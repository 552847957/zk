<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book lang="ja-JP">
<bookinfo>
    <title>ZK開発者ガイド</title>
	 <copyright>
      <year>2007</year>
      <holder>Potix Corporation. All rights reserved.</holder>
	</copyright>
</bookinfo>
<para>
</para>
<para/>
<chapter><title>はじめに</title><para>ようこそ、ウェブアプリケーションのコンテンツを豊富にする最も簡単な方法、ZKへ。</para>
<para>本資料はZKの内容と特徴が書いてあります。インストールの際にはクイックスタートガイド(Quick Start Guide)をご覧ください。また、操作方法と内容の詳細については the Developer's Referenceを参照してください。</para>
<para>この章はウェブプログラミング・Ajax技術・ZKプロジェクトにおける現在までの流れを説明します。ZKの特徴についてすでにご存知でしたら、この章を飛ばしても構いません。</para><sect1><title>従来のウェブアプリケーション</title>
<para>効率的に簡単にウェブ上の情報を交換する目的として、Web技術、HTTPとHTMLはページをベースにした方式とステートレスモデルを基にしていました。このモデルの中では、ページは独立したものであり、クライアントとサーバーの間の最小のコミュニケーション単位でもあります。</para>
<para>
  <graphic fileref="img/1.png" align="center"/>
ウェブが次世代のアプリケーション進化として現れたとき、このモデルは本質的な試練に直面しました：今日のアプリケーションの中で視覚的に複雑さをあらわせないという問題です。たとえば、ユーザーに見積もりを見せるため、他のページを開いて自分の取引の記録探す、または最近の値段のページを開く、あるいは現在の株価のページを開かなければなりません。ユーザーは現在作業しているページをそのままにし、いくつものページ間を移動しなければなりません。ユーザーはページ間で簡単に迷子になるし、混乱しやすいです。結果として、ユーザーは機嫌を損ね、売り上げが落ち、生産力も下がります。</para>
<para>ページをベースにあした方式に頼る近代のアプリケーションを進化させるのは一つの挑戦で、本質に関わる問題です。このモデルではサーバー上で作動しているアプリケーションは全てを見なければいけません。リクエストに応えること、返答を送付すること、ユーザーをページと他のページに結び付ける過程を順番付けること、エラーを処理することなどです。そこでStruct・Tapestry・JSFなど多数のフレームワークが進化過程を簡単にするため開発されました。ページ方式と近代のアプリケーションとの大きな差によって、これらの構造は理解しにくいし、使うことは楽しいものではなく、簡単でも直感的なものでもありませんでした。</para></sect1><sect1><title>Ad-hoc AJAX アプリケーション</title><para>
進化期間を終えて、ウェブアプリケーションは静的なHTMLのページから動的なHTMLへと、アプレットとフラッシュへと、そして、最後にはAjax<footnote>
<para>AJAXとはJesse James Garrett氏がAjax: A New Approach to Web Applicationsで提出したものです。</para>
</footnote>技術(非同期、JavaスクリプトとXML)まで至りました。Google マップ とSuggestによって示されているように、AJAXは対話性と返答機能を提供することにより、新しい生命をウェブアプリケーションに吹き込みました。アプレットやFlashとは違ってAJAXは標準的なブラウザとJavaScriptを基盤としており、AJAXだけのプラグインは必要ありません。</para><graphic fileref="img/1-2.png" align="center"/>
<para>AJAXはDHTMLのような新しい世代です。というのはDHTMLのように、JavaScriptに深く依存しています。ユーザーの操作によって行われるイベントを監視し、ブラウザの中で動的にページ(aka.DOM)の視覚表現をうまく処理します。ページをそのままにしたり、再び送付したりすることなく、非同期でサーバーとのやり取りするを可能にすることで、更に進化をさせます。クライアントとサーバーの間の簡単なやり取りでページ方式を変えています。適切なデザインで、AJAXはデスクトップアプリケーションのように豊富な内容をウェブウェブアプリケーションに提供し、全ての内容はアプリケーションのコントロールの下、動的に更新されます。</para>
<para>AJAXでユーザーが期待する対話機能を達成するのは元々コスト高のウェブアプリケーション開発にさらに開発費用を増やします。開発者はブラウザ側でDOMを処理すると同時に、バグだらけのJavaScript APIを通してサーバーとコミュニケーションを取らなければなりません。さらに、より高度な対話を実現するため、開発者はアプリケーションデータやビジネスロジックをブラウザにコピーしますが、それによってメンテンのコストとデータ同期の難度はより高くなります。</para>
<para>結論として、リクエストの処理について、ad-hoc AJAXのアプリケーションと従来のウェブアプリケーションのとは同じです。また、開発者は依然としてページ方式とステートレスモデルによって起こるギャップを埋めなければなりません。</para></sect1><sect1><title>ZKとは？</title><para>ZKはイベント駆動型コンポーネンツをベースにした、豊富なユーザーインターフェースのあるウェブアプリケーションを可能にするフレームワークです。ZKはAjJaxをベースにした駆動型エンジンと豊富なXUL・XHTMLコンポーネンツ集とZUMLと呼ばれる(ZK User Interface Markup Language)マークアップ言語を提供しています。</para>
<para>ZKの特徴のある多彩なXULとXHTMLコンポーネンツでアプリケーションを表現することができます。何年間もデスクトップアプリケーションの中でしてきたように、ユーザー操作によって行われるイベントはXULとXHTMLにより処理しています。ほとんどの構成とは違い、AJAXは舞台裏の技術です。コンポーネンツの同期とイベントの並行処理はZKエンジンにより自動的に行われます。</para>
<para>デスクトップアプリケーションを開発する簡単なレベルで、同じ程度の対話と応答ができます。</para>
<para>シンプルなモデルと豊富なコンポーネンツに加え、ZKはZUMLと呼ばれるマークアップ言語をサポートしています。ZUMLはXHTMLのようなもので、開発者にユーザーインターフェースをプログラムなしでデザイン可能にしています。XMLのネームスペースを用いて、ZUMLはシームレスに異なったタグ<footnote>
<para>タグはXML要素です。コンポーネントはZUMLページが翻訳された時に生成されました。</para>
</footnote>セットを同じページに組み込むことができます。現在、ZUMLはXULとHTMLの二つのタグセットに対応しています。</para>
<para>迅速なプロトタイピングやカスタマイズ化するため、開発者はZUMLにてELまたはJava<footnote>
<para>JavaインタープリターはBeanShell (http://www.beanshell.org)を使用します。</para>
</footnote>・JavaScript<footnote>
<para>JavaScriptインタープリターはRhino (http://www.mozilla.org/rhino)を使用します。</para>
</footnote>・Ruby<footnote>
<para>RubyインタープリターはJRuby (http://jruby.codehaus.org/)を使用します。</para>
</footnote>・Groovy<footnote>
<para>GroovyインタープリターはGroovy (http://groovy.codehaus.org/)を使用します。</para>
</footnote>等のスクリプトを使用することができます。必要がなければ開発者はスクリプトを使わなくても結構です。JavaScriptがHTMLに埋め込まれているのと違って、ZKはサーバー側でスクリプトを実行します。</para>
<para>ここで全てのタスクはサーバー側で実行しているというのは開発者の立場で言ったものです。コンポーネントを開発する開発者は対話とシンプルのバランスを取りながら、それぞれのタスクがサーバー側またはクライアント側いずれかで決定しなければなりません。</para></sect1><sect1><title>ZKでないものとは？</title><para>ZKはサーバー同士の通信と耐久性について設計したものではありません。ZKはできる限り小さく設計されています。それは、ZKはプレゼンテーション層を目的としているからです。バックエンドの技術を必要としていないし、推奨もしていません。JDBC、Hibemate、Java Mail、EJB or JMSなど 全てのミドルウェアーは今まで動いていたように作動します。</para>
<para>ZKはクライアントとサーバー間を通信する開発者のための通信路、RMI又は他のAPIを提供していません。なぜなら、全てのコードは同じJVMを使用し、サーバーで作動してるからです。</para>
<para>ZKは開発者にMVCや他のデザインパターンを強制的に使わせません。それを使うかどうかは開発者が選択します。</para>
<para>ZKはXULをウェブアプリケーションに提供することを目的としたフレームワークではありません。デスクトッププログラムモデルをウェブアプリケーションに提供することを目的としています。ZKは現在ではXULとXHTMLが使用可能で、将来的にはXAMLとXQueryまたは他の言語に対応することは可能です。</para>
<para>現在、ZKはAJAXを組み込んでいますが、それだけではありません。近い将来、ZKモバイルを用いて、今開発したウェブアプリケーションはそのまま<footnote>
<para>画面のサイズに合わせて調整する必要がある場合があります。</para>
</footnote>PDA・モバイル・ゲーム等J2MEが使えるデバイスに適用できます。</para></sect1><sect1><title>ZKの制限</title><para>ZKは3Dゲームのような、ほとんどのタスクがクライアント側で実行されるアプリケーションのためにあるのではありません。</para>
<para>特別なコンポーネントを作らない限り、ZKはクライアント側の能力を有効に利用するアプリケーションのためにあるのではありません。</para></sect1></chapter><chapter><title>さあ、はじめましょう</title><para>この章ではどのようにZUMLページを作成するか説明しています。お時間のない方でも、必ずこの章を読んでください。</para>
<para>この章ではXULを用いてZKの特徴を説明しますが、ZKで使用可能な他のマークアップ言語も通用できます。</para><sect1><title>Hello World!</title>
<para>ZKをウェブサーバー<footnote>
<para>クイックスタートガイドをご覧ください。</para>
</footnote>にインストールしたら、アプリケーションを作成することは難しくありません。下の例を参考にして<footnote>
<para>本資料にある例のライブデモを見ることもできます。</para>
</footnote> 適切なディレクトリの下にhello.zulファイルを作りましょう。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
    Hello World! 
&lt;/window&gt;</programlisting>
<para>そうして、間違えないように <ulink url="http://localhost/myapp/hello.zul">http://localhost/myapp/hello.zul</ulink>
を参照すれば以下の結果が表示されます。
</para>
<para>
<graphic fileref="img/2-1.png"  align="center"/>ZUMLページの中で、XML要素はどんなコンポーネントを作るかを説明しています。この例では、ひとつのウィンドウです（<code>org.zkoss.zul.Window</code>）。XMLの属性はウィンドウコンポーネントプロパティの値を指定する際に使います。この例では、<code>title</code>と<code>border</code>プロパティを「Hello」と「normal」にそれぞれ設定し、ウィンドウが作られています。</para>
<para>XML要素の中で括弧を付けたテキストは<code>label</code>（<code>org.zkoss.zui.Label</code>）と呼ばれる特別なコンポーネントとして指定されます。このようにして、上の例は下記のものと同じ内容になります。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
  &lt;label value="Hello World!"/&gt;
&lt;/window&gt;</programlisting></sect1><sect1><title>対話</title>
<para>いくつかの対話機能を加えてみましょう。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
   &lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;
&lt;/window&gt;</programlisting>
<para>ボタンをクリックしたら、以下のようなものが表示されます。</para>
<para>
<graphic fileref="img/2-2c.png"  align="center"/>
<code>onClick</code>属性の機能はコンポーネントにイベントリスナを付け加えます。属性の値はJavaコードであれば何でも構いません。ZKは<code>&amp;quot</code>でダブルコーテーションマーク（”）を表現し、標準的なXMLにします。XMLをよくご存じでないなら、「ZKユーザーインターフェースマークアップ言語」の章の「XML」セクションを見てください。</para>
<para><code>alert</code>ファンクションはダイアログボックスを表示するためのグローバルファンクションです。それは<code>org.zkoss.zui.Messagebox</code>クラスの<code>show</code>コマンドへのショートカットです。</para>
<programlisting>&lt;button label="Say Hello" onClick="Messagebox.show(&amp;quot;Hello World!&amp;quot;)"/&gt;</programlisting>
<para>【補足】：</para>
<orderedlist>
<listitem>
<para>ZUMLに組み込まれているスクリプトはJava・JavaScript・Ruby・Groovyに限らずに、異なった言語で編集することができます。さらにそれらはサーバーで実行されます。</para>
</listitem>
<listitem>
<para>ZKは実行中にBeanShellを使ってJavaを翻訳します。つまり、<code>alert</code>といったグローバルファンクションを宣言することができます。同じように、ほとんどのスクリプト言語ではグローバルファンクションは簡単に定義できます。クラスを簡単に定義できる言語は少ないですが存在します。</para>
</listitem>
<listitem>
<para><code>Java.lang、java.util、org.zkoss、sk.ui、org.zkoss.zk.ui.event、org.zkoss.zuil</code>のパッケージにあるすべてのクラスはZUMLページに組み込まれているスクリプトコードを処理する前に挿入されています。</para>
</listitem>
</orderedlist></sect1><sect1><title><code>zscript</code>要素</title>
<para><code>zscript</code>はZUMLページが生成された際、処理されるスクリプトコードを定義する特別な要素です。代表的な使用方法は初期化、グローバル変数及びメソッドの宣言です。</para>
<para>【補足】：<code>zscript</code>ではELを使用できません。</para>
<para>たとえば、下の例はボタンが押されるたびに、異なったメッセージを表示します。.</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="sayHello()"/&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;int count = 0;
&nbsp;&nbsp;&nbsp;void sayHello() { //declare a global function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert("Hello World! "+ ++count);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&lt;/window&gt;</programlisting>
<para>【補足】：<code>zscript</code>はページを読み込むときに一度だけ、翻訳します。それは大抵、初期変数とメソッドを定義します。</para><sect2><title>スクリプト言語</title>
<para>デフォルトで、スクリプト言語はJavaに設定されています。しかし、<code>language</code>属性を使えば異なった言語を選ぶことができます。なお、<code>language</code>は大文字と小文字を識別します。</para>
<programlisting>&lt;zscript language="javascript"&gt;
&nbsp;&nbsp;&nbsp;alert('Say Hi in JavaScript');
&nbsp;&nbsp;&nbsp;new Label("Hi, JavaScript!").setParent(win);
&lt;/zscript&gt;</programlisting>
<para>イベントハンドラのスクリプト言語を指定するために、以下のように言語名（この例ではjavascript）を前置き記述します。【補足】：言語名の前後にはスペースを入れてはいけません。</para>
<programlisting>&lt;button onClick="javascript: do_something_in_js();"/&gt;</programlisting>
<para>これによって、同じページに異なった言語でスクリプトを書くことができます。</para></sect2><sect2><title>別ファイルの中のスクリプト</title><para>コードとビューを別にするために、開発者はスクリプトコードを他のファイルに保存することができます。たとえば<code>sayHello.zs</code>と作り、それから、<code>src</code>属性を使いそれを参照します。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="sayHello()"/&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript src="sayHello.zs"/&gt;
&lt;/window&gt;</programlisting>
<para><code>sayHello.zs</code>の中身は以下のようにします。</para>
<programlisting>int count = 0;
void sayHello() { //declare a global function
&nbsp;&nbsp;&nbsp;alert("Hello World! "+ ++count);
}</programlisting>
</sect2></sect1><sect1><title><code>attribute</code>要素</title><para><code>attiribute</code>要素は要素(ここでは<code>button</code>)のXML属性を定義する要素です。適切に使えばページがより読みやすくなります。以下のコードは上に紹介した<code>hello.zul</code>と同様です。</para>
<programlisting>&lt;button label="Say Hello"&gt;
&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;alert("Hello World!");&lt;/attribute&gt;
&lt;/button&gt;</programlisting>
<para>以下のように<code>trim</code>を設定するより、入力時のスペースを無視するかどうか決めることができます。デフォルトでは <code>trim</code>が設定されていません。</para>
<programlisting>&lt;button&gt;
&nbsp;&nbsp;&nbsp;&lt;attribute name="label" trim="true"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The leading and trailing whitespaces will be omitted.
&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&lt;/button&gt;</programlisting></sect1><sect1><title>EL 表記</title><para>属性の名前や、要素、プロセスの指令を除いて、JSPのように、ZUMLのどの部分でもEL表記を使うことができます。</para>
<para>EL表記は構文<code>${expr}</code>を使います。例えば、</para>
<programlisting>&lt;element attr1=”${bean.property}”.../&gt;
${map[entry]}
&lt;another-element&gt;${3+counter} is ${empty map}&lt;/another-element&gt;</programlisting>
<para>【ヒント】： <code>empty</code>はマップ、集合、配列、文字列が空(null)かどうかをテストする演算子です。</para>
<para>【ヒント】： <code>map[entry]</code>はマップの要素にアクセスする方法です。つまり、Javaで言う、<code>map.get(entry)</code>と同じです。</para>
<para>EL表記が属性の値として使われるとき、コンポーネントがその値を受け取れる限り、戻り値はどのようなオブジェクトでも構いません。たとえば、以下の表記はBooleanオブジェクトとして処理されます。</para>
<programlisting>&lt;window if="${some &gt; 10}"&gt;</programlisting>
<para>【ヒント】： ELの中の<code> + operator</code>は算術です。文字列の連結処理はしません。文字列の連結は<code>”${exprl} is added with ${expr2}”</code>でできます。</para>
<para><code>param</code>と<code>requestScope</code>のような標準的な暗黙オブジェクトと<code>self<code>と</code>page</code>のようなZKの暗黙オブジェクトは簡単に使えるようになっています。</para>
<programlisting>&lt;textbox value="${param.who} does ${param.what}"/&gt;</programlisting>
<para>EL機能をTLDファイルから挿入するために、以下のように<code>taglib</code>と呼ばれるプロセス指令が使えます。</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.tld" prefix="p" ?&gt;</programlisting>
<para>The Developer's Reference にEL表記の詳細が書かれています。または、JSP2.0チュートリアルかガイドを参照してください。</para></sect1><sect1><title><code>id</code>属性</title><para>JavaコードとEL表記の中のコンポーネントにアクセスするために、<code>id</code>という属性を使って識別子を指定することができます。以下の例では、識別子をラベルに指定し、ボタンが押された時にその値を処理できます。</para>
<para/>
<programlisting>&lt;window title="Vote" border="normal"&gt;
&nbsp;&nbsp;&nbsp;Do you like ZK? &lt;label id="label"/&gt;
&nbsp;&nbsp;&nbsp;&lt;separator/&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Yes" onClick="label.value = self.label"/&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="No" onClick="label.value = self.label"/&gt;
&lt;/window&gt;</programlisting>
<para>Yesボタンを押したのち、下記のように表示されます。</para>
<para>
<graphic fileref="img/2-6a.png"  align="center"/>以下はEL表記の中のコンポーネントを参照する例です。</para>
<programlisting>&lt;textbox id="source" value="ABC"/&gt;
&lt;label value="${source.value}"/&gt;</programlisting></sect1><sect1><title><code>if</code>と<code>unless</code>属性</title><para><code>if</code>と<code>unless</code>属性によりコンポーネントを生成するかどうかが決められます。下の例では、リクエストが<code>vote</code>というパラメーターを持つ場合のみ、二つのラベル(コンポーネント)が両方とも作られます。</para>
<programlisting>&lt;label value="Vote 1" if="${param.vote}"/&gt;
&lt;label value="Vote 2" unless="${!param.vote}"/&gt;</programlisting>
<para>二種類の属性が同時に指定された場合、ともに正しい(True)と判断されない限り、コンポーネントは作られません。</para></sect1><sect1><title><code>forEach</code>属性</title><para><code>forEach</code>属性によりどれくらいコンポーネントが作られるかが決められます。この属性にオブジェクトの集合を指定したら、ZKローダーが集合にあるそれぞれの項目にコンポーネントを作成します。たとえば、以下のZUMLページの中で、<code>listitem</code>要素が三回 (Mondayと Tuesdayと Wednesdayを)指定したので、三つのリスト項目が作成されます。</para>
<programlisting>&lt;zscript&gt;contacts = new String[] {"Monday", "Tuesday", "Wednesday"};&lt;/zscript&gt;
<inlinegraphic fileref="img/2-8.png" align="right" />&lt;listbox width="100px"&gt;
&nbsp;&nbsp;&lt;listitem label="${each}" forEach="${contacts}"/&gt;
&lt;/listbox&gt;</programlisting>
<para><code>forEach</code>属性を使って要素を処理する際、<code>each</code> 変数はひとつずつ集合のオブジェクトより値が指定されます。たとえば、ひとつ前の例の<code>contacts</code>です。ですので、上記のZUMLページは以下のものとは同様です。</para>
<programlisting>&lt;listbox&gt;
&nbsp;&nbsp;&lt;listitem label="Monday"/&gt;
&nbsp;&nbsp;&lt;listitem label="Tuesday"/&gt;
&nbsp;&nbsp;&lt;listitem label="Wednesday"/&gt;
&lt;/listbox&gt;</programlisting>
<para><code>forEach</code>に加えて、<code>forEachBegin</code>と<code>forEachEnd</code>を使って繰り返すこともできます。詳細は「ZKユーザーインターフェースマークアップ言語」の「ZK属性」の章をご覧ください。</para></sect1><sect1><title><code>use</code>属性</title><para>ページ中に不適切に組み込まれているコードはメンテナンスの際に問題を起こさせるかもしれません。ビューからコードを分離させるには二つの方法があります。</para>
<para>一つ目は、大事なイベントに注目し、それに応じて、適切なメソッドを適用します。たとえば、初期化、プロセス、取り消しをそれぞれ<code>onCreate</code><footnote>
<para>ZUMLページに定義されたウィンドウが生成されたら、onCreateイベントが送信されます。</para>
</footnote>、<code>onOK</code><footnote>
<para>ユーザーがリターンキーを押したら、onOKイベントが送信されます。</para>
</footnote>、<code>onCancel</code><footnote>
<para>ユーザーがESCキーを押したら、onCancelイベントが送信されます。</para>
</footnote>で対応します。</para>
<programlisting>&lt;window id="main" onCreate="MyClass.init(main)"
&nbsp;&nbsp;&nbsp;onOK="MyClass.process(main)" onCancel="MyClass.cancel(main)"/&gt;</programlisting>
<para>なお、MyClassというJavaクラスが存在しなければなりません。</para>
<programlisting>import org.zkoss.zul.Window;

public class MyClass {
&nbsp;&nbsp;&nbsp;public static void init(Window main) { //does initialization
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public static void save(Window main) { //saves the result
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public static void cancel(Window main) { //cancel any changes
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>二つ目の方法は、<code>use</code>属性によりクラスを指定してデフォルトコンポーネントクラスを取り換えます。</para>
<programlisting>&lt;window use="MyWindow"/&gt;</programlisting>
<para>そして、以下のようにMyWindowというJavaクラスが存在しなければなりません。</para>
<programlisting>import org.zkoss.zul.Window;

public class MyWindow extends Window {
&nbsp;&nbsp;&nbsp;public void onCreate() { //does initialization
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public void onOK() { //save the result
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public void onCancel() { //cancel any changes
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>これら二つのアプローチは異なった利点があります。これらは二つともMVCモデルのコントローラーとして作動しています。どちらを使うのかはユーザーの選択です。</para><sect2><title><code>zscript</code>でJavaクラスを実装</title><para>BeanShell<footnote>
<para>http://www.beanshell.org</para>
</footnote>のおかげで、以下のようにJavaクラスは<code>zscript</code>で実装することができます。</para>
<programlisting>&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;public class MyWindow extends Window {
&nbsp;&nbsp;&nbsp;}
&lt;/zscript&gt;
&lt;window use="MyWindow"/&gt;</programlisting>
<para>【ヒント】： JRuby 等多くのスクリプト言語では、開発者はJVMにアクセスできるクラスを定義できます。詳しくは関連したマニュアルを参照してください。</para>
<para>コードをビューから分けるのに、全ての<code>zscript</code> コードを別ファイルに置くことができます。たとえば、 <code>mywnd.zs</code>ファイルに。そして以下のようにパスを指定します。</para>
<programlisting>&lt;zscript src="/zs/mywnd.zs"/&gt;
&lt;window use="MyWindow"/&gt;</programlisting>
<para>【ヒント】： <code>init</code> 指令で<code>zscript</code>を指定するのも可能です。その違いは、<code>init</code>指令は全てのコンポーネントが生成される前に(Pageの初期の時点で)処理されます。「ZKユーザーインターフェースマークアップ言語」の「<code> init</code>コマンド」セクションを参考にしてください。</para></sect2></sect1><sect1><title>手動でコンポーネントを作る</title>
<para>ZUMLページで作られるコンポーネントの記述に加え、開発者は手動でそれらを作ることもできます。すべてのコンポーネントのクラスは結合体で、直接<footnote>
<para>簡素化するため、ここではファクトリデザインパターンが使われていません。</para>
</footnote> 構築子から作られます。</para>
<programlisting>&lt;window id="main"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Add Item"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;new Label("Added at "+new Date()).setParent(main);
&nbsp;&nbsp;&nbsp;new Separator().setParent(main);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;separator bar="true"/&gt;
&lt;/window&gt;</programlisting>
<para>コンポーネントが手動で作られたとき、自動的にページに付け加えられることはありません。つまり、ユーザーのブラウザには現れません。ページにそれを追加するため、<code>setParent</code>・<code>appendChild</code>・<code>insertBefore</code>を使い、親とそれをつなげます。そうすれば親がページの一部であれば、そのコンポーネントもページの一部になります。</para>
<para>コンポーネントを削除したり、クローズしたりする方法はありません<footnote>
<para>W3C DOMのコンセプトと類似です。一方、Windows APIでは、開発者はライフサイクルを管理しなければなりません。</para>
</footnote>。コンポーネントがページから離れるとすぐに、ブラウザからも離れてしまいます。ページにつけられるとすぐに表示されます。</para>
<programlisting>&lt;window id="main"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;Component detached = null;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;button id="btn" label="Detach"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;if(detached != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detached.setParent(main);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detached = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btn.label = "Detach";
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(detached = target).setParent(null);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btn.label = "Attach";
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;separator bar="true"/&gt;
&nbsp;&nbsp;&nbsp;&lt;label id="target" value="You see this if it is attached."/&gt;
&lt;/window&gt;</programlisting>
<para>上の例では、<code>setVisible</code>方法を使えば同じような効果があります。しかしながら、<code>setVvisible(false)</code>はブラウザからコンポーネントを取り除きません。ただ、コンポーネント（とすべての子ページ）を見えなくします。</para>
<para>コンポーネントがページから離れると、使っていた(使わなくなった)メモリーはJVMのガーベージコレクタよりリリースされます。</para><sect2><title>ZUMLを使わずにZKアプリケーションを開発</title><para>ZUMLを使わない開発者は、いわゆるrichletを使ってすべてのコンポーネントを手動で作ることができます。</para>
<programlisting>import org.zkoss.zul.*;
public class TestRichlet extends org.zkoss.zk.ui.GenericRichlet {
&nbsp;&nbsp;&nbsp;public void service(Page page) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page.setTitle("Richlet Test");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Window w = new Window("Richlet Test", "normal", false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Label("Hello World!").setParent(w);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Label l = new Label();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.setParent(w);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.setPage(page);
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>「アドバンス機能」のリッチレット部分をご覧ください。</para></sect2></sect1><sect1><title>ページに新しいコンポーネントを定義する</title>
<para>下記の例のように、XML属性でプロパティをコンポーネントに指定することは簡単です。</para>
<programlisting>&lt;button label="OK" style="border:1px solid blue"/&gt;</programlisting>
<para>開発者に特定ページに新しいコンポーネントを定義させ、パワフルで簡単な方法をZKは提供しています。多くの同じタイプのコンポーネントがプロパティセットを共有する場合は便利です。</para>
<para>はじめに <code>component</code>指令を使って新しいコンポーネントを定義します。</para>
<programlisting>&lt;?component name="bluebutton" extends="button" style="border:1px solid blue" label="OK"?&gt;

&lt;bluebutton/&gt;
&lt;bluebutton label="Cancel"/&gt;</programlisting>
<para>は以下の内容と同様です。</para>
<programlisting>&lt;bluebutton style="border:1px solid blue" label="OK"/&gt;
&lt;bluebutton style="border:1px solid blue" label="Cancel"/&gt;</programlisting>
<para>さらに、以下のように<code>button</code>の定義を無効にすることができます。もちろん他のどのページには、影響ありません。</para>
<programlisting>&lt;?component name="button" extends="button" style="border:1px solid blue" label="OK"?&gt;

&lt;button/&gt;
&lt;button label="Cancel"/&gt;</programlisting>
<para>より詳しい情報は「ZKユーザーインターフェースマークアップ言語」の「<code> component </code>コマンド」セクションをご覧ください。</para></sect1></chapter><chapter><title>基礎</title>
<para>この章はZKの基礎を説明します。XULを使ってZKの特徴を表していますが、ZKで使用できる他のマークアップ言語も大抵、使うことができます。</para><sect1><title>構造</title>
<para>ZKはAJAX方式の構造を用いて対話を自動化し、XUL方式のコンポーネントのセットにより使い勝手を良くし、マークアップ言語を使用することより開発を簡単化しています。AJAX方式は下にかいてあるように三つの構造から成っています。ZKローダー、ZK AUエンジン、ZKクライアントエンジン</para>
<para/>
<para>
<graphic fileref="img/3-1.png"  align="center"/>ユーザーリクエストを基にして、ZKローダーはZKページを読み込んで翻訳し、結果をURLで指定されたHTMLページに表示します。ZKページはZUMLと呼ばれるマークアップ言語で書かれています。ZUMLはHTMLに似ていて、視覚的にどのように表示するかと、どんなコンポーネントを作成するかが書かれています。これら一度作られたコンポーネンツはセッションが時間切れになるまで、使うことができます。</para>
<para>ZK AU<footnote>
<para>AUはAsynchronous Updateの省略です。</para>
</footnote>エンジンとZKクライアントエンジンは投手と捕手のような関係です。それらはサーバーで作動しているアプリケーションにブラウザ上のイベントを配信し、ブラウザ上でアプリケーションにより操作されているコンポーネントを基にしてDOMツリーを更新します。これがいわゆるイベント駆動型のプログラミングモデルです。</para><sect2><title>実行の流れ</title>
<orderedlist>
<listitem>
<para>URLを入力するか、また、ブラウザ上でハイパーリンクをクリックしたとき、リクエストはウェブサーバーに送られます。もしそのURLがZKに照合されたら、ZKローダーが呼び出され、このリクエストを処理します<footnote>
<para>the Developer's ReferenceのAppendix Aをご覧ください。</para>
</footnote>。</para>
</listitem>
<listitem>
<para>ZKローダーは指定されたページを読み込み、翻訳し、それに応じて、適切なコンポーネントを作成します。</para>
</listitem>
<listitem>
<para>1ページすべてを翻訳した後、ZKローダーはHTMLページに結果を表示します。そのHTMLページはZKクライアントエンジン<footnote>
<para>ZKクライアントエンジンはJavaScriptで作成されました。ブラウザはZKクライアントエンジンをキャッシュしますので、エンジンは大抵、最初の一回目のみ送信されます。</para>
</footnote>とともにブラウザへ送り返されます。</para>
</listitem>
<listitem>
<para>ZKクライアントエンジンはブラウザ側にあり、ユーザーによって行われた、マウス移動、値の変化のようなイベントを検出します。一度、検出すると、ZK AUエンジンにZKリクエスト<footnote>
<para>ZKリクエストは特別なAJAXリクエストですが、ZKモバイルの場合、ZKリクエストは特別なHTTPリクエストです。</para>
</footnote>を送ることによって通知します。</para>
</listitem>
<listitem>
<para>クライアントエンジンからZKリクエストを受け取ることで、AUエンジンは、必要ならコンポーネントの内容を更新します。そして、AUエンジンは関連するイベントハンドラーを呼び出すことによって、アプリケーションに通知します。</para>
</listitem>
<listitem>
<para>もし、アプリケーションがコンポーネントの内容を改変したり、移動させたり、つけ足したりしたら、AUエンジンは改変されたコンポーネントの新しい内容をクライアントエンジンにZKのレスポンスにより送ります。</para>
</listitem>
<listitem>
<para>これらZKのレスポンスはDOMツリーの状況に応じた更新方法をクライアントエンジンに指示するメソッドです。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>コンポーネンツ、ページ と デスクトップ</title><sect2><title>コンポーネンツ</title>
<para>コンポーネンツはラベル、ボタン、ツリーのようなUIオブジェクトです。それらは視覚的な表現と特定ユーザーインターフェースの動作を定義します。それらを操作することで、開発者はクライアント側の視覚的なアプリケーションの表し方をコントロールします。</para>
<para>コンポーネントは<code>org.zkoss.zk.ui.Component</code>インターフェースを実装しなければなりません。</para></sect2><sect2><title>ページ</title>
<para>ページ(<code>org.zkoss.zk.ui.Page</code>) はコンポーネンツの集合です。それぞれのコンポーネントはブラウザのある部分で表示されています。ZKローダーがZUMLのページを翻訳したときにページは自動的に作成されます。</para><sect3><title>ページのタイトル</title>
<para>どのページでも、ブラウザウィンドウのキャプションにタイトルを追加できます。詳しくは「ZKユーザーインターフェースマークアップ言語」の「プロセシングコマンド」セクションを参照してください。</para>
<programlisting>&lt;?page title="My Page Title"?&gt;</programlisting></sect3></sect2><sect2><title>デスクトップ</title>
<para>
<graphic fileref="img/3-2-3a.png"  align="center"/>ZUMLページは直接的にまたは間接的にほかのZUMLページを含んでいます。これらのページは同じURLにつながっているので、まとめてデスクトップ(<code>org.zkoss.zk.ui.Desktop</code>)と呼ばれています。つまりデスクトップとは同じURLにつながっているページの集合です。</para>
<para>ZKアプリケーションがユーザーと対話するとき、ページがデスクトップに追加されたり、またいくつかがデスクトップから削除されます。同様に、ページからコンポーネントがつけ足されたり、消されたりします。</para><sect3><title><code>createComponents</code>メソッド</title><para>ページとデスクトップは自動的に作られたり、消されたりします。それらを消したり作ったりするAPIはありません。ZUMLがページを読み込むたびにページが作成され、ZKがこれ以上参照しないと認識したときにページは削除されます。最初のZUMLページが読み込まれた時にデスクトップは作成され、一つのセッションに対して、デスクトップが多く作られすぎたときに消されます。</para>
<para><code>org.zkoss.zk.ui.Executions</code>クラスの<code>creatComponents</code>メソッドはページではなくてコンポーネントだけ作成します。また、ZUMLファイル(aka.,page)を読み込んだ時も同様です。</para></sect3></sect2><sect2><title>コンポーネンツの森</title>
<para>一つのコンポーネントは一つ以上の親コンポーネントを持つことができません。一つのコンポーネントには複数の子コンポーネントを持つことがあります。あるコンポーネントは特定の種類のコンポーネントのみを子として受け入れます。また別のコンポーネントは全く子をとりません。たとえば、XUL中のListboxはListcolsとListitemだけを受け入れます。詳しいことが知りたければ、JavadocまたはXULチュートリアルを参照してください。</para>
<para>親のいないコンポーネントはルートコンポーネントと呼ばれます。一つのページは複数のルートコンポーネントから成り立っていることがあります。なお、ルートコンポーネントは<code>getRoots</code>メソッドによって検索できます。</para></sect2><sect2><title>コンポーネント：視覚表現とJavaオブジェクト</title>
<para>サーバー中でジャバオブジェクトになる他に、コンポーネントはブラウザ上で視覚要素<footnote>
<para>ブラウザがクライアントのであれば、視覚的な表現はDOM要素かその集合です。</para>
</footnote>を担当します。ただし、それはただ一ページのみに属している場合です。コンポーネントがページに添付されているとき、その視覚要素は作成されます<footnote>
<para>ビジュアル部分は自動的に生成・更新・削除されます。開発者はそれを処理する必要はほとんどありません。開発者主なタスクはサーバー側のオブジェクトを処理することです。</para>
</footnote>。コンポーネントがページから外れるとき、視覚部分はなくなります。</para>
<para>ページにコンポーネントを添付する方法は二つあります。まず一つ目は<code>setPage</code>メソッドを呼び出して、任意のコンポーネントをそのページのルートコンポーネントにします。二つ目は<code>setParent</code>・
<code>insertBefore</code>・<code>appendChild</code>メソッドを呼び出す方法で、コンポーネントを他に所属している子コンポーネントにすることができます。そして、子コンポーネントは親が属しているページと同じページに属することになります。</para>
<para>同様にして、<code>null</code>と一緒に<code>setPage</code>を呼び出すことでページからルートコンポーネントを外すことができます。子は親から離れる、または親がページを離れることで外れます。</para>
<para/></sect2><sect2><title>識別子</title>
<para>どのコンポーネントも識別子(<code>getId</code>メソッド)を持っています。識別子はコンポーネントが作成されるとき自動的に作成され、開発者はいつでもそれを編集することができます。識別子に名前をつける制限はありません。しかしながら、識別子がアルファベットで指定されたら、ZUMLページに組み込まれているJavaコードとEL表記で直接アクセスすることができます。</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;
&nbsp;&nbsp;&nbsp;Do you like ZK? &lt;label id="label"/&gt;
&nbsp;&nbsp;&nbsp;&lt;separator/&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Yes" onClick="label.value = self.label"/&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="No" onClick="label.value = self.label"/&gt;
&lt;/window&gt;</programlisting></sect2><sect2><title>UUID</title>
<para>コンポーネントはUUID(Universal Unique ID)という別の識別子を持っていますが、アプリケーション開発者はめったに使用しません。</para>
<para>UUIDはコンポーネントとクライアントエンジンによって使われ、ブラウザ上でDOMを操作したり、サーバーと通信するために使われます。より正しく言うと、クライアント上にあるDOM要素の<code>id</code>属性はUUIDです。</para>
<para>UUIDはコンポーネントが作られるときに自動で作られます。UUIDのうちでHTMLタグを表すコンポーネントの識別子以外は、変えることができません。</para>
<para>HTMLに関連するコンポーネントはUUIDを他のコンポーネンツと異なる方法で処理します。UUIDはIDと同じです。もしHTML関連のコンポーネントのIDを変えてしまったら、UUIDはそれに応じて変わります。この特性によって、古いJavaScriptコードとサーブレットは前のまま使うことができます。</para></sect2></sect1><sect1><title>IDスペース</title>
<para>視覚表現をいくつかのZUMLページに分けるのはよくあることです。たとえば、注文購入のページ、支払いモーダルのダイアログ。すべてのコンポーネントが同じデスクトップで認識できるのなら、開発者は一つのデスクトップに追加されるすべてのページに対して、すべての認識子を独特なものにしなければなりません。</para>
<para>IDスペースのコンセプトはこの問題を解決するため導入したものです。IDスペースはデスクトップコンポーネントのサブセットです。その唯一性はIDスペース内でのみ保障されています。</para>
<para>IDスペースのもっとも簡単な形はウィンドウ（<code>org.zkoss.zul.Window</code>）です。ひとつのウィンドウ（ウィンドウ自体を含む）との子コンポーネンツコンポーネントは独立したIDスペースを形作ります。このようにして、ウィンドウをそれぞれのページの最上段のコンポーネントとして使えます。そうして開発者はそれぞれのページ別々に唯一性を保持する必要があります。</para>
<para>一般的に、<code>org.zkoss.zk.ui.IdSpace</code>インターフェースを実装する限り、どのコンポーネントもIDスペースを形成できます。ページはまた<code>IdSpace</code>インターフェースを実装するので、ページは空間所有者なのです。</para>
<para>最上段のIDスペースコンポーネントはIDスペースの所有者と呼ばれていて、<code>Component</code>インターフェースの中から<code>getSpaceOwner</code>メソッドによってIDスペースを引き出すことができます。</para>
<para>IDスペース、例えばXは他のIDスペースの子で、X空間の所有者はY空間に含まれています。しかし、Xの子はY空間には含まれていません。</para>
<para>下図に例示されたように三つの空間（P、A、C）がああります。<graphic fileref="img/3-3.png"  align="center"/>P空間はPとAとFとGを含んでいます。A空間はAとBとCとDを含んでいます。C空間はCとEを含んでいます。</para>
<para>同じIDスペース中のコンポーネントはフェローと呼ばれます。たとえば、A・B・C・Dは同じIDスペースのフェローです。</para>
<para>ほかのフェローを引き出すのに、<code>IdSapce</code>インターフェース、又は<code>Component</code>インターフェースの中の<code>getFellow</code>メソッドを使います。</para>
<para><code>getFellow</code>メソッドは同じIDスペースの最上段（所有者）に限らず、IDスペースのどのコンポーネントに対しても呼び出すことができます。同様に、空間所有者とは関係なく、<code>getSpaceOwner</code>メソッドは同じIDスペースのどのコンポーネントに対しても同じオブジェクトを返します。</para>
<para><code>org.zkoss.zk.ui.Path</code>クラスはIDスペース上のコンポーネントの位置を簡単化するためのユーティリティプログラムを提供します。その使用方法は<code>java.io.File</code>と同様です。</para>
<programlisting>Path.getComponent("/A/C/E");
new Path("A/C", "E").getComponent();</programlisting><sect2><title>ネーム空間とIDスペース</title>
<para>インタープリターでコンポーネントに直接にアクセスするため、ネーム空間(<code>org.zkoss.scripting.Namespace</code>)のコンセプトを使用します。まず、どのIDスペースもネーム空間を持っています。さらに、ネーム空間の中で定義された値をネーム空間内のスクリプトコードとEL表記は参照できます。</para>
<programlisting>
&lt;window border="normal"&gt;
&nbsp;&nbsp;&nbsp;&lt;label id="l" value="hi"/&gt;<inlinegraphic fileref="img/3-3-1.png"  align="right"/>
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.value = "Hi, namespace";
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;${l.value}
&lt;/window&gt;</programlisting>
<para>以下の例の中で二つのネーム空間があります。一つはウィンドウ<code>w1</code>に属していて、もう一つはウィンドウ<code>w2</code><footnote>
<para>ウィンドウはorg.zkoss.zk.ui.IdSpaceを実装しますので、独立したIDスペースとネーム空間が形成されます。</para>
</footnote>に属しています。ですから、<code>b1</code>ボタンの<code>onClick</code>スクリプトはウィンドウ<code>w1</code>で定義されたラベルを参照して、<code>b2</code>ボタンのonclickスクリプトは<code>w2</code>内で定義されたチェックボックスを参照します。</para>
<programlisting>&lt;window id="w1"&gt;
&nbsp;&nbsp;&nbsp;&lt;window id="w2"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label id="c"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&nbsp;&nbsp;&nbsp;&lt;checkbox id="c"/&gt;
&nbsp;&nbsp;&nbsp;&lt;button id="b2" onClick="c.label = &amp;quot;OK&amp;quot;"/&gt;
&lt;/window&gt;</programlisting>
<para>ここで一つ注意するポイントがあります：ネーム空間は階層です。つまり、ウィンドウ<code>w2</code>内の<code>zscript</code>は<code>w2</code>の中に重複がない限り、ウィンドウ<code>w1</code>のコンポーネントを見ることができます。このようにして、以下の例の中でボタン<code>b1</code>をクリックすることはラベル<code>c</code>を変えます。</para>
<programlisting>&lt;window id="w1"&gt;
&nbsp;&nbsp;&nbsp;&lt;window id="w2"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&nbsp;&nbsp;&nbsp;&lt;label id="c"/&gt;
&lt;/window&gt;</programlisting>
<para>ZKのコンポーネントはネームスペースにコンポーネントを指定する他に、<code>setVariable</code>メソッドによって変数をコンポーネントに指定することができます。そうして<code>zscript</code>はそれらを直接参照することができます。</para></sect2><sect2><title><code>zscript</code>の中で定義された変数とファンクション</title>
<para>コードを実行するに加えて、以下のように記述することで、変数と要素を<code>zscript</code>メソッドの中で直接定義することができます。</para>
<programlisting>&lt;window id="A&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object myvar = new LinkedList();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void myfunc() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&lt;button label="add" onClick="myvar.add(some)"/&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="some" onClick="myfunc()"/&gt;
&lt;/window&gt;</programlisting>
<para><code>zscript</code>の中で定義された変数とメソッドはスクリプト言語のインタープリターの中に保存されています。</para><sect3><title><code>zscript</code>とEL表記</title>
<para>ネーム空間<footnote>
<para><code>org.zkoss.zk.scripting.Namespace</code></para>
</footnote>のように、<code>zscript</code>の中で定義された変数をEL表記は参照できます</para>
<programlisting>&lt;window&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;String var = "abc";
&nbsp;&nbsp;&nbsp;self.setVariable("var2", "xyz", true);
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;${var} ${var2}
&lt;/window&gt;</programlisting>
<para>上記は以下と同様です。</para>
<programlisting>&lt;window&gt;
abc xyz
&lt;/window&gt;</programlisting>
<para><code>zscript</code>の中で定義された変数はネーム空間で定義されたものより優先度が高いです。</para>
<programlisting>&lt;window&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;String var = "abc";
&nbsp;&nbsp;&nbsp;self.setVariable("var", "xyz", true);
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;${var}
&lt;/window&gt;</programlisting>
<para>上記は以下と同様です。</para>
<programlisting>&lt;window&gt;
abc
&lt;/window&gt;</programlisting>
<para>以下の例のようにコンポーネントを宣言すると混乱を招くことがあります。</para>
<programlisting>&lt;window&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;String var = "abc";
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;label id="var" value="A label"/&gt;
&nbsp;&nbsp;&nbsp;${var.value} &lt;!-- Wrong! var is "abc", not the label --&gt;
&lt;/window&gt;</programlisting>
<para>混乱を避けるために、いくつかの名付け方式を使うことをお勧めします。たとえば、インタープリター変数には前置詞<code>zs_</code>をつけます。</para>
<para>なお、できるだけローカル変数を使いましょう。ローカル変数はクラスの名前とともに定義され、<code>zscript</code>コードの特定の範囲内のみに有効です。</para>
<programlisting>&lt;zscript&gt;
Date now = new Date();
&lt;/zscript&gt;</programlisting>
<para>さらに、以下のように括弧でくくることでローカル変数をEL表記が参照できないように設定できます。</para>
<programlisting>&lt;zscript&gt;
{ //create a new logic scope
&nbsp;&nbsp;&nbsp;String var = "abc"; //visible only inside of the enclosing curly brace
}
&lt;/zscript&gt;</programlisting></sect3><sect3><title>多領域(マルチ・スコープ)インタープリター</title><para>定義することによって、インタープリターはひとつの領域を持つか、変数とメソッドを保存する論理領域を持つことができます。区別するために、それぞれ、シングル領域と多領域インタープリターと呼びます。</para>
<para>Javaインタープリター（BeamShell）は代表的な多領域インタープリター<footnote>
<para>2.3.1(含む)以降および2.2.1(含む)以前、Javaインタープリターはマルチスコープに対応可能です。</para>
</footnote>で、それぞれのIDスペースに独立のインタープリター領域を作ります。例えば、以下の例で二つの論理領域はそれぞれウィンドウ<code>A<code>と</code>B</code>のために確保されます。そうして、<code>var2</code>はウィンドウ<code>B</code>のみに有効で、<code>var1</code>は<code>A</code>と<code>B</code>の両方のウィンドウに有効です。</para>
<programlisting>&lt;window id="A"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;var1 = "abc";&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;var2 = "def";&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&lt;/window&gt;</programlisting><sect4><title>Javaインタープリター(BeanShell)</title>
<para>Javaインタープリター（BeanShell）を使って、以下のようにクラスの名前を定義することで一番近いIDスペースの論理領域（つまり、ウィンドウ）にローカルインタープリター変数を宣言することができます。</para>
<programlisting>&lt;window id="A"&gt;
&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;String b = "local to window B";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&lt;/window&gt;</programlisting>
<para>以下は<code>abc</code>と<code>def</code>を作成するより正確な例です。</para>
<programlisting>&lt;window id="A"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;var1 = var2 = "abc";
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;Object var1 = "123";
&nbsp;&nbsp;&nbsp;var2 = "def";
&nbsp;&nbsp;&nbsp;var3 = "xyz";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&nbsp;&nbsp;&nbsp;${var1} ${var2} ${var3}
&lt;/window&gt;</programlisting>
<para><code>Object var1="123"</code>は、クラス名、つまり<code>Object</code>が指定されているので、ローカル変数をウィンドウ<code>B</code>に定義しています。一方、オブジェクト<code>var2="def"</code>はインタープリターに、現領域、又は上層領域(親など)内で<code>var2</code>と定義された変数を参照させます。<code>var2</code>はウィンドウ<code>A</code>中で定義されていて、変数はオーバーライドされています。<code>var3＝"xyz"</code>の場合では、ウィンドウ<code>A</code>が<code>var3</code>と呼ばれる変数を定義していないので、ウィンドウ<code>B</code>にローカル変数が指定されています。</para></sect4></sect3><sect3><title>単領域インタープリター</title>
<para>Ruby・Groovy・JavaScriptインタープリターはまだ多領域をサポートしていません<footnote>
<para>今後サポートする予定です。</para>
</footnote>。つまり、すべての変数はひとつの論理領域のみに定義されていることを意味しています。例えば、Rudyの変数は(インタープリターごとに)一領域中に保存されます。このように、同ページのであれば、ひとつのウィンドウ中に定義されたインタープリター変数はほかのウィンドウでオーバーライドされます。混乱を避けるために、ウィンドウを意味する特別な前置詞のついた変数を書きます。</para>
<para>【ヒント】： どのページも<code>zkscript</code>コードを処理するために自身のインタープリターを持っています。デスクトップは多数のページを持っていて、(スクリプト言語ごとに)インタープリターが複数のインスタンスを持っている場合があります。</para></sect3><sect3><title>一ページの中にある複数のスクリプト言語</title>
<para>どのスクリプト言語もひとつのインタープリターと繋がっています。変数とメソッドはひとつの言語の中で定義されていて、ほかの言語には使えません。例えば、以下の例の中で<code>var1</code>と<code>var2</code>は異なった2つのインタープリターに属しています。</para>
<programlisting>&lt;zscript language="Java"&gt;
&nbsp;&nbsp;&nbsp;var1 = 123;
&lt;/zscript&gt;
&lt;zscript language="JavaScript"&gt;
&nbsp;&nbsp;&nbsp;var2 = 234;
&lt;/zscript&gt;</programlisting></sect3><sect3><title><code>getVariable</code>と<code>getZScriptVariable</code></title>
<para>ネーム空間の中で定義された変数は<code>getVariable</code>メソッドで引き出すことができます。</para>
<para>一方，<code>zscript</code>中で定義された変数はそれを翻訳するインタープリターの一部です。ネーム空間の一部ではありません。つまり、<code>getVariable</code>メソッドでそれらを取得することはできません。</para>
<programlisting>&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;var1 = 123; //var1 belongs to the interpreter, not any namespace
&nbsp;&nbsp;&nbsp;page.getVariable("var1"); //returns null
&lt;/zscript&gt;</programlisting>
<para>代わりに<code>getZScriptVariable</code>をつかって<code>zscript</code>内で定義された変数を引き出さなければなりません。同様にして、<code>getZScriptClass</code>を使ってクラスを取得し、<code>getZScriptMethod</code>をつかってメソッドを取得します。これらのメソッドは見つかるまで、呼び出されたインタープリターを通して、繰り返されます。</para>
<para>特定のインタープリターを探す場合、以下のように<code>getInterpreter</code>メソッドを使って、インタープリターを引き出します。</para>
<programlisting>page.getInterpreter("JavaScript").getVariable("some"); //interpreter for JavaScript
page.getInterpreter(null).getVariable("some"); //interpreter for default language</programlisting></sect3></sect2></sect1><sect1><title>イベント</title><para>イベントは(<code>org.zkoss.zk.ui.event.Event</code>)はアプリケーションに何が起こったかを通知します。異なった種類のイベントは異なったクラスによって表されます。たとえば<code>org.zkoss.zk.ui.event.MouseEvent</code>はマウスをクリックしたような動きを表します。</para>
<para>イベントへレスポンスするためには、アプリケーションがひとつ以上のリスナーを登録しなければなりません。イベントリスナーを登録する方法は二つあります。ひとつはマークアップ言語中で<code>onXxx</code>属性を定義する方法です。もうひとつは<code>addEventListener</code>メソッドをつかってコンポーネント又は参照するページを呼び出します。</para>
<para>イベントがブラウザでユーザーの操作によって発生することに加えて、アプリケーションは<code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>postEvent</code>と<code>sendEvent</code>メソッドを使ってイベントを発生させます。</para></sect1><sect1><title>デスクトップとイベント処理</title>
<para>上に記述したように、デスクトップはURLリクエストが集まるページです。デスクトップはイベントリスナが通信できる領域でもあります。</para>
<para>イベントが発生したとき、イベントはデスクトップ上で行われます。ZKはイベントをデスクトップごとに別々の待ち行列に分けます。こうして、同じデスクトップ上のイベントは順番に行われ、一方、別デスクトップ上のイベントは同時進行で行われます。</para>
<para>イベントリスナはイベントが行われるデスクトップ上のどのページコンポーネントにも通信できます。同じデスクトップ内ではひとつのページから別のページにコンポーネントを動かすこともできます。一方で、他のデスクトップに属しているコンポーネントへは通信することができません。</para>
<para>【補足】：開発者はイベントリスナ中のデスクトップからコンポーネントをはずすことができます。そして他のイベントリスナ中の別デスクトップにつけることができます。</para><sect2><title>デスクトップとコンポーネントの作成</title>
<para>イベントリスナ中にコンポーネントを作成する時、現在イベントが行われているデスクトップにコンポーネントを自動的に指定します。コンポーネントがページに添付されていないときでさえ、指定作業は行われます。イベントリスナの中にユーザーが作成したどのコンポーネントもリスナが操作しているデスクトップ上で使用できます。</para>
<para>コンポーネントがイベントリスナ以外のスレッドの中で作成される時、コンポーネントはどのデスクトップにも属していません。この場合、適したイベントリスナ中で添付作業が行われる限り、添付したいどのデスクトップへも添付できます。もちろん、一度、コンポーネントがデスクトップへ添付されると、そのデスクトップへずっと付属することになります。</para>
<para>ほとんどのアプリケーションで、イベントリスナ以外のスレッドの中にコンポーネントを作成する必要はほとんどありません。しかし、ロングオペレーションを行うなら、バックグラウンドスレッド中でそれを実行した方がいいかもしれません。そのときバックグラウンドにコンポーネントツリーを準備します、適したイベントを受け取ったときそれをデスクトップへ添付します。「イベントの監視と処理」の「ロング・オペレーション」セクションを参照してください。</para></sect2></sect1><sect1><title>ZUMLとXMLネーム空間</title>
<para>ZKユーザーインターフェースマークアップ言語(ZUML)は視覚表現を記述するのに開発者が使用するXML基盤の言語であります。ZUMLはコンポーネンツセットへの依存を避けることを目的としています。つまりXULとXHTMLといったコンポーネントの異なったセット<footnote>
<para>タグともいいます。コンポーネントとタグは一対一の関係です。</para>
</footnote>を同じZUMLページで同時に使うことができます。異なったマークアップ言語は透過的に添付されます。二つ以上のコンポーネンツセットが同じページ中で使用されると、開発者はXMLのネーム空間を使ってそれらを区別します。XHTML・XULといった多数コンポーネントセットを同じページ中に組み合わせる場合は「ZKユーザーインターフェースマークアップ言語」の「コンポーネンツ集とXMLネーム空間」セクションを参照してください。</para>
<para>【ヒント】： ZUMLの中のXMLのネーム空間を使用するかどうかは選択できます。二つ以上を組み合わせる際に使います。</para></sect1></chapter><chapter><title>コンポーネントのライフサイクル</title>
<para>この章はページの読み込みとページ更新のライフサイクルについて説明します。</para><sect1><title>ページの読み込みサイクル</title>
<para>ZKローダーがZUMLページを読み込み、翻訳するのに4段階があります。ページ初期段階、コンポーネント作成段階、イベント処理段階、書き込み段階です。</para><sect2><title>ページ初期段階</title>
<para>この段階ではZKは<code>init</code>と呼ばれる指示語を処理します。このような指示語が定義されていなければ、この段階は省略されます。</para>
<para><code>class</code> 属性を伴った<code>init</code>プロセスの指示語に対し、指定されたクラスのインスタンスは作られます。そして、<code>doInit</code>メソッドが呼び出されます。クラスが何をするか？はアプリケーションしだいです。</para>
<programlisting>&lt;?init class="MyInit"?&gt;</programlisting>
<para>他形式の<code>init</code>指示語は以下のように<code>zscript</code>属性でスクリプトコードファイルを指定します。そのファイルはページの初期段階で翻訳されます。</para>
<programlisting>&lt;?init zscript="/my/init.zs"?&gt;</programlisting>
<para>ページ初期段階ではページはデスクトップにまだ添付されていないことに注意してください。</para></sect2><sect2><title>コンポーネント作成段階</title>
<para>この段階ではZKローダーがZUMLページを翻訳します。必要に応じて、コンポーネントを初期化したり、作成したりします。以下のようにいくつかのステップを踏みます。</para>
<orderedlist>
<listitem>
<para>どの要素に対しても、<code>if</code> と<code>unless</code>属性を調べて有効かどうかを決めます。有効でないなら、メソッドとその子メソッドは無視されます。</para>
</listitem>
<listitem>
<para><code>forEach</code>属性が指定されたら、ZKはその項目の集合中で以下のステップを繰り返します。</para>
</listitem>
<listitem>
<para>要素名を基にしてコンポーネントを作成します。または、<code>use</code>属性の中に指定されたクラスを使って作成します。</para>
</listitem>
<listitem>
<para>ZUMLページの中で明記された属性の順番でメンバーは一つ一つ初期化されます。</para>
</listitem>
<listitem>
<para>重ねられた要素を翻訳し、すべてのプロセスを繰り返します。</para>
</listitem>
<listitem>
<para>コンポーネントが<code>org.zkoss.zk.ui.ext.AfterCompose</code>インターフェースを実装するなら、<code>afterCompose</code>メソッドを使用します。<footnote>
<para>AfterComposeと呼ばれるのはステップ3～5がいわゆるcomposingです。</para>
</footnote></para>
</listitem>
<listitem>
<para>子要素が作成されてから<code>onCreate</code>イベントはこのコンポーネントに送られます。それによって、アプリケーションがいくつかの要素を初期化できます。<code>onCreate</code>イベントは初めに子コンポーネントのために呼び出されます。</para>
</listitem>
</orderedlist>
<para>【補足】：開発者は<code>onCreate</code>イベント又は<code>AfterCompose</code>を実装することで、各々のアプリケーションに対して異なる初期化を行うことができます。<code>AfterCompose</code>はコンポーネント作成段階の中で呼び出されます。一方<code>onCreate</code>イベントはイベントリスナによってコントロールされます。
イベントリスナはモーダルダイアログ作成といった操作を一時保留にしたり再び行ったりできます。一方<code>AfterCompose</code>は他のスレッドに分岐させる必要がないのでより速いです。</para></sect2><sect2><title>イベント処理段階</title>
<para>この段階ではデスクトップ上の待ち行列にあるイベントに対し、対応するリスナをZKが呼び出します。</para>
<para>独立したスレッドはリスナを呼び出します。そうして、他のイベントプロセスに影響を与えることなく一旦停止できます。</para>
<para>プロセスの中のイベントリスナは他のイベントを起こすこともあります。詳しくは「イベントの監視と処理」を参照してください。</para></sect2><sect2><title>書き込み(Rendering)段階</title>
<para>すべてのイベントを終えたら、ZKはそれらのコンポーネンツをHTMLページへ書き込み、そのページをブラウザへ送ります。</para>
<para>コンポーネントを書き込むのに、<code>redraw</code>メソッドを呼び出します。このメソッドでは、コンポーネントの実装はコンポーネントの中身を変えてはいけません。</para></sect2></sect1><sect1><title>ページ更新のライフサイクル</title>
<para>ZKのAUエンジンは三段階でクライアントから送られたZKのリクエストを処理します：リクエスト処理段階、イベント処理段階、書き込み段階。</para>
<para>ZKのAUエンジンは、ひとつのデスクトップにはひとつの待ち行列を当てることを原則にして、同じデスクトップのリクエストを順番で処理し、異なったデスクトップのリクエストを並列に処理します。</para><sect2><title>リクエスト処理段階</title>
<para>リクエストによって、ZK AUエンジンは変更したコンポーネントの内容をクライアント側に表示しているように更新する場合があります。</para>
<para>更新終わったら、関連するイベントを待ち行列に送ります。</para></sect2><sect2><title>イベント処理段階</title>
<para>この段階はコンポーネント作成段階の中のイベント処理段階と同じです。独立したスレッド中でイベントは一つずつ処理されます。</para></sect2><sect2><title>書き込み段階</title>
<para>イベントが処理されたら、ZKは変更されたコンポーネントを書き込み、対応するレスポンスを生成し、レスをクライアントに返します。そうして、クライアントエンジンはその返信を基にして、ブラウザにてDOMツリーを更新します。</para>
<para>ブラウザでコンポーネントの視覚表現を全体的に表現しなおす、又は属性を更新するかどうかは全てコンポーネントの実装によります。対話と簡単さの間でバランスを取ることがコンポーネント開発者の仕事です。</para></sect2></sect1><sect1><title>モールド(Molds)</title><para>同じページにコンポーネントを異なった外見で見せることができます。そのコンセプトをモールドと呼びます(aka.,template)。開発者は<code>Component</code>インターフェース中で<code>setMold</code>メソッドの使用し、動的に外見を変えることができます。すべてのコンポーネンツは<code>default</code>と呼ばれるデフォルトモールドを持っています。あるコンポーネントは二つ以上のモールドを持っています。例えば、<code>tabbox</code>は<code>default</code>と<code>accordion</code>モールドが使用可能です。</para>
<programlisting>&lt;tabbox&gt;&lt;!-- if not specified, the default mold is assumed. --&gt;
&nbsp;&nbsp;&nbsp;<inlinegraphic fileref="img/4-3.png"   align="right"/>&lt;tabs&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="Default"/&gt;
&nbsp;&nbsp;&nbsp;&lt;/tabs&gt;
&nbsp;&nbsp;&nbsp;&lt;tabpanels&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabbox mold="accordion"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabs&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="First Accordion"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="Second Accordion"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabs&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanels&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;The second panel.&lt;/tabpanel&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabpanels&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabbox&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabpanel&gt;
&nbsp;&nbsp;&nbsp;&lt;/tabpanels&gt;
&lt;/tabbox&gt;</programlisting></sect1><sect1><title>不要なコンポーネントの処理</title>
<para>他のコンポーネントをベースにしたGUIとは違って、ZKはコンポーネントを削除したり、閉じたりするメソッドがありません。W3C DOMのようにコンポーネントはページから外れるとすぐにブラウザから消えます。また、ページに添付されるとすぐに現れます。</para>
<para>より正しく言うと、一度ページから外れると、ZKはもうそれをコントロールすることができません。また、アプリケーションがそのコンポーネントをこれ以上参照しないのであれば、そのコンポーネントに対応するメモリーはJVMのGabageCollectorによって開放されます。</para></sect1></chapter><chapter><title>イベントの監視と処理</title><para>この章はどのようにイベントが処理されるかを説明します。</para><sect1><title>マークアップ言語によるイベントリスナの追加</title>
<para>イベントリスナを追加する最も簡単な方法はZUMLページで属性を宣言することです。イベントを監視する属性の値はBeanShellが翻訳できるJavaコードでしたら何でもOKです。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;
&lt;/window&gt;</programlisting></sect1><sect1><title>プログラムによるイベントリスナの追加と削除</title><para>プログラムによってイベントリスナを追加する方法は二つあります。</para><sect2><title>メンバーを宣言する</title>
<para>ユーザーによって作られたクラスを使ってコンポーネントをオーバーライドするとき、以下のようにメンバーファンクションをイベントリスナとして宣言できます。</para>
<para>ZUMLページの中で、<code>use</code>属性を宣言することでデフォルト以外のクラスを指定できます。以下に書いたようにZKに<code>org.zkoss.zul.Window</code><footnote>
<para>デフォルトクラスはzul.jarにあるlang.xmlに定義されています。</para>
</footnote>の代わりにMyClassを使用させます。</para>
<programlisting>&lt;window use="MyClass"&gt;
...
&lt;/window&gt;</programlisting>
<para>そうして、以下のようにデフォルトクラスから拡張することでMyWindow.javaを実装します。</para>
<programlisting>public class MyWindow extends org.zkoss.zul.Window {
&nbsp;&nbsp;&nbsp;public void onOK() { //add an event listener
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//handles the onOK event (sent when ENTER is pressed)
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>以下のように宣言すると、イベントについてより多くの情報を取得できます。</para>
<programlisting>public void onOK(org.zkoss.zk.ui.event.KeyEvent event) {
...
}</programlisting>
<para>それぞれ異なったイベントはそれぞれの異なったイベントオブジェクトに関連している可能性があります。詳しくはAppendx Cをご参照ください。</para></sect2><sect2><title>動的にイベントリスナを追加・削除</title><para>開発者は<code>org.zkoss.zk.ui.Component</code>インターフェースの<code>addEventListener</code>と<code>removeEventListener</code>メソッドを使って、イベントリスナを動的に追加したり削除したりします。以下に書いたように、動的に追加されるイベントリスナは<code>org.zkoss.zk.ui.event.EventListener</code>インターフェースを実装しなければなりません。</para>
<programlisting>void init(Component comp) {
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;comp.addEventListener("onClick", new MyListener());
&nbsp;&nbsp;&nbsp;...
}
class MyListener implements org.zkoss.zk.ui.event.EventListener {
&nbsp;&nbsp;&nbsp;public void onEvent(Event event) throws UiException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//processing the event
&nbsp;&nbsp;&nbsp;}
}</programlisting></sect2><sect2><title>可延イベントリスナ(通信のタイミングを遅らせるイベントリスナ)</title>
<para>デフォルトではクライアントで起こったイベントはサーバーに送られます。しかし、多くのイベントリスナはユーザー側で何かを表示させるよりは、ただ単にサーバーの状態を維持します。つまりこの状態制御リスナに対して起こったイベントは即座に情報を送る必要がありません。サーバーのパフォーマンスをあげるため、クライアントとサーバー間の通信量を最小にし、これらのリスナをまとめて送信します。便宜上これらを、可延イベントリスナと呼びます。</para>
<para>イベントリスナの通信を一時保留するのに<code>org.zkoss.zk.ui.event.Deferrable</code>インターフェース(<code>EventListener</code>を含め)を実装し、以下のように<code>isDeferrable</code>メソッドにtrueを返します。</para>
<programlisting>public class DeferrableListener implements EventListener, Deferrable {
&nbsp;&nbsp;&nbsp;private boolean _modified;
&nbsp;&nbsp;&nbsp;public void onEvent(Event event) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_modified = true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public boolean isDeferrable() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>クライアントでイベントが発生したとき(例えば、ユーザーがリスト項目を選択したとき)、可延リスナだけが登録されているか、又は、イベントリスナが全く登録されていない場合、ZKはイベントを送信しません。代わりに、イベントはクライアント側の待ち行列に保存されます。</para>
<para>少なくともひとつ可延でないリスナが登録しているのであれば、イベントはすぐにすべて待ち行列にあるイベントとともにサーバーへ送られます。すべてのイベントは順番通り送信されます。</para>
<para>【ヒント】：  可延リスナを使って、サーバーの状態を維持します。一方、ユーザー側での視覚的な変更は。不可延リスナを使用します。</para></sect2><sect2><title>動的にページにてイベントリスナを追加・削除</title>
<para>開発者は動的にページへ(<code>org.zkoss.zk.ui.Page</code>)イベントリスナを追加できます。一度付加されると、指定したページのコンポーネンツに名前が指定されたすべてのイベントはリスナへ送られます。</para>
<para>すべてのページイベントリスナは即時に作動するものではありません。つまり<code>isArap</code>メソッドは無視されます。</para>
<para>代表的な例はページ単位のイベントリスナを使用して、以下のように”変更フラグ”をコントロールします。</para>
<programlisting>public class ModificationListener implements EventListener, Deferrable {
&nbsp;&nbsp;&nbsp;private final Window _owner;
&nbsp;&nbsp;&nbsp;private final Page _page;
&nbsp;&nbsp;&nbsp;private boolean _modified;

&nbsp;&nbsp;&nbsp;public ModificationListener(Window owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Note: we have to remember the page because unregister might
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//be called after the owner is detached
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page = owner.getPage();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onChange", this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onSelect", this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onCheck", this);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;/** Called to unregister the event listener.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public void unregister() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onChange", this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onSelect", this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onCheck", this);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;/** Returns whether the modified flag is set.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public boolean isModified() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _modified;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;//-- EventListener --//
&nbsp;&nbsp;&nbsp;public void onEvent(Event event) throws UiException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_modified = true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;//-- Deferrable --//
&nbsp;&nbsp;&nbsp;public boolean isDeferrable() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>【メモ】：<code>Deferrable</code> インターフェースを実装するかどうかはこの例の中ではオプションです。それはページイベントリスナは<code>Deferrable</code>を実装しなくてもデフォルトでも可延であるからです。</para></sect2><sect2><title>呼び出し順序</title>
<para>イベントリスナの呼び出す順序は以下の通りです。<code>onClick</code>イベントが届いたと想定しましょう。</para>
<orderedlist>
<listitem>
<para>目的コンポーネントへ追加された<code>onClick</code>イベントのリスナをひとつずつ呼び出します。ただしこれは、リスナが<code>org.zkoss.zk.ui.event.Express</code>インターフェースを実装する場合のみです。また、追加される順番と呼び出される順番は同じです。</para>
</listitem>
<listitem>
<para>目的コンポーネントの中の<code>onClick</code>属性に明記したスクリプトを呼び出します。</para>
</listitem>
<listitem>
<para><code>org.zkoss.zk.ui.event.Express</code>インターフェースを実装していない目的コンポーネントへ追加された<code>onClick</code>イベントのリスナをひとつずつ呼び出します。追加される順番と呼び出される順番は同じです。</para>
</listitem>
<listitem>
<para>目的コンポーネントの<code>onClick</code>メンバーメソッドを呼び出します。</para>
</listitem>
<listitem>
<para>目的コンポーネントが属しているページへ追加された<code>onClick</code>イベントに対してイベントリスナを呼び出します。追加される順番と呼び出される順番は同じです。</para>
</listitem>
</orderedlist>
<para><code>org.zkoss.zk.ui.event.Express</code>インターフェースは装飾用のインターフェースです。イベントリスナの呼び出される優先順位を変更する際に使用します。イベントリスナがコンポーネントではなく、ページへ追加された場合は、このインターフェースは使用できません。</para></sect2><sect2><title>呼び出し順序を中止</title>
<para><code>org.zkoss.zk.ui.event.Event</code>クラスの中の<code>stopPropagation</code>メソッドを呼ぶことで呼び出し順序を中止できます。一度あるイベントリスナがこのメソッドを呼び出すと、それ以降のすべてのイベントリスナは使用されません。</para></sect2></sect1><sect1><title>イベントリスナからイベントを送信・生成</title><para>イベントを受け取ることに加えて、イベントを生成または送信することでアプリケーションは多くのイベントリスナ間で通信できます。</para><sect2><title>イベントを生成</title><para><code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>postEvent</code>メソッドを使って、イベントリスナはイベント待ち行列の最後にイベントを追加できます。待ち行列にイベントを置いた後、すぐに戻ります。追加されたイベントは待ち行列にあるイベントがすべて処理された後、処理されます。</para></sect2><sect2><title>イベントを送信</title>
<para><code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>sendEvent</code>メソッドを使うことでイベントリスナはZKにすぐに指定したイベントを処理させます。指定されたイベントのイベントリスナがすべて処理されるまで、このプロセスは続きます。なお、イベントは同じスレッド内で処理されます。</para></sect2></sect1><sect1><title>スレッドモデル</title>
<para>ひとつのデスクトップにあるイベントは順番に処理されるので、スレッドモデルは簡単です。 デスクトップアプリケーションを開発するように、マルチスレッド問題や競合問題を心配する必要はありません。必要なのはイベントリスナを登録し、そして、呼び出されたときにイベントを処理することです。</para>
<para>【ヒント】： イベントリスナはイベント処理スレッドと呼ばれる独立したスレッドの中で実行します。一方、ZUMLページはサーブレットスレッドの中で処理されます。</para>
<para>【ヒント】： イベント処理スレッドを無効にし、すべてのイベントをサーブレットスレッドの中で処理させることができます。これによって、処理速度を速くし、統合問題を少なくします。しかし、処理を一時中断させることはできません。詳しくは「アドバンス機能」の「サーブレットプロセスでイベントを処理」セクションを参照してください。</para><sect2><title>中断と再開</title>
<para>アドバンスアプリケーションでは、いくつかの条件を満足するまで処理を一時中断させなければならないことがあります。<code>org.zkoss.zk.ui.Executions</code>クラスの<code>wait</code>と<code>notify</code>と<code>notifyAll</code>メソッドはこの目的のために作られました。</para>
<para>イベントリスナが自身を一時中断させるには<code>wait</code>メソッドを使用します。アプリケーションの条件が満足したら、他のスレッドは<code>notify</code>又は<code>notifyAll</code>でそれを呼び起こします。モーダルダイアログはこのメカニズムを使った代表的な例です。</para>
<programlisting>public void doModal() throws InterruptedException {
...
&nbsp;&nbsp;&nbsp;Executions.wait(_mutex); //suspend this thread, an event processing thread
}
public void endModal() {
...
&nbsp;&nbsp;&nbsp;Executions.notify(_mutex); //resume the suspended event processing thread
}</programlisting>
<para>これらの使用は<code>java.lang.Object</code>クラスの<code>wait</code>、<code>notify</code>と<code>notigyAll</code>と同じです。しかし、<code>java.lang.Object</code>クラスのメソッドを使い、イベントリスナを中断したり、再開したりできません。さもなければ、関連したデスクトップのすべてのイベント処理はコントロールできなくなります。</para>
<para>Java<code>Object</code>の<code>wait</code>と<code>notify</code>とは違って、<code>synchronized</code>ブロックで<code>Executions</code>の<code>wait</code>と<code>notify</code>を囲い込むかはオプションです。上記のケースでは競合問題にはなりえないので、ブロックを使わなくても結構です。しかし、競合状態になる可能性があれば、Java<code>Object</code>の<code>wait</code>と<code>notify</code>を処理するのと同じように<code>synchronized</code>ブロックを使います。</para>
<programlisting>//Thread 1
public void request() {
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;synchronized (mutex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//start another thread
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.wait(mutex); //wait for its completion
&nbsp;&nbsp;&nbsp;}
}

//Thread 2
public void process() {
&nbsp;&nbsp;&nbsp;... //process it asynchronously
&nbsp;&nbsp;&nbsp;synchronized (mutex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.notify(mutex);
&nbsp;&nbsp;&nbsp;}
}</programlisting></sect2><sect2><title>ロング・オペレーション</title>
<para>同じデスクトップのイベントは順番に処理されます。つまりイベントハンドラは以下のどのハンドラも遮断します。イベントハンドラが実行するのに時間が長ければ、ユーザーのリクエストを遮断する時間も長くなります。デスクトップアプリケーションのように、ワーキングスレッドを作り、長時間処理の遮断時間を最小にするようにしなければなりません。</para>
<para>HTTPの制限により、以下のルールに従っているかどうかを確認しなければなりません。</para>
<orderedlist>
<listitem>
<para>ワーキングスレッドを作った後に、<code>org.zkoss.zk.ui.Executions</code>クラスの<code>wait</code>メソッドを使い、イベントハンドラ自体を一時中断させます。</para>
</listitem>
<listitem>
<para>ワーキングスレッドはイベントリスナではないので、コンポーネントにアクセスすることができません。ただし、どのデスクトップにも属していないコンポーネントでしたらアクセスできます。ですので、ワーキングスレッドを開始する前に、必要な情報を手動で追加する必要があります。</para>
</listitem>
<listitem>
<para>そして、ワーキングスレッドは必要に応じて、情報を削除したり、コンポーネントを作成したりします。ただし、デスクトップに属しているコンポーネンツを参照してはいけないことに注意しましょう。</para>
</listitem>
<listitem>
<para>ワーキングスレッドが終了したら、その中にある<code>org.zkoss.zk.ui.Executions</code>クラスの中の<code>notify(Desktop desktop, Object flag)</code>又は<code>notifyAll(Desktop desktop, Object flag)</code>メソッドを使って、イベントハンドラを再開します。</para>
</listitem>
<listitem>
<para>他のイベントがクライアントから送られてくるまで、再開されたイベントハンドラは実行されません。強制的にイベントを送信させるには、タイマーコンポーネント(<code>org.zkoss.zul.Timer</code>)を使い、イベントを少し後にまたは周期的に起こします。このタイマーのイベントリスナは何もしないか、状態の更新を行います。</para>
</listitem>
</orderedlist><sect3><title>例：ワーキングスレッドが非同期ラベルを作成</title>
<para>ラベルを非同期的に生成することを想定します。もちろん、マルチスレッドでそのような簡単なタスクをするのは効率的ではありませんが、この例を参考にして、複雑なタスクで使用してください。</para>
<programlisting>//WorkingThread
package test;
public class WorkingThread extends Thread {
&nbsp;&nbsp;&nbsp;private static int _cnt;

&nbsp;&nbsp;&nbsp;private Desktop _desktop;
&nbsp;&nbsp;&nbsp;private Label _label;
&nbsp;&nbsp;&nbsp;private final Object _mutex = new Integer(0);

&nbsp;&nbsp;&nbsp;/** Called by thread.zul to create a label asynchronously. 
&nbsp;&nbsp;&nbsp;&nbsp;* To create a label, it start a thread, and wait for its completion. 
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public static final Label asyncCreate(Desktop desktop)
&nbsp;&nbsp;&nbsp;throws InterruptedException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final WorkingThread worker = new WorkingThread(desktop);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (worker._mutex) { //to avoid racing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.wait(worker._mutex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return worker._label;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public WorkingThread(Desktop desktop) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_desktop = desktop;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label = new Label("Execute "+ ++_cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (_mutex) { //to avoid racing
E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xecutions.notify(_desktop, _mutex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>次に、<code>onClick</code>のようなイベントリスナでワーキングスレッドを呼び出すZUMLページを作成します。</para>
<programlisting>&lt;window id="main" title="Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;timer.start();
&nbsp;&nbsp;&nbsp;Label label = test.WorkingThread.asyncCreate(desktop);
&nbsp;&nbsp;&nbsp;main.appendChild(label);
&nbsp;&nbsp;&nbsp;timer.stop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;timer id="timer" running="false" delay="1000" repeats="true"/&gt;
&lt;/window&gt;</programlisting>
<para>中断されているイベントリスナ(<code>onClick</code>)を再開するにはタイマーを使わなければなりません。それを不自然だと感じるかもしれませんが、それはHTTPの制限によるものです：ブラウザでページを存続させるには、イベント処理が一時中断されているときでも応答をしなければいけません。その結果、ワーキングスレッドが役割を果たしてイベントリスナに通知したとき、HTTPのリクエストはすでになくなっています。それを解決するため、タイマーを使用します。</para>
<para>精確にいうと、ワーキングスレッドがイベントリスナへ再開を通知するとき、ZKは順番待ちのリストに再開通知を追加するだけです。他のHTTPリクエストを受け取ってからリスナが実際に再開されます。(上の例ではそれが<code>onTimer</code>イベントです。)</para>
<para>この単純な例の中で、<code>onTimer</code>イベントを操作しませんでした。複雑なアプリケーションを処理する場合、<code>onTimer</code>で処理のステータスを送信することもできます。</para></sect3><sect3><title>方法１：タイマー(再開/中断なし)</title><para>中断と再開なしで長時間処理を実装することは可能です。同期コードが複雑になる場合にとても便利です。</para>
<para>そのアイデアは単純です。ワーキングスレッドはある場所に結果を一時的に保存します。そして、<code>onTimer</code>イベントリスナは結果をデスクトップへ表示させます。</para>
<programlisting>//WorkingThread2
package test;
public class WorkingThread2 extends Thread {
&nbsp;&nbsp;&nbsp;private static int _cnt;

&nbsp;&nbsp;&nbsp;private final Desktop _desktop;
&nbsp;&nbsp;&nbsp;private final List _result;

&nbsp;&nbsp;&nbsp;public WorkingThread2(Desktop desktop, List result) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_desktop = desktop;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_result = result;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_result.add(new Label("Execute "+ ++_cnt));
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>そして、<code>onTimer</code>イベントリスナの中にラベルを付加します。</para>
<programlisting>&lt;window id="main" title="Working Thread2"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;int numPending = 0;
&nbsp;&nbsp;&nbsp;List result = Collections.synchronizedList(new LinkedList());
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;++numPending;
&nbsp;&nbsp;&nbsp;timer.start();
&nbsp;&nbsp;&nbsp;new test.WorkingThread2(desktop, result).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;timer id="timer" running="false" delay="1000" repeats="true"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onTimer"&gt;
&nbsp;&nbsp;&nbsp;while (!result.isEmpty()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.appendChild(result.remove(0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--numPending;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (numPending == 0) timer.stop();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/timer&gt;
&lt;/window&gt;</programlisting></sect3><sect3><title>方法２：ピギーバック(中断、再開、タイマーなし)</title><para>周期的に結果を検査する代わりに、例えば、ユーザーがボタンをクリックしたり何かを入力したりするときに便乗し、クライアントへ送信することができます。</para>
<para>それをするには、ルートコンポーネントの<code>onPiggyback</code>イベントにイベントリスナを登録します。そうすると、ZK Update Engine がイベントを処理するたびにリスナが呼び出されます。例えば、以下のようにコードを書き換えることができます。</para>
<programlisting>&lt;window id="main" title="Working Thread3" onPiggyback="checkResult()"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;List result = Collections.synchronizedList(new LinkedList());

&nbsp;&nbsp;&nbsp;void checkResult() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!result.isEmpty())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.appendChild(result.remove(0));
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;timer.start();
&nbsp;&nbsp;&nbsp;new test.WorkingThread2(desktop, result).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&lt;/window&gt;</programlisting>
<para> ピギーバックの長所は、クライアントとサーバー間の通信パケットを増やさないことです。しかし、この方法だと、クリックや入力などのユーザーの操作がなければ、ページは更新されません。ですので、 ピギーバックを適用できるかどうかはそのアプリケーションの要求しだいです。</para>
<para>【補足】：可延イベントはすぐにクライアントに送られることはありませんので、不可延のイベントが起こったときにのみ<code>onPiggyback</code>イベントは発生します。「可延イベントリスナ」セクションを参照してください。</para></sect3></sect2></sect1><sect1><title>イベント処理スレッドを初期化とクリーンアップ</title><sect2><title>各イベントを処理する前に初期化</title><para>イベント処理スレッドの中でイベントリスナは実行されます。イベントを処理する前にスレッドを初期化しなければならない場合もあります。</para>
<para>代表的な例はユーザー認証スレッドの初期化です。一部のJ2EE又はウェブコンテナは、ユーザー認証用の情報をスレッドローカルメモリに保存し、必要なときに自動的に再認証できるようにしています。</para>
<para>イベント処理スレッドを初期化するのに、<code>org.zkoss.zk.ui.event.EventThreadInit</code>インターフェースを実装するクラスを<code>WEB-INF/zk.xml</code>ファイル<footnote>
<para>詳細はDeveloper's ReferenceのAppendix Bを参照してください。</para>
</footnote>の<code>listener</code>要素に登録しなければなりません。</para>
<para>登録できたら、指定したクラスのインスタンスはイベント処理スレッドが始まる前に、メインスレッドに構築されます(aka.、サーブレッドスレッド)。そして、何よりも先に、インスタンスの<code>init</code>メソッドはイベント処理の状況で呼び出されます。</para>
<para>コンストラクタと<code>init</code>コマンドは異なったスレッドの中に呼び出されて、開発者はスレッド依存するデータをひとつのスレッドから取得し、他へ送ります。</para>
<para>ここにJBoss<footnote>
<para>http://www.jboss.org</para>
</footnote>のユーザー認証メカニズムの例をあげます。この例では、コンストラクタの中のサーブレッドスレッドに保存されている情報を取得します。そうして、<code>init</code>メソッドが呼ばれたときにイベント処理スレッドを初期化します。</para>
<programlisting>import java.security.Principal;
import org.jboss.security.SecurityAssociation;
import org.zkoss.zk.ui.Component;
import org.zkoss.zk.ui.event.Event;
import org.zkoss.zk.ui.event.EventThreadInit;

public class JBossEventThreadInit implements EventThreadInit {
&nbsp;&nbsp;&nbsp;private final Principal _principal;
&nbsp;&nbsp;&nbsp;private final Object _credential;
&nbsp;&nbsp;&nbsp;/** Retrieve info at the constructor, which runs at the servlet thread. */
&nbsp;&nbsp;&nbsp;public JBossEventThreadInit() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_principal = SecurityAssociation.getPrincipal();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_credential = SecurityAssociation.getCredential();
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;//-- EventThreadInit --//
&nbsp;&nbsp;&nbsp;/** Initial the event processing thread at this method. */
&nbsp;&nbsp;&nbsp;public void init(Component comp, Event evt) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityAssociation.setPrincipal(_principal);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityAssociation.setCredential(_credential);
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>そして、<code>WEB-INF/zk.xml</code>の中で以下のように指定しなければなりません。</para>
<programlisting>&lt;zk&gt;
&nbsp;&nbsp;&nbsp;&lt;listener&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;JBossEventThreadInit&lt;/listener-class&gt;
&nbsp;&nbsp;&nbsp;&lt;/listener&gt;
&lt;/zk&gt;</programlisting></sect2><sect2><title>各イベントを処理した後にクリーンアップ</title><para>同様にして、イベントを処理した後に、イベント処理スレッドを削除しなければなりません。</para>
<para>適切に終了していなかった処理を終了させるのが代表的な例です。</para>
<para>イベント処理スレッドをクリーンアップするには、<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>インターフェースを実装するリスナクラスを<code>WEB-INF/zk.xml</code>ファイルの<code>listener</code>要素に登録しなければなりません。</para>
<programlisting>&lt;zk&gt;
&nbsp;&nbsp;&nbsp;&lt;listener&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;my.MyEventThreadCleanup&lt;/listener-class&gt;
&nbsp;&nbsp;&nbsp;&lt;listener&gt;
&lt;/zk&gt;</programlisting></sect2></sect1></chapter></book>
