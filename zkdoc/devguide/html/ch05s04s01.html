<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Suspend and Resume</title><link rel="stylesheet" href="devguide.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.0"><link rel="start" href="index.html" title="ZK Developer's Guide"><link rel="up" href="ch05s04.html" title="Thread Model"><link rel="prev" href="ch05s04.html" title="Thread Model"><link rel="next" href="ch05s04s02.html" title="Long Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Suspend and Resume</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s04.html">Prev</a> </td><th width="60%" align="center">Thread Model</th><td width="20%" align="right"> <a accesskey="n" href="ch05s04s02.html">Next</a></td></tr></table><hr></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="id456223"></a>Suspend and Resume</h3></div></div></div><p>For advanced applications, you might have to suspend an execution until some condition is satisfied. The wait, notify and notifyAll methods of the org.zkoss.zk.ui.Executions class are designed for such purpose.</p><p>When an event listener want to suspend itself, it could invoke wait. Another thread could then wake it up by use of notify or notifyAll, if the application-specific condition is satisfied. The modal dialog is an typical example of using this mechanism.</p><pre class="programlisting">public void doModal() throws InterruptedException {    ...Executions.wait(_mutex); //suspend this thread, an event processing thread}    public void endModal() {...    Executions.notify(_mutex); //resume the suspended event processing thread    }</pre><p>Their use is similar to the wait, notify and notifyAll methods of the java.lang.Object class. However, you cannot use the methods of java.lang.Object for suspending and resuming event listeners. Otherwise, all event processing will be stalled for the associated desktop.</p><p>Notice that, unlike Java Object's wait and notify, whether to use the synchronized block to enclose Executions' wait and notify is optional. In the above case, we don't have to, because no racing condition is possible. However, if there is an racing condition, you can use the synchronized block as what you do with Java Object's wait and notify.</p><pre class="programlisting">//Thread 1public void request() {    ...        synchronized (mutex) {            ...//start another thread                Executions.wait(mutex); //wait for its completion            }    }//Thread 2public void process() {    ... //process it asynchronously        synchronized (mutex) {            Executions.notify(mutex);            }    }</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05s04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch05s04s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Thread Model </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Long Operations</td></tr></table></div></body></html>
