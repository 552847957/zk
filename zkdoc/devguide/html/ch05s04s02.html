<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Long Operations</title><link rel="stylesheet" href="devguide.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.0"><link rel="start" href="index.html" title="ZK Developer's Guide"><link rel="up" href="ch05s04.html" title="Thread Model"><link rel="prev" href="ch05s04s01.html" title="Suspend and Resume"><link rel="next" href="ch05s05.html" title="Initialization and Cleanup of Event Processing Thread"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Long Operations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s04s01.html">Prev</a> </td><th width="60%" align="center">Thread Model</th><td width="20%" align="right"> <a accesskey="n" href="ch05s05.html">Next</a></td></tr></table><hr></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="id456288"></a>Long Operations</h3></div></div></div><p>Events for the same desktop are processed sequentially. In other words, an event handler will block any following handlers. The time blocking user's requests might not be acceptable, if an event handler takes too much time to execute. Like desktop applications, you have to create a working thread for long operations to minimize the blocking time. You have four options to commit this requirement, including server push, suspend and resume, timer, and piggyback.</p><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id456304"></a>Server Push</h4></div></div></div><p>Server push is so-called reverse-Ajax which allows the server to send content to the client actively. With the help of server push, you could send or update the content to the client in the working thread when your pre-defined condition is satisfied. To use server push is simple,and it requires only three steps as follows, </p><div class="orderedlist"><ol type="1"><li><p>Enable server push for the desktop </p><p>Invoke Desktop.enableServerPush(boolean bool) to enable server push</p></li><li><p>Passing components required to be update into the working thread</p></li><li><p>Invoke the working thread in the desktop </p></li></ol></div><p>Note: You need to install zkex.jar or zkmax.jar to have the server push, unless you have your own implementation of org.zkoss.zk.ui.sys.ServerPush.</p><p>Let&#8217;s take a look at a real example below. If you want to update the number of client using server push, first of all, you have to enable server push for the desktop and then to invoke the thread as follows, </p><pre class="programlisting">&lt;window title="Demo of Server Push"&gt;&lt;zscript&gt;    import test.WorkingThread;        WorkingThread thread;        void startServerpush(){            //enable server push                desktop.enableServerPush(true);                    //invoke working thread and passing required component as parameter                        thread= new WorkingThread(info);                    thread.start();            }        void stopServerpush(){            //stop the thread                thread.setDone();                //disable server push                desktop.enableServerPush(false);            }    &lt;/zscript&gt;    &lt;vbox&gt;            &lt;button label="Start Server Push" onClick="startServerpush()"/&gt;                &lt;button label="Stop Server Push" onClick="stopServerpush()"/&gt;            &lt;label id="info"/&gt;        &lt;/vbox&gt;    &lt;/window&gt;</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id473463"></a>Security Issue</h4></div></div></div><p>One thing to notice is that the problem of synchronization which happens when a desktop is accessed by multiple threads at the same time Thus, before accessing the desktop, you have to invoke Executions.activate(Desktop desktop) to get full control of the desktop to avoid this problem, and then release the control of the desktop by invoking Executions.deactivate(Desktop desktop) after the thread finishing its job as follows,</p><pre class="programlisting">    packagetest;            publicclassWorkingThread extends Thread{            private final Desktop _desktop;        private final Label _info;        private int _cnt;        private boolean _ceased;            publicWorkingThread(Label info){                _desktop = info.getDesktop();                    _info= info;                                        }publicvoidrun(){try{                                            while(!_ceased){                                Threads.sleep(2000); //Update each two seconds                                Executions.activate(_desktop); //get full control of desktop                                    try{                                        _info.setValue(Integer.toString(++_cnt));                                                                }catch(RuntimeException ex){throw ex;                                                                }catch(Error ex){                                        throw ex;                                    }finally{                                        Executions.deactivate(_desktop);//release full control ofdesktop                                        }                            }                        }catch(InterruptedException ex){                        }                            }publicvoidsetDone(){                        _ceased = true;            }}    </pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id473527"></a>Behind the Scene</h4></div></div></div><p>The mechanism of server push is implemented using client-polling technique which the client will query the server repetitively to invoke the working thread to do its job, and the frequency of query could be adjusted manually by invoking Executions.setDelay(int min, int max, int factor).</p><div class="itemizedlist"><ul type="disc"><li><p>min, the minimal delay to poll the server for any pending server-push threads.</p></li><li><p>max, the maximum delay to poll the server for any pending server-push threads.</p></li><li><p>factor, The real delay is the processing time multiplies the delay factor.</p></li></ul></div><p>Last, one thing to notice is that the frequency will be adjusted automatically depending on the loading of the server</p></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id403627"></a>Alternative 1: Thread Suspend and Resume</h4></div></div></div><p>With the help of server push, you don't have to take care about the problem of multi threads. However, if you would like to handle this job by yourself, you have to conform with the following rules due to the limitations of HTTP.</p><div class="itemizedlist"><ul type="disc"><li><p>Use the wait method in the org.zkoss.zk.ui.Executions class to suspend the event handler itself, after creating a working thread.</p></li><li><p>Because the working thread is not an event listener, it cannot access any components, unless the components don't belong to any desktop. Thus, you might have to pass necessary information manually before starting the working thread.</p></li><li><p>Then, the working thread could crush the information and create components as necessary. Just don't reference any component that belongs to any desktop.</p></li><li><p>Use the notify(Desktop desktop, Object flag) or notifyAll(Desktop desktop, Object flag) method in the org.zkoss.zk.ui.Executions class in the working thread to resume the event handler, after the working thread finishes.</p></li><li><p>The resumed event handler won't be executed immediately until another event is sent from the client. To enforce an event to be sent, you could use a timer component (org.zkoss.zul.Timer) to fire an event a moment later or periodically. This event listener for this timer could do nothing or update the progress status.</p></li></ul></div><div class="sect4" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a name="id473850"></a>Example: A Working Thread Generates Labels Asynchronously</h5></div></div></div><p>Assume we want create a label asynchronously. Of course, it is non-sense to do such a little job by applying multi-threading, but you can replace the task with sophisticated one.</p><pre class="programlisting">//WorkingThreadpackage test;public class WorkingThread extends Thread {    private static int _cnt;        private Desktop _desktop;        private Label _label;        private final Object _mutex = new Integer(0);        /** Called by thread.zul to create a label asynchronously.        *To create a label, it start a thread, and wait for its completion.        */        public static final Label asyncCreate(Desktop desktop)            throws InterruptedException {                        final WorkingThread worker = new WorkingThread(desktop);synchronized (worker._mutex) { //to avoid racing                            worker.start();                        Executions.wait(worker._mutex);                        return worker._label;                    }            }        public WorkingThread(Desktop desktop) {            _desktop = desktop;                }public void run() {                    _label = new Label("Execute "+ ++_cnt);                        synchronized (_mutex) { //to avoid racing                        Executions.notify(_desktop, _mutex);                    }            }    }</pre><p>Then, we have a ZUML page to invoke this working thread in an event listener, say onClick.</p><pre class="programlisting">&lt;window id="main" title="Working Thread"&gt;    &lt;button label="Start Working Thread"&gt;            &lt;attribute name="onClick"&gt;                timer.start();                Label label = test.WorkingThread.asyncCreate(desktop);                main.appendChild(label);                timer.stop()                &lt;/attribute&gt;            &lt;/button&gt;        &lt;timer id="timer" running="false" delay="1000" repeats="true"/&gt;    &lt;/window&gt;</pre><p>Notice that we have to use a timer to really resume the suspended the event listener (onClick). It looks odd, but it is a must due to the HTTP limitation: to keep Web page alive at the browser, we have to return the response when the event processing is suspended. Then, when the working thread completes its job and notifies the even listener, the HTTP request was already gone. Therefore, we need a way to 'piggyback' the result, which the timer is used for.</p><p>More precisely, when the working thread notifies the event listener to resume, ZK only adds it to a waiting list. And, the listener is really resumed when another HTTP request arrives (in the above example, it is the onTimer event)</p><p>In this simple example, we do nothing for the onTimer event. For a sophisticated application, you can use it to send back the progressing status.</p></div></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id403691"></a>Alternative 2: Timer (No Suspend/Resume)</h4></div></div></div><p>It is possible to implement a long operation without suspend and resume. It is useful if the synchronization codes are going too complex to debug.</p><p>The idea is simple. The working thread save the result in a temporary space, and then the onTimer event listener pops the result to the desktop.</p><pre class="programlisting">//WorkingThread2package test;public class WorkingThread2 extends Thread {    private static int _cnt;        private final Desktop _desktop;        private final List _result;                public WorkingThread2(Desktop desktop, List result) {            _desktop = desktop;                _result = result;            }        public void run() {            _result.add(new Label("Execute "+ ++_cnt));            }    }</pre><p>Then, you append the labels in the onTimer event listener.</p><pre class="programlisting">&lt;window id="main" title="Working Thread2"&gt;    &lt;zscript&gt;            int numPending = 0;                List result = Collections.synchronizedList(new LinkedList());            &lt;/zscript&gt;        &lt;button label="Start Working Thread"&gt;            &lt;attribute name="onClick"&gt;                    ++numPending;                        timer.start();                        new test.WorkingThread2(desktop, result).start();                    &lt;/attribute&gt;            &lt;/button&gt;        &lt;timer id="timer" running="false" delay="1000" repeats="true"&gt;            &lt;attribute name="onTimer"&gt;                    while (!result.isEmpty()) {                        main.appendChild(result.remove(0));                        --numPending;                        }                        if (numPending == 0) timer.stop();                    &lt;/attribute&gt;            &lt;/timer&gt;    &lt;/window&gt;</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id473933"></a>Alternative 3: Piggyback (No Suspend/Resume, No Timer)</h4></div></div></div><p>Instead of checking the results periodically, you can piggyback them to the client when the user, say, clicks a button or enters something.</p><p>To piggyback, all you need to do is to register an event listener for the onPiggyback event to one of the root components. Then, the listener will be invoked each time ZK Update Engine has processed the events. For example, you can rewrite the codes as follows.</p><pre class="programlisting">&lt;window id="main" title="Working Thread3" onPiggyback="checkResult()"&gt;    &lt;zscript&gt;        List result = Collections.synchronizedList(new LinkedList());        void checkResult() {            while (!result.isEmpty())                    main.appendChild(result.remove(0));                }        &lt;/zscript&gt;        &lt;button label="Start Working Thread"&gt;            &lt;attribute name="onClick"&gt;            timer.start();        new test.WorkingThread2(desktop, result).start();            &lt;/attribute&gt;            &lt;/button&gt;    &lt;/window&gt;</pre><p>The advantage of the piggyback is no extra traffic between the client and the server. However, the user sees no updates if he doesn't have any activity, such as clicking or typing. Whether it is proper is really up to the application requirements.</p><p>Note: A deferrable event won't be sent to the client immediately, so the onPiggyback event is triggered only if a non-deferrable event is fired. Refer to the Deferrable Event Listeners section.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s04s01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05s04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch05s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Suspend and Resume </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Initialization and Cleanup of Event Processing Thread</td></tr></table></div></body></html>
