<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Live Data</title><link rel="stylesheet" href="devguide.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.0"><link rel="start" href="index.html" title="ZK Developer's Guide"><link rel="up" href="ch07s11.html" title="List Boxes"><link rel="prev" href="ch07s11s10.html" title="Special Properties"><link rel="next" href="ch07s11s12.html" title="List Boxes Contain Buttons"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Live Data</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s11s10.html">Prev</a> </td><th width="60%" align="center">List Boxes</th><td width="20%" align="right"> <a accesskey="n" href="ch07s11s12.html">Next</a></td></tr></table><hr></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="id483958"></a>Live Data</h3></div></div></div><p>Like grids<sup>[<a name="id483965" href="#ftn.id483965" class="footnote">39</a>]</sup>, list boxes support the live data. With live data, developers could separate the data from the view. In other words, developers needs only to provide the data by implementing the org.zkoss.zul.ListModel interface. Rather than manipulating the list box directly. The benefits are two folds.</p><div class="itemizedlist"><ul type="disc"><li><p>It is easier to use different views to show the same set of data.</p></li><li><p>The list box sends the data to the client only if it is visible. It saves a lot of network traffic if the amount of data is huge.</p></li></ul></div><p>There are three steps to use the live data.</p><div class="orderedlist"><ol type="1"><li><p>Prepare the data in the form of ListModel. ZK has a concrete implementation called org.zkoss.zul.SimpleListModel. for representing an array of objects.</p></li><li><p>Implement the org.zkoss.zul.ListitemRenderer interface for rendering an item of data into a list item of the list box.</p></li></ol></div><div class="itemizedlist"><ul type="disc"><li><div class="orderedlist"><ol type="1"><li><p>This is optional. If not specified, the default renderer is used to render the data into the first column.</p></li><li><p>You could implement different renderers for represent the same data in different views.</p></li></ol></div></li></ul></div><div class="orderedlist"><ol type="1"><li><p>Specify the data in the model property, and, optionally, the renderer in the itemRenderer property.</p></li></ol></div><p>
</p><div><img src="images/1000000000000132000000E3AE1693E7.png"></div><p>In the following example, we prepared a list model called strset, assigned it to a list box through the model property. Then, the list box will do the rest.</p><pre class="programlisting">&lt;window title="Livedata Demo" border="normal"&gt;&lt;zscript&gt;String[] data = new String[30];for(int j=0; j &amp;lt; data.length; ++j) {data[j] = "option "+j;}ListModel strset = new SimpleListModel(data);&lt;/zscript&gt;&lt;listbox width="200px" rows="10" model="${strset}"&gt;&lt;listhead&gt;&lt;listheader label="Load on demend"/&gt;&lt;/listhead&gt;&lt;/listbox&gt;&lt;/window&gt;                                                                                        </pre><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="id484112"></a>Sorting with Live Data</h4></div></div></div><p>If you allow users to sort a list box provided with live data, you have to implement an interface, org.zkoss.zul.ListModelExt, in addition to org.zkoss.zul.ListModel.</p><pre class="programlisting">class MyListModel implements ListModel, ListModelExt {    public void sort(Comparator cmpr, boolean ascending) {            //do the real sorting                //notify the listbox (or grid) that data is changed by use of ListDataEvent            }    }</pre><p>When a user requests the list box to sort, the list box will invoke the sort method of ListModelExt to sort the data. In other words, the sorting is done by the list model, rather than the list box.</p><p>After sorted, the list model shall notify the list box by invoking the onChange method of the org.zkoss.zul.event.ListDataListener instances that are registered to the list box (by the addListDataListener method). In most cases, all data are usually changed, so the list model usually sends the following event:</p><pre class="programlisting">new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1)</pre><p>Note: the implementation of ListModel and ListModelExt is independent of the visual representation. In other words, it can be used with grids, list boxes and any other components supporting ListModel.</p><p>In other words, to have the maximal flexibility, you shall not assume the component to used. Rather, use ListDataEvent to communicate with.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id483965" href="#id483965" class="para">39</a>] </sup>The concept is similar to Swing (javax.swing.ListModel).</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s11s10.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07s11.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s11s12.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Special Properties </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> List Boxes Contain Buttons</td></tr></table></div></body></html>
