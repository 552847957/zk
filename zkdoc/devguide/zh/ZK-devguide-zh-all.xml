<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="zh-CN">
	<bookinfo>
		<title>ZK开发手册</title>
		<copyright>
			<year>2007</year>
			<holder>Potix Corporation. All rights reserved.</holder>
		</copyright>
	</bookinfo>
	<para />
	<chapter>
		<title>1. 简介</title>
		<para>欢迎使用ZK---- 一种丰富Web应用程序的最简单方式。</para>
		<para>
			此开发手册买描述了ZK的概念和功能。关于如何安装配置ZK的环境，请参阅Quick Start
			Guide。如果想得到的各个组件(components)的属性和方法的详细描述，请参阅Developer's
			Guide。
		</para>
		<para>这章描述了Web程序，AJAX技术和ZK项目的历史背景。如果你想马上了解ZK的功能，可以跳过这一章。</para>
		<sect1>
			<title>传统的Web应用程序</title>
			<para>
				以交换文档简单高效为目标，Web技术，超文本传输协议(HTTP)和超文本标记语言(HTML)，都来源于单页性(page-based
				)和无状态(stateless-communication)的模式。在这种模式中，一个页面是自给自足(self-contained)的，并且是沟通客户端与服务器端的最小单位。
			</para>

			<graphic align="center" fileref="img/1.png" />

			<para>
				随着网络俨然成为应用开发的默认平台，这种模式面临着巨大的挑战：对于表现当今应用程序中复杂性的无能为力。举个例子，为了给客户报价，你或许必须打开另一个页面来查询此客户的交易记录，再打开一个页面来显示当前的价格，还得开一个页面来存储当前信息。用户被迫离开他正在工作的页面，并且在几个页面间来回浏览。这很容易迷失，混淆，结果是把客户弄得不愉快，销售机会的损失和低生产力。
			</para>
			<para>
				在这种单页性(page-based
				)的模式上开发一个现代的应用程序也是一个极大的挑战。在这种模式中，运行在服务器上的应用程序必须处理来自从语法上分析请求，送出回应
				，连接用户从一个页面到另一个页面路由的一切，并且处理用户的各种错误。
				数十种框架，例如Struct，Tapestry和JSF，随即出现用来简化开发过程。由于单页性(page-based)模式与现代模式之间的巨大差别，学习和使用这些框架并不是一个愉快的过程，更不要提直觉感知(intuition)和简化了。
			</para>
		</sect1>
		<sect1>
			<title>点对点(Ad-hoc)AJAX应用</title>
			<para>
				经过数十年的演变，Web应用已经从静态HTML发展到动态HTML，applets，Flash，最后发展到了AJAX
				<footnote>
					<para>
						Ajax是由Jesse James Garrett於Ajax: A New Approach
						to Web Applications中所提出的。
					</para>
				</footnote>
				(Asynchronous JavaScript and XML ，非同步的JavaScript和XML
				)。通过谷歌地图及推荐(Google Maps and
				Suggest)的说明，AJAX技术通过提供与桌面应用程序同等水平的互动性和反应能力给Web应用带来了新生命。不同于applets或Flash，AJAX基于标准的浏览器和JavaScript，并且不需要专门的插件。
			</para>

			<graphic align="center" fileref="img/1-2.png" />

			<para>
				AJAX是新一代的DHTML，就像DHTML，它在很大程度上依赖于JavaScript监听用户活动产生的事件,然后动态的操纵浏览器中一个页面(aka.
				DOM)的视觉表现。此外，它更近一步，能够使与服务器的沟通异步进行，即不需要离开或提交整个页面。它通过引入客户与服务器间轻量级的通信(light-weight
				communication
				)打破了基于页面的模式。妥善设计，AJAX可以给Web应用带来丰富的桌面通用组件，而且这些组件的内容可以在应用程序的控制下动态更新。
			</para>
			<para>
				当提供给用户需要的交互性的同时，AJAX给已经很昂贵的Web应用程序开发增加了复杂性和技术先决条件。开发者不得不在浏览器中操纵DOM，并且使用不兼容甚至是错误的JavaScript与服务器通信，为了更好的交互性，开发者必须重复复制应用数据和业务逻辑以便于浏览。这样就增加了维护成本及同步数据的挑战。
			</para>
			<para>
				底线是在关于处理请求方面，点对点(Ad-hoc)的AJAX应用与传统的Web应用没有区别。开发者仍然必须解决由单页性(page-based)和无状态(stateless-communication)模式造成的隔阂。
			</para>
		</sect1>
		<sect1>
			<title>ZK: 它是什么</title>
			<para>
				ZK是一个事件驱动(event-driven)的，基于组件(component-based)的，用以丰富网络程序中用户界面的框架。ZK包括一个基于AJAX事件驱动的引擎(engine)，一套丰富的XUL和XHTML，以及一种被称为ZUML(ZK
				User Interface Markup Language，ZK用户界面标记语言)的标记语言。
			</para>
			<para>
				有了ZK，您可以利用XUL和XHTML的丰富特性来呈现您的Web应用，操纵它们来处理因用户活动而引发的事件，就像您使用多年的桌面应用程序那样。不同于大多数其它框架，ZK是一种幕后(behind-the-scene)技术，组件内容的同步和流水线事件(pipelining
				of events)都由ZK引擎自动完成。
			</para>
			<para>您的用户获得了如同桌面程序的互动性和反应能力，而您的开发仍然像开发桌面应用程序那样简单。</para>
			<para>
				除了简单的模型和丰富的组件，ZK也支持一种文本标记语言，称为ZUML。ZUML，如同HTML，可以让开发人员设计界面而无需编程。通过XML的命名空间，ZUML无缝的集成了一套不同的标签
				<footnote>
					<para>标签是XML元素。组件是在当ZUML网页被翻译时所产生出来的。</para>
				</footnote>
				到同一页面。目前，ZUML支持两套标签，即XUL和HTML。
			</para>
			<para>
				为了方便快速模型开发(prototyping)和定制，ZK允许开发人员嵌入EL表达式，以及您喜欢的脚本语言，包括但不限于
				Java
				<footnote>
					<para>
						使用BeanShell(http://www.beanshell.org)的Java
						interpreter。
					</para>
				</footnote>
				, JavaScript
				<footnote>
					<para>
						使用Rhino
						(http://www.mozilla.org/rhino)的JavaScript
						interpreter。
					</para>
				</footnote>
				, Ruby
				<footnote>
					<para>
						使用JRuby (http://jruby.codehaus.org/)的Ruby
						interpreter。
					</para>
				</footnote>
				and Groovy
				<footnote>
					<para>
						使用Groovy (http://groovy.codehaus.org/)的Groovy
						interpreter。
					</para>
				</footnote>
				.
				开发人员可以选择不嵌入任何脚本语言，如果他们喜欢更严格的要求(discipline)。不同于JavaScript嵌入在HTML，ZK在服务器端执行所有的嵌入脚本。
			</para>
			<para>
				注意我们所说的一切运行在服务器端是从应用程序开发者的角度出发的。对于组件开发人员来说，他们必须平衡互动性与简单性来决定什么任务由浏览器来完成，而什么任务由服务器来完成。
			</para>
		</sect1>
		<sect1>
			<title>ZK: 它不是什么</title>
			<para>
				ZK并没有关注持久化(persistence)或伺服务器之间的沟通(inter-server
				communication)。ZK被设计的尽可能的简单，它只针对表示层(presentation
				tier)。他并不要求和暗示任何后端技术，所有你喜欢的中间件就像以前一样工作，如JDBC， Hibernate，
				Java Mail，EJB 或 JMS。
			</para>
			<para>
				Zk并没有为开发人员提供(tunnel)，RMI或其他的API用来在客户端与服务器端通信，因为所有的代码都运行在同一服务器的同一Java虚拟机(JVM)上。
			</para>
			<para>ZK并没有强迫开发人员使用MVC或其他设计模式。是否使用它们由开发人员选择。</para>
			<para>
				ZK并不是旨在把XUL带入Web应用的框架。它的目标是把桌面编程模式引入Web应用。目前，它只支持XUL和XHTML。将来它或许会支持XAML,
				Xquery及其它。
			</para>
			<para>
				ZK将AJAX嵌入到了现今的应用中(implementation)，但它并没有止步于AJAX结束的地方。在即将来临的ZK
				Mobile中，您的应用程序可以到达支持J2ME的任何设备，例如PDA，手机和游戏平台。此外，您根本不用修改您的应用程序
				<footnote>
					<para>根据萤幕大小有时需要做调整。</para>
				</footnote>
				。
			</para>
		</sect1>
		<sect1>
			<title>ZK: 局限</title>
			<para>
				ZK不适合在客户端运行多任务的应用程序，例如3D动作游戏，除非你写编写一个特殊的组件。ZK也不适合需要大量使用客户端计算能力的应用程序。
			</para>
		</sect1>
	</chapter>
	<chapter>
		<title>2. 让我们开始吧</title>
		<para>这一章的内容描述了如何写出你的第一个ZUML页面，如果你没时间的话建议你至少阅读这一章。</para>
		<para>此章使用ZUL来说明ZK的功能，但是也适合于其他ZK支持的语言。</para>
		<sect1>
			<title>Hello World!</title>
			<para>
				当ZK安装到你最喜爱的Web服务器
				<footnote>
					<para>参考Quick Start Guide。</para>
				</footnote>
				后, 你就可以直接编写应用程序。仅需在合适的目录新建一个名为hello.zul的文件
				<footnote>
					<para>你也可以试试这些例子的在线示范。</para>
				</footnote>
				。
			</para>
			<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;   Hello World!&#13;&lt;/window&gt;&#13;</programlisting>
<para>然后输入正确的URL，例如：<ulink url="http://localhost/myapp/hello.zul">http://localhost/myapp/hello.zul</ulink>，得到如下页面 ：</para>
<para/>

<graphic align="center"  fileref="img/2-1.png"/>

<para>在ZUML页面中，一个XML元素描述了应该创建。在这个例子中，被创建的是window(<code>org.zkoss.zul.Window)，</code>XML属性(<code>attributes</code>)用来指定window组件属性(properties)的值。在这个例子中，创建了window，<code>并指定了title和border属性的值分别为 '</code>Hello'和'normal'。XML元素内的文本(即Hello World)也可以通过一个称为Label (<code>org.zkoss.zul.Label</code>)的标签来展示。所以上面的例子和下面的例子是等价的：</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;   &lt;label value="Hello World!"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>互动性</title>
<para>让我们来添加一些互动元素：</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
   &lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>点击按钮，可以看到如下效果：</para>

<graphic align="center"  fileref="img/2-2c.png"/>
<para><code>onClick</code>是为组件添加事件监听器的一个特殊属性。这个属性的值可以是任何合法的Java代码。注意我们使用 &amp;<code>quot;</code>来匹配双引号(“)以使其成为合法的XML文档。如果你不熟悉XML，可以在 ZK 用户接口标记语言(ZK User Interface Markup Language )一章中查看有关 XML的部分。</para>
<para>
<code>alert</code>是一个显示消息对话框的全局函数。<code>它是调用org.zkoss.zul.Messagebox</code>类的一个捷径。 </para>
<programlisting>&lt;button label="Say Hello" onClick="Messagebox.show(&amp;quot;Hello World!&amp;quot;)"/&gt;&#13;</programlisting>
<para>[注]: </para>
<orderedlist>
<listitem>
<para>嵌入到ZUML页面的脚本可以用不同的语言编写，包括但不限于Java, JavaScript, Ruby  and Groovy。此外，它们是运行在服务器上的。</para>
</listitem>
<listitem>
<para>在运行时刻，ZK使用BeanShell解释Java，所以你可以声明全局函数，<code>例如alert。</code>同样 它为大部分的脚本语言提供了一个简单的方式来定义全局函数，有时甚至是类。</para>
</listitem>
<listitem>
<para>在ZUML页面嵌入脚本语言前，<code>所有java.lang, java.util, org.zkoss.zk.ui， org.zkoss.zk.ui.event和org.zkoss.zul包中的类都已经被引入。</code>
</para>
</listitem>
</orderedlist></sect1><sect1><title>
<code>zscript</code>元素</title>
<para>
<code>zscript</code>是一个用来定义代码的元素，当ZUML页面被提交时被赋值。典型的应用包括初始化和申明全局变量与方法。</para>
<para>[注]: <code>你不可以在zscript代码中使用EL表达式。</code>
</para>
<para>例如，下面的例子展示了每次按钮被按下时显示的不同信息。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;   &lt;button label="Say Hello" onClick="sayHello()"/&gt;&#13;   &lt;zscript&gt;&#13;   int count = 0;&#13;   void sayHello() { //declare a global function&#13;      alert("Hello World! "+ ++count);&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>[注]: <code>zscript</code>仅当页面被加载时赋值一次，通常被用于定义函数和初始变量。</para><sect2><title>脚本语言</title>
<para>Java是ZK默认的脚本语言，<code>但是你可以通过指定language属性来选择不同的语言，</code>就像下面的例子一样。<code>language属性区分大小写。</code>
</para>
<programlisting>&lt;zscript language="javascript"&gt;&#13;   alert('Say Hi in JavaScript');&#13;   new Label("Hi, JavaScript!").setParent(win);&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>你可以像下面的例子一样使用前缀 <code>javascript:</code>来为事件处理器指定脚本语言。注意：不要在自己指定语言的前面或后面添加空格。</para>
<programlisting>&lt;button onClick="javascript: do_something_in_js();"/&gt;&#13;</programlisting>
<para>你可以在同一页面中使用不同的脚本语言。</para></sect2><sect2><title>将脚本代码放在一个单独的文件中</title>
<para>为了分离代码和视图(views)，开发人员可以将将脚本代码放在单独的文件中，<code>例如sayHello.zs，</code>然后使用<code>src</code>属性指向此文件。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;   &lt;button label="Say Hello" onClick="sayHello()"/&gt;&#13;   &lt;zscript src="sayHello.zs"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>假设<code>sayHello.zs</code>文件的内容如下:</para>
<programlisting>int count = 0;&#13;void sayHello() { //declare a global function&#13;   alert("Hello World! "+ ++count);&#13;}&#13;</programlisting></sect2></sect1><sect1><title>
<code>attribute</code>元素</title>
<para>
<code>attribute</code>元素是用来定义XML元素属性的元素。妥善使用，它可以使页面更具可读性。<code>下面的例子和前面所述的hello.zul是等价的。</code>
</para>
<programlisting>&lt;button label="Say Hello"&gt;&#13;    &lt;attribute name="onClick"&gt;alert("Hello World!");&lt;/attribute&gt;&#13;&lt;/button&gt;&#13;</programlisting>
<para>
<code>你可以决定是否使用trim属性来省略属性值开头和末位的值，</code>使用方法如下：</para>
<programlisting>&lt;button&gt;&#13;   &lt;attribute name="label" trim="true"&gt;&#13;      The leading and trailing whitespaces will be omitted.&#13;   &lt;/attribute&gt;&#13;&lt;/button&gt;&#13;</programlisting></sect1><sect1><title>EL表达式</title>
<para>就像JSP一样，你可以在ZUML页面的任何部分使用EL表达式，但除了属性的名字(names of attributes)，元素(elements)和处理指令(processing instruction)。</para>
<para>EL表达式的语法格式为<code>${expr}</code>，例如：</para>
<programlisting>&lt;element attr1=”${bean.property}”.../&gt;&#13;${map[entry]}&#13;&lt;another-element&gt;${3+counter} is ${empty map}&lt;/another-element&gt;&#13;</programlisting>
<para>[提示]: <code>emp</code>
<code>ty</code>是用来测试一个map, collection, array 或者string 是否为null或空的。</para>
<para>[提示]: <code>map[entry]</code>是读取map元素的一种方法，换句话说，就像Java中的 <code>map.get(entry)</code>。</para>
<para>当一个EL表达式作为一个属性值时，它可以返回任何类型的对象，对象的长度限制在组件可以接受的范围内。在下面的例子中，表达式被赋予一个Boolean对象的值：</para>
<programlisting>&lt;window if="${some &gt; 10}"&gt;&#13;</programlisting>
<para>[提示]: + 在EL表达坏中是算数操作，并不能用于string类型。对于string可以使用 "<code>${expr1} is added with ${expr2}"。</code>
</para>
<para>标准的隐含对象(implicit objects)，<code>如param</code>和<code>requestScope，</code>还有ZK的隐含对象，<code>如self</code>和<code>page，</code>可以很简单的使用。</para>
<programlisting>&lt;textbox value="${param.who} does ${param.what}"/&gt;&#13;</programlisting>
<para>通过从TLD引入EL函数，<code>你可以使用被称为tablib的指令，</code>就像下面：</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.tld" prefix="p" ?&gt;&#13;</programlisting>
<para>Developer's Reference 提供了更多关于EL表达式的细节。或者，你可以参考JSP 2.0的指南或手册来来获得更多关于EL表达式的信息。</para></sect1><sect1><title>
<code>id</code>属性</title>
<para>为了读取Java代码或EL表达式中的组件，你可以使用<code>id</code>属性来标识它。在下面的例子中，<code>我们为</code>label<code>设置了一个标识，</code>这样当一个按钮被按下时，<code>我们就可以操纵</code>label<code>的值了。</code>
</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;   Do you like ZK? &lt;label id="label"/&gt;&#13;   &lt;separator/&gt;&#13;   &lt;button label="Yes" onClick="label.value = self.label"/&gt;&#13;   &lt;button label="No" onClick="label.value = self.label"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当按下Yes按钮时，可以看到如下效果：</para>

<graphic align="center"  fileref="img/2-6a.png" />

<para>下面是一个EL表达式为组件赋值的例子：</para>
<programlisting>&lt;textbox id="source" value="ABC"/&gt;&#13;&lt;label value="${source.value}"/&gt;&#13;</programlisting></sect1><sect1><title>
<code>if</code>
<code>和</code>
<code>unless</code>属性</title>
<para>
<code>if和unless属性被用于控制是否创建一个组件，</code>在下面的例子中，<code>两个</code>label<code>只有在请求中含有一个为vote的属性时才被创建：</code>
</para>
<programlisting>&lt;label value="Vote 1" if="${param.vote}"/&gt;&#13;&lt;label value="Vote 2" unless="${!param.vote}"/&gt;&#13;</programlisting>
<para>如果两个属性都被指定，将不会创建组件除非它们的值都被赋值为true。</para></sect1><sect1><title>
<code>forEach</code>属性</title>
<para>forEach 属性用来控制要创建多少组件，如果你为这个对象指定一个对象集合，ZK 装载机(ZK loader)将为每个被指定的集合项目创建一个组件。在下面的ZUML页面中，<code>listitem元素将被赋值三次(</code>分别为"Monday", "Tuesday" 和"Wednesday")然后产生三个list项目。</para>
<programlisting>&lt;zscript&gt;contacts = new String[] {"Monday", "Tuesday", "Wednesday"};&lt;/zscript&gt;&#13;<inlinegraphic align="right"  fileref="img/2-8.png" />&lt;listbox width="100px"&gt;&#13;  &lt;listitem label="${each}" forEach="${contacts}"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>当使用forEach属性赋值时，</code>每个变量被一个接一个的赋予来自集合的对象，即像先前接触的例子一样。因上面的ZUML页面和下面的是等价的：</para>
<programlisting>&lt;listbox&gt;&#13;   &lt;listitem label="Monday"/&gt;&#13;   &lt;listitem label="Tuesday"/&gt;&#13;   &lt;listitem label="Wednesday"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>除了使用forEach，还可以通过forEachBegin和forEachEnd来控制迭代(</code>iteration)，可以参考 ZK User Interface Markup Language一章中有关ZK属性的一节来获得详细信息。</para></sect1><sect1><title>
<code>use</code>属性</title>
<para>在页面中嵌入代码不当会增加维护的难度，有两种途径可以从视图中分离出代码。</para>
<para>一种途径是你可以监听所关心的事件，然后调用合适的方法进行处理。例如，可以调用<code>onCreate</code>
<footnote>
<para>当ZUML中window产生时onCreate事件会被送出。</para>
</footnote>, <code>onOK</code>
<footnote>
<para>使用者按下ENTER key时onOK事件被送出。</para>
</footnote>, <code>onCancel</code>
<footnote>
<para>使用者按下ESC key时onCancel事件被送出。</para>
</footnote> 事件来完成初始化(initialize)，处理(process)和取消(cancel)等工作。</para>
<programlisting>&lt;window id="main" onCreate="MyClass.init(main)"
   onOK="MyClass.process(main)" onCancel="MyClass.cancel(main)"/&gt;&#13;</programlisting>
<para>另外，必须有一个名称为MyClass的Java类，内容像下面一样：</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyClass {&#13;   public static void init(Window main) { //does initialization&#13;   }&#13;   public static void save(Window main) { //saves the result&#13;   }&#13;   public static void cancel(Window main) { //cancel any changes&#13;   }&#13;}&#13;</programlisting>
<para>另一种途径，你可以使用<code>use</code>属性来指定一个类，用来替换默认的组件类。</para>
<programlisting>&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>然后必须创建一个名为MyWindow的Java类，内容如下：</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyWindow extends Window {&#13;   public void onCreate() { //does initialization&#13;   }&#13;   public void onOK() { //save the result&#13;   }&#13;   public void onCancel() { //cancel any changes&#13;   }&#13;}&#13;</programlisting>
<para>这两种方法有着不同的优点，它们都扮演者MVC模式中控制者(controller)的角色。使用哪种分方法是您的选择。</para><sect2><title>以 <code>zscript</code>实现Java类</title><para>在<code>zscript</code>中继承Java类，多亏了BeanShell<footnote>
<para>http://www.beanshell.org</para>
</footnote>的强大功能，Java类的继承可以按如下的方式完成：</para>
<para/>
<programlisting>&lt;zscript&gt;&#13;   public class MyWindow extends Window {&#13;
   }
&lt;/zscript&gt;
&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>[提示]:很多脚本语言，例如JRuby，也允许开发人员定义可以被Java虚拟机(JVM)存取的类，请参考相应的手册来了解详情。</para>
<para>为了从视图中分离代码，你可以把所有的<code>zscript</code>代码放到单独的文件中，称为<code>mywnd.zs</code>，然后：</para>
<programlisting>&lt;zscript src="/zs/mywnd.zs"/&gt;&#13;&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>[提示]:你也可以使用初始化指令(<code>init</code>directive)来指定<code>zscript</code>文件的位置。不同的是初始化指令在所有组件被创建前被赋指(页面初始阶段)。如需更多信息请参考ZK User Interface Markup Language 一章中有关初始化指令( <code>init</code>Directive section)的部分。</para></sect2></sect1><sect1><title>手动创建组件</title>
<para>除了讲述什么组件可以在ZUML页面被创建外，开发人员可以手动创建组件。所有的组件都是具体的(concrete)，你可以直接<footnote>
<para>为了简化，这里不用factory design pattern。</para>
</footnote>通过它们的构造函数(constructors)来创建它们。</para>
<programlisting>&lt;window id="main"&gt;&#13;   &lt;button label="Add Item"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;   new Label("Added at "+new Date()).setParent(main);&#13;   new Separator().setParent(main);&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;   &lt;separator bar="true"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当一个组件被手动创建时，它并没有自动被加到页面。换句话说，它并不在用户的浏览器中出现。为了将它加到页面，你可以调用<code>setParent</code>，<code>appendChild</code>或 <code>insertBefore</code>方法来为其指定一个父类(parent)，如果父类组件是页面的一部分，那么它也变成了页面的一部分。</para>
<para>组件类并没有destroy 或close方法<footnote>
<para>与W3C DOM的观念相近。而另一方面，Windows API需要程序员管理生命周期。</para>
</footnote>，当一个组件从页面中被拆卸的时候就会从浏览器中内移除。它表现的就像附着在页面上一样。</para>
<programlisting>&lt;window id="main"&gt;&#13;   &lt;zscript&gt;Component detached = null;&lt;/zscript&gt;&#13;   &lt;button id="btn" label="Detach"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;   if(detached != null) {&#13;      detached.setParent(main);&#13;      detached = null;&#13;      btn.label = "Detach";&#13;   } else {&#13;      (detached = target).setParent(null);&#13;      btn.label = "Attach";&#13;   }&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;label id="target" value="You see this if it is attached."/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>在上面的例子中，你可以用<code>setVisible</code>方法来产生类似的效果。但是<code>setVisible(false)</code>方法并没有把组件从浏览器中移除，它只是使一个组件(及其所有的子组件(children))变得不可见。</para>
<para>当一个组件从页面被卸载后，如果应用程序没有涉及到该组件，它所占用的内存会被Java虚拟机的垃圾回收机制(JVM's garbage collector)所释放。</para><sect2><title>不使用ZUML来开发ZK应用程序</title>
<para>对于根本不习惯使用ZUML的开发人员来说，他们可以使用被称为richlet的方法来手动创建所有的组件。</para>
<programlisting>import org.zkoss.zul.*;&#13;public class TestRichlet extends org.zkoss.zk.ui.GenericRichlet {&#13;   public void service(Page page) {
      page.setTitle("Richlet Test");

      final Window w = new Window("Richlet Test", "normal", false);&#13;
      new Label("Hello World!").setParent(w);&#13;
      final Label l = new Label();
      l.setParent(w);
      //...
      w.setPage(page);
   }&#13;}&#13;</programlisting>
<para>请参考增强型功能(Advanced Features)一章中有关Richlets 的部分。 </para></sect2></sect1><sect1><title>为某一页面定义新的组件</title>
<para>就像所展示的那样，通过使用XML属性为组件指定一个属性是很容易的事情。</para>
<programlisting>&lt;button label="OK" style="border:1px solid blue"/&gt;&#13;</programlisting>
<para>ZK提供了一种强大但很简单的方式来让开发人员为某一页面定义新的组件，如果同一类型的大多数组件共享一套属性，这就非常有用。</para>
<para>首先使用组件指令来定义一个新的组件。</para>
<programlisting>&lt;?component name="bluebutton" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;bluebutton/&gt;
&lt;bluebutton label="Cancel"/&gt;</programlisting>
<para>等价于：</para>
<programlisting>&lt;bluebutton style="border:1px solid blue" label="OK"/&gt;
&lt;bluebutton style="border:1px solid blue" label="Cancel"/&gt;</programlisting>
<para>此外，你可以用下面的方式来覆盖<code>button</code>组件的定义，当然，这不会影响到其他的页面：</para>
<programlisting>&lt;?component name="button" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;button/&gt;
&lt;button label="Cancel"/&gt;</programlisting>
<para>如需要更多的信息，请参考ZK用户界面标记语言(ZK User Interface Markup Language)一章中关于组件指令(<code>component</code>Directive )的部分。</para></sect1></chapter><chapter><title>3. 基础</title><para>这一章讲述了ZK的基础。这里使用了XUL来说明ZK的功能，但同样可用于ZK支持的其他标记语言。</para><sect1><title>架构概况</title>
<para>ZK包括一种基于AJAX机制用来实现自动的交互性，一套丰富的基于XUL的组件用以丰富可用性，和一种的标记语言用来简化开发。</para>
<para>基于AJAX的机制包括三个部分，描绘如下：ZK 加载器(ZK loader)，ZK AU引擎(ZK AU Engine )，和ZK客户端引擎(ZK Client Engine)。</para>

<graphic align="center"  fileref="img/3-1.png"/><para>基于用户的请求，ZK 加载器(ZK loader)加载一个ZK页面，解释它，并将结果送到HTML页面来响应URI请求。ZK页面是用一种被称为ZUML的标记语言写成的。ZUML，就像HTML，被用来描述什么组件被创建，以及如何把它们呈现出来。这些组件一旦被创建，就会一直处于可用状态知道会话超时。</para>
<para>然后ZK AU<footnote>
<para>AU 即Asynchronous Update，异步更新。</para>
</footnote> 引擎(ZK AU Engine )和ZK客户端引擎(ZK Client Engine)作为投手和捕手一起工作。它们将在浏览器端发生的事件送到运行在服务器端的应用程序，然后更新浏览器段的DOM树，基于组件如何被应用程序操纵。这种方式即所谓的事件驱动编程模型。</para><sect2><title>执行流</title>
<orderedlist>
<listitem>
<para>当用户在浏览器中键入一个URL或点击一个超链接时，一个请求便被送到了Web服务器，如果URI符合ZK的配置<footnote>
<para>参考 the Developer's Reference中的Appendix A 。</para>
</footnote>，ZK 加载器则援引担任这一要求 。</para>
</listitem>
<listitem>
<para>ZK 加载器(ZK loader)加载指定的页面然后解释它，以据此创建和适的组件。</para>
</listitem>
<listitem>
<para>当解释完整个页面后，ZK 加载器(ZK loader)将结果送到一个HTML页面。然后这个HTML页面被送回浏览器和ZK客户端引擎(ZK Client Engine)<footnote>
<para>ZK客户端引擎(ZK Client Engine)是由JavaScript语言编写的。浏览器缓存ZK客户端引擎，所以通常仅需在首次读取时设置引擎。</para>
</footnote>一起。</para>
</listitem>
<listitem>
<para>ZK客户端引擎(ZK Client Engine)坐落在浏览器，以监视由客户的活动触发的事件，例如挪动鼠标，或改变某个值。一旦监测到，它就通知ZK AU引擎通过发送一个ZK请求<footnote>
<para>Zk请求(ZK requests)是一种特殊的AJAX 请求。 但是，对于mobile版本，ZK 请求是一种特殊的HTTP 请求。</para>
</footnote>。</para>
</listitem>
<listitem>
<para>当从客户端引擎接到ZK请求后，如果有需要的话AU引擎就更新相应组件的内容。然后，AU引擎通过调用相关的事件处理程序(如果有的话)来通知应用程序。</para>
</listitem>
<listitem>
<para>如果应用程序选择改变组件的内容，添加或移动组件，AU引擎通过ZK响应(ZK responses)将更新后组件的新内容送至客户端引擎。</para>
</listitem>
<listitem>
<para>这些ZK响应实际上是一些命令，这些命令指示客户端引擎如何更新DOM树的内容。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>组件，页面和桌面</title><sect2><title>组件</title>
<para>组件即一个用户界面(UI)对象，如标签，按钮和树。它用来定义 一个特定用户界面的视觉表现和行为。通过操纵他们， 开发 人员来控制如何在客户端展示一个应用程序。</para>
<para>组件必须实现 <code>org.zkoss.zk.ui.Component</code>接口。</para></sect2><sect2><title>页面</title>
<para>页面(<code>org.zkoss.zk.ui.Page</code>)是一系列组件的集合，一个页面限制属于它的组件，这样它们会被展示在浏览器的特定部分。一个页面被自动创建当ZK 加载器(ZK loader)解释完一个ZUML页面时。</para><sect3><title>页面标题</title>
<para>每个页面都可以有一个标题，这个标题将被作为浏览器窗口标题(window caption)的一部分。请参考ZK用户界面标记语言(ZK User Interface Markup Language)一章中有关处理指令(Processing Instructions)的部分。</para>
<programlisting>&lt;?page title="My Page Title"?&gt;&#13;</programlisting></sect3></sect2><sect2><title>桌面</title>
<para>一个ZUML可以直接或间接包含另外一个ZUML页面。由于这些页面是为服务同样的URL请求而创建的，它们被统称为桌面(<code>org.zkoss.zk.ui.Desktop</code>)。换句话说，桌面是页面的集合，这些 页面服务于同样的URL请求。</para>

<graphic align="center"  fileref="img/3-2-3a.png"/>

<para>为了实现Zk应用程序与用户的交互，更多的页面需要被加到桌面，而另一些需要从桌面移除。类似的，一个组件可能被加到页面或从页面移除。</para><sect3><title>createComponents 方法</title><para>请注意创建移除页面和桌面都是在背后达成的。并没有关于此的API。每次ZUML加载一个页面时，这个页面就被创建。当ZK发现某个页面不再被用到时这个页面就会被移除。当第一个ZUML页面被加载时桌面被创建。当太多的桌面为特定的会话而创建时桌面会被移除。</para>
<para>
<code>org.zkoss.zk.ui.Executions</code>类中的<code>CreateComponents</code>方法仅能创建组件，而不是页面，即使它装载一个ZUML页面(亦=page)。</para></sect3></sect2><sect2><title>组件树的森林</title>
<para>一个组件至多有一个父组件，而可能有多个子组件。一些组件只能接受某些类型的组件作为子组件，一些组件必须为某些类型组件的子组件，一些组件根本不允许有子组件。例如，XUL中的Listbox接受Listcols 和 Listitem 。没有任何父组件的组件称为根组件(root component)。一个页面可能有多个根组件，这些组件可以由<code>getRoots</code> 方法获得。</para></sect2><sect2><title>组件：视觉表现和Java对象</title>
<para>除了在服务器端的Java对象，组件在浏览器端有一个可视部分<footnote>
<para>如果客户端为浏览器， 视觉表现为 一个 DOM 元素 或一个套DOM 元素。</para>
</footnote> ，并且当且仅当它属于一个页面时。当一个组件附加到一个页面时，其视觉部分就会被创建<footnote>
<para>可是部分是自动创建，更新和移除的。应用程序开发人员很少需要注意到它的存在。 他们在在服务器端操纵对象部分（object part)。</para>
</footnote>。当一个组件从一个页面脱离时，其视觉部分被移除。</para>
<para>有两种方法将一个组件附加到一个页面。第一种，你可以调用<code>setPage</code>方法使一个组件成为指定页面的根组件。第二中，你可以调用<code>setParent</code>，<code>insertBefore</code>或<code>appendChild</code>方法来使其成为另外一个的子组件，那么属于同一页面的子组件将会属于父组件所属于的页面。</para>
<para>同样，你可以通过调用<code>setPage</code>方法并将其参数设为<code>null</code>将一个根组件从页面卸载。当一个子组件从父 组件被卸载或其父组件从页面被卸载时，此组件被卸载。</para></sect2><sect2><title>Identifiers</title>
<para>每个组件都有一个标识(可利用<code>getId</code>方法获得)，当一个组件被创建时它被自动创建。开发人员可以在任何时候改变它。对于标识如何命名并没有限制。但是，如果一个字母标识(alphabetical identifier)被指定之后，开发人员可以通过Java代码或 嵌入到ZUML页面的EL表达式直接读取到它。</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;   Do you like ZK? &lt;label id="label"/&gt;&#13;   &lt;separator/&gt;&#13;   &lt;button label="Yes" onClick="label.value = self.label"/&gt;&#13;   &lt;button label="No" onClick="label.value = self.label"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>UUID</title>
<para>一个组件有另外一个称为UUID的标识，但应用程序开发人员很少用到它。</para>
<para>UUID是被组件和客户端引擎用来操纵浏览器端的DOM以及和服务器进行通信的。更确切地说，客户端DOM元素的id属性就是UUID。</para>
<para>当一个组件被创建时，UUID会自动产生。除了用以呈现HTML标签的组件标识，它是一成不变的。</para>
<para>相关的HTML组件处理UUID的方式不同于其他的一套组件：UUID就像ID一样。如果你改变一个HTML相关组件的ID，UUID就会跟着改变。因此原来的JavaScript 代码和servlets 将会继续工作，而无需任何修改。</para></sect2></sect1><sect1><title>ID空间 </title>
<para>将视觉表现(visual representation)分为几个ZUML页面是很常见的。例如，一个页面用来展示订购单，一个对话框用于进入付款期。如果同一个桌面内所有的组件都是非常明确的，开发人员必须为这个桌面内所有页面维护所有标识的唯一性。为了解决这个问题，ID空间的概念被引入。一个ID空间是一个桌面的组件的子集。唯一性只在ID空间的范围内有保障。</para>
<para>Id空间的最简单形式是一个window(<code>org.zkoss.zul.Window</code>)。所有window衍生出来的组件(包括window)形成了一个独立的ID空间。因此，你可以将window作为每个页面的最高组件使用，这样，开发人员需要维护每个页面的唯一性。</para>
<para>更一般地说，任何组件可形成一个ID空间，只要它实现了<code>org.zkoss.zk.ui.IdSpace</code>接口。页面(Page)也实现了这个接口，所以它又是个空间所有者(space owner)。</para>
<para>一个ID空间的最高组件即为空间的所有者，可以使用<code>Component</code>接口中的<code>getSpaceOwner</code>方法来获得这个组件。</para>
<para>如果一个称为X的ID空间，从另外一个称为Y的ID空间衍生而来，那么X的所有者是空间Y的一部分，但从X衍生出来的部分并不是空间Y的一部分。</para>
<para>就像在图中描绘的一样，有三个空间：P，A 和C。空间P包括P，A，F和G。空间A包括A，B，C和D。空间C包括C和E。</para>

<graphic align="center"  fileref="img/3-3.png"/>

<para>在相同ID空间内的组件称为fellows，例如A，B，C和D就是同一ID空间内的fellows。</para>
<para>为了获得另一个fellow，可以使用<code>IdSpace</code>或<code>Component</code>接口中的<code>getFellow</code>方法。</para>
<para>请注意可以<code>getFellow</code>方法可以被同一ID空间内任何组件调用，并不仅限于空间所有者。同样，对于在同一空间内的任何组件，<code>getSpaceOwner</code>方法返回的是同样的对象，与是否是空间所有者无关。</para>
<para>
<code>org.zkoss.zk.ui.Path</code>类提供了在ID空间内简化定位组件的工具。其使用凡是类似<code>java.io.File</code>
</para>
<programlisting>Path.getComponent("/A/C/E");
new Path("A/C", "E").getComponent();</programlisting><sect2><title>命名空间和ID空间</title>
<para>为了能让解释器(interpreter)直接读取到组件，命名空间(<code>org.zkoss.scripting.Namespace</code>)的概 念被引入。首先，每一个ID空间都有一个确切的命名空间。第二，定义在命名空间内的变量对于属于 同一个命名空间的脚本代码及EL表达式是可见的。</para>
<programlisting>&lt;window border="normal"&gt;&#13;   &lt;label id="l" value="hi"/&gt;&#13;<inlinegraphic align="right"  fileref="img/3-3-1.png"/>   &lt;zscript&gt;&#13;      l.value = "Hi, namespace";&#13;   &lt;/zscript&gt;&#13;   ${l.value}&#13;&lt;/window&gt;&#13;</programlisting>
<para>下面的例子有两个命名空间，一个属于window <code>w1</code>，另一个属于window <code>w2</code>。<code>b1</code>按钮的<code>onClick</code>事件针对window <code>w1</code>内定义的label，而<code>b2</code>按钮的<code>onClick</code>事件是针对窗口window <code>w2</code>
<footnote>
<para>window 实现了 <code>org.zkoss.zk.ui.IdSpace</code>, 所以它形成了一个独立的ID空间和命名空间。</para>
</footnote>内的定义的checkbox。</para>
<programlisting>&lt;window id="w1"&gt;&#13;   &lt;window id="w2"&gt;&#13;      &lt;label id="c"/&gt;&#13;      &lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;&#13;   &lt;/window&gt;&#13;   &lt;checkbox id="c"/&gt;&#13;   &lt;button id="b2" onClick="c.label = &amp;quot;OK&amp;quot;"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>请注意命名空间是有等级的。换言之，window <code>w2</code>中的<code>zscript</code>可以看见window <code>w1</code>中的组件，除非她凌驾于window <code>w2</code>。因此，在下面的例子中button <code>b1</code>将会改变标签<code>c</code>。</para>
<programlisting>&lt;window id="w1"&gt;&#13;   &lt;window id="w2"&gt;&#13;      &lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;&#13;   &lt;/window&gt;&#13;   &lt;label id="c"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>除了ZK指定的添加到命名空间的组件，你可以指定自己的变量通过使用<code>setVariable</code>方法，这样 <code>zscript</code>可以直接参考(reference)它们。</para></sect2><sect2><title>在<code>zscript</code>中定义变量和函数</title><para>除了执行代码,你可以在<code>zscript</code>元素中直接定义变量和函数，就像下面描绘的一样:</para>
<programlisting>&lt;window id="A&gt;&#13;   &lt;zscript&gt;&#13;      Object myvar = new LinkedList();&#13;      void myfunc() {&#13;         ...&#13;      }&#13;   &lt;/zscript&gt;&#13;   ...&#13;   &lt;button label="add" onClick="myvar.add(some)"/&gt;&#13;   &lt;button label="some" onClick="myfunc()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>在<code>zscript</code>中定义的变量和函数存储在相应脚本语言的解释器(interpreter )中。</para><sect3><title>
<code>zscript</code>和<code>EL</code>表达式</title>
<para>就像命名空间<footnote>
<para>
<code>org</code>
<code>.zkoss.zk.scripting.Namespace</code>
</para>
</footnote>一样，定义在<code>zscript</code>中的变量对于EL表达式都是可见的。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;   String var = "abc";&#13;
   self.setVariable("var2", "xyz", true);
   &lt;/zscript&gt;&#13;   ${var} ${var2}&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;abc xyz&#13;&lt;/window&gt;&#13;</programlisting>
<para>请注意，定义在<code>zscript</code>中的变量比定义在命名空间中的变量有更高的优先级。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;   String var = "abc";&#13;   self.setVariable("var", "xyz", true);&#13;   &lt;/zscript&gt;&#13;   ${var}&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;
abc
&lt;/window&gt;</programlisting>
<para>但如果你之后声明了一个同名组件，这就会令人困惑，就像下面展示的那样。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;   String var = "abc";&#13;
   &lt;/zscript&gt;
   &lt;label id="var" value="A label"/&gt;
   ${var.value} &lt;!-- Wrong! var is "abc", not the label --&gt;
&lt;/window&gt;</programlisting>
<para>因此，建议使用一些命名方式来避免这种困惑。例如，你可以为所有的解释(interpreter)变量加上前缀<code>zs_</code>。</para>
<para>另外，应该尽量使用局部变量。局部变量是和类名一起被声明的，并且只对某一范围的<code>zscript</code>代码可见。</para>
<programlisting>&lt;zscript&gt;&#13;Date now = new Date();&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>你可以通过将其放在{}中使局部变量对于EL表达式不可见，如下：</para>
<programlisting>&lt;zscript&gt;&#13;
{ //create a new logic scope
   String var = "abc"; //visible only inside of the enclosing curly brace&#13;
}
&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>多范围(Multi-Scope)的解释器</title><para>依靠实现，一个解释器或许有确切的范围，或每个ID空间一个逻辑范围来存储这些变量和方法。出于 以上的描述，我们将它们分别称为单范围和多范围的解释器(single-scope and multi-scope interpreters)。</para>
<para>Java解释器(BeanShell)是一个典型的多范围解释器。<footnote>
<para>Java 解释器支持多范围(multi-scope )在 2.3.1 (包括)之后及2.2.1 (包括)之前</para>
</footnote>。它为每个ID空间创建一个独立的解释范围。例如，在下面的例子中分别为window <code>A</code>和<code>B</code>创建两个逻辑范围。因此在下面的例子中，<code>var2</code>仅对于window <code>B</code>是可见的，<code>var1</code>对于窗口<code>A</code>和<code>B</code>都是可见的。</para>
<programlisting>&lt;window id="A"&gt;&#13;   &lt;zscript&gt;var1 = "abc";&lt;/zscript&gt;&#13;   &lt;window id="B"&gt;&#13;      &lt;zscript&gt;var2 = "def";&lt;/zscript&gt;&#13;   &lt;/window&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect4><title>Java解释器(BeanShell)</title>
<para>通过Java解释器，你可以为一个最近ID空间(例如一个窗口window)的逻辑范围声明一个局部解释变量(interpreter variable)通过指定类名，如下例所示：</para>
<programlisting>&lt;window id="A"&gt;&#13;   &lt;window id="B"&gt;&#13;      &lt;zscript&gt;&#13;   String b = "local to window B";&#13;
      &lt;/zscript&gt;
   &lt;/window&gt;
&lt;/window&gt;</programlisting>
<para>下面是一个更复杂的例子，可以产生<code>abc def</code>。</para>
<programlisting>&lt;window id="A"&gt;&#13;   &lt;zscript&gt;&#13;   var1 = var2 = "abc";&#13;   &lt;/zscript&gt;&#13;   &lt;window id="B"&gt;&#13;      &lt;zscript&gt;&#13;   Object var1 = "123";&#13;   var2 = "def";&#13;   var3 = "xyz";&#13;      &lt;/zscript&gt;&#13;   &lt;/window&gt;&#13;   ${var1} ${var2} ${var3}&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>Object var1 =</code>"<code>123</code>"实际上是为window <code>B</code>创建了一个局部变量，对象是指定的。另一方面，<code>var2 =</code>"<code>def</code>"会使解释器(interpreter)在当前或更高的范围内寻找名称为<code>var2</code>的变量。<code>var2</code>变量在window <code>A</code>内已被定义，变量在此被重定义(overrided)。<code>var3 =</code>"<code>xyz</code>
<code>"</code>为窗口(winodw)<code>B</code>创建了一个局部变量，而window <code>A</code>并没有定义任何叫做<code>var3</code>的变量。</para></sect4></sect3><sect3><title>单范围(Single-Scope)解释器</title>
<para>Ruby, Groovy 和javaScript解释器(Interpreters)并不支持多范围<footnote>
<para>在不久的将来我们或许会支持。</para>
</footnote>。这就意味着定义的所有变量，就是说， Ruby存储在一个逻辑范围内(每一个解释器)。因此，定义在一个窗口中的解释变量(interpreter variables)会覆盖定义在另一个窗口中的变量，如果它们在同一个页面内。为了避免这种困惑，你可以为每个变量的名字加上与窗口相关的特殊前缀。</para>
<para>[提示]:每个页面都有它自己的解释器(interpreter)来为zscript代码赋值，如果一个桌面有多个页面，那么它或许有多个解释器的实例(instances of the interpreters)(每一种脚本语言)。</para></sect3><sect3><title>在一个页面中使用多种脚本语言</title>
<para>每种脚本语言都与一种解释器(interpreter)相关联。因此，定义在一种语言中的变量和方法对于另外一种语言是不可见的。例如在下面的例子中，变量<code>var</code>
<code>1</code>和<code>var2</code>属于两种不同的解释器(interpreter)。</para>
<programlisting>&lt;zscript language="Java"&gt;&#13;   var1 = 123;&#13;&lt;/zscript&gt;&#13;&lt;zscript language="JavaScript"&gt;&#13;   var2 = 234;&#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>
<code>getVariable</code>VS <code>getZScriptVariable</code>
</title>

<para>可以通过<code>getVariable</code>方法获得定义在命名空间内的变量。另一方面，定义在<code>zscript</code>中的变量是解释它的解释的一部分，它们不是任何命名空间的一部分。换句话说，你不能通过<code>getVariable</code>方法获取它。</para>
<para>你必须使用<code>getZScriptVariable</code>方法来获得<code>zscript</code>中的定义的变量。同样，可以使用<code>getZScriptClass</code>和<code>getZScriptMethod</code>方法来获取定义在<code>zscript</code>中的类和方法。这些方法将会遍历所有的被加载的解释器直到指定的一个被找到。</para>
<para>如果你想找到某个解释器，可以使用<code>getInterpreter</code>方法先获得解释器，就像下面一样：</para>
<programlisting>&lt;zscript&gt;
   var1 = 123; //var1 belongs to the interpreter, not any namespace
   page.getVariable("var1"); //returns null
&lt;/zscript&gt;</programlisting>
<para>相反，你必须使用<code>getZScriptVariable</code>方法来获得<code>zscript</code>中的定义的变量。同样，可以使用<code>getZScriptClass</code>和<code>getZScriptMethod</code>方法来获取定义在<code>zscript</code>中的类和方法。这些方法将会遍历所有的被加载的解释器(interpreter)知道指定的一个被找到。</para>
<para>如果你想找到某个解释器，可以使用<code>getInterpreter</code>方法先获得解释器，就像下面一样：</para>
<programlisting>page.getInterpreter("JavaScript").getVariable("some"); //interpreter for JavaScript&#13;
page.getInterpreter(null).getVariable("some"); //interpreter for default language</programlisting></sect3></sect2></sect1><sect1><title>事件</title>
<para>事件(<code>org.zkoss.zk.ui.event.Event</code>)用来通知服务器发生了什么。每种类型的事件都由一种不同的类来表示。例如，<code>org.zkoss.zk.ui.event.MouseEvent</code>来代表鼠标活动，如点击。</para>
<para>为了响应事件，服务器需要为其注册一个或多个事件监听器。由两种方法来注册一个事件监听器。一种是通过在标记语言中指定<code>onXxx</code>属性。另一种方法是为你要监听的组件或页面调用<code>addEventListener</code>方法。</para>
<para>除了在浏览器端由客户活动触发的事件，一个应用程序可以<code>org.zkoss.zk.ui.event.Events</code>类中的<code>sendEvent</code>和<code>postEvent</code>方法来触发事件。</para></sect1><sect1><title>桌面和事件处理</title>
<para>如上所述，桌面是页面的集合，这些页面服务于同样的URL请求。一个桌面当然是事件监听器能读取的范围。</para>
<para>当一个事件被触发时，它就和桌面联系在一起。ZK分离基于关联桌面及流水事件(pipelines events)分成单独的队列。因此，同一桌面的事件可以被顺序处理。另一方面，不同桌面的事件可以被并行处理。</para>
<para>一个事件监听器是被允许读取事件关联桌面内任何页面的任何组件的。它也被允许将一个组件从一个页面移到另一个页面，只要这些页面在同一桌面内。另一方面，它不能读取到其它桌面的组件。</para>
<para>[注]: 开发人员可以在一个事件监听器中将一个组件从一个桌面卸载，然后在另外的事件监听器中将其添加到另外一个桌面。</para><sect2><title>桌面及创建组件</title>
<para>当一个组件在一个事件监听器中被创建时，它就自动被分配到被处理的事件相关联的桌面。即使组件不属于一个页面这种分配也会发生。这就意味着你在事件监听器中创建的任何组件可以用于监听正在处理的同一桌面。</para>
<para>如果一个组件是在一个线程(thread)而不是任何事件监听器中创建的话，它就不属于任何桌面。在这种情况下，可以将它添加到任何一个桌面，只要添加发生在一个合适的监听程序中。当然，一旦组件被添加到一个桌面，它就一直属于这个桌面。</para>
<para>对于大多数应用程序而言，很少在线程(thread)而不是事件监听器中创建组件。然而，如果有一个长操作(long operation)，你或许会在后台线程(background thread)中执行它。那么，你可以在后台准备一些组件树，然后在合适的事件被接收时将它们添加到桌面。关于此的详细信息，请参考事件监听和处理(Event Listening and Processing)中关于长操作(Long Operations)的部分。</para></sect2></sect1><sect1><title>ZUML 和XML命名空间</title><para>ZK用户界面标记语言(ZK User Interface Markup Language，ZUML)是一套基于XML的语言，开发人员可以用它来描述视觉表现。ZK的目标是分离出一套独立的组件一供使用。换句话说，一套不同的组件<footnote>
<para>亦称为标签(tags)。 在组件与标签之间有一对一的映射。</para>
</footnote>，就像XUL和XHTML，可以同时在同一ZUML页面内使用。不同的标记语言可以被透明地添加。如果两套或更多的组件在同一页面内被使用，开发人员必须使用XML命名空间来区分它们。请参考 ZK用户界面标记语言(ZK User Interface Markup Language )一章中关于组件集合XML命名空间(Component Sets and XML Namespaces)的部分，如果你想在同一页面中使用多套组件，就像XUL和XHTML。</para>
<para>[提示]:在ZUML中使用XML命名空间是可选的，你只有在使用多套组件时会用到它。</para></sect1></chapter><chapter><title>4. 组件活动周期</title><para>本章描述了加载页面和更新页面的活动周期。</para><sect1><title>加载页面的活动周期</title>
<para>ZK加载器(ZK loader)加载并解释页面需要经历四个阶段：页面初始阶段，组件创建阶段，事件处理阶段及响应阶段(the Page Initial Phase, the Component Creation Phase, the Event Processing Phase, and the Rendering Phase)。</para><sect2><title>页面初始阶段</title>
<para>在这个阶段，ZK处理处理指令，被称为初始化(<code>init</code>)。如果并没有定义这样的处理指令，此阶段会被跳过。</para>
<para>对于每个<code>init</code>处理指令都有一个<code>class</code>属性，一个指定类的实例(instance)将会被创建，然后它的<code>doInit</code>方法将会被调用。当然，这个类要做什么取决于你的应用程序的需求。</para>
<programlisting>&lt;?init class="MyInit"?&gt;&#13;</programlisting>
<para>初始处理指令的另一种形式是使用<code>zscrtpt</code>属性指定包含脚本代码的文件如下。那么在页面初始阶段这个文件将会被解释。</para>
<programlisting>&lt;?init zscript="/my/init.zs"?&gt;&#13;</programlisting>
<para>请注意在这个阶段页面并没有被附加到桌面。</para></sect2><sect2><title>组件创建阶段</title>
<para>在这个阶段，ZK加载器(ZK loader)解释一个ZUML页面，它创建并初始组件。这需要以下的一些步骤：</para>
<orderedlist>
<listitem>
<para>对于每个元素，它检查<code>if</code>和<code>unless</code>以确定元素是否有效。如果无效，此元素及其所有的子元素将 会被忽略。</para>
</listitem>
<listitem>
<para>如果<code>forEach</code>被指定并伴随着一个项目的集合，ZK将会为集合中的每个项目重复以下步骤。</para>
</listitem>
<listitem>
<para>基于元素名字，或使用<code>use</code>属性指定的类(如果有的话)创建一个组件。</para>
</listitem>
<listitem>
<para>基于在ZUML页面属性指定的顺序依次初始成员。</para>
</listitem>
<listitem>
<para>解释嵌套的元素(nested elements)并重复整个过程。</para>
</listitem>
<listitem>
<para>调用<code>afterCompose</code>方法如果组件实现了<code>org.zkoss.zk.ui.ext.AfterCompose</code>
<footnote>
<para>step 3-5 即所谓的composing。这是此方法称为 <code>AfterCompose</code>的原因。</para>
</footnote>接口。</para>
</listitem>
<listitem>
<para>在所有的组件都被创建后，<code>onCreate</code>事件被送到该组件，这样之后应用程序可以初始划化一些元素的内容。注意，<code>onCreate</code>事件首先为子组件公布。</para>
</listitem>
</orderedlist>
<para>[注]: 开发人员可以通过监听<code>onCreate</code>事件或实现<code>AfterCompose</code>接口来完成一些特定应用程序的初始化。<code>AfterCompose</code>在组件创建阶段(the Component Creation Phase)被调用，而<code>onCreate</code>事件是由事件监听器来处理的。一个事件监听器者可以自由地挂起或恢复执行(例如创建对话框(modal dialogs)),而由于<code>AfterCompose</code>不需要派生另一个线程， 所以它快一些。</para></sect2><sect2><title>事件处理阶段</title>
<para>在这个阶段，ZK依次调用每个事件的监听器，这些事件已经为桌面排好队列。一个独立线程开始调用监听，这样它可以在不影响其它事件处理的情况下被挂起。</para>
<para>在处理过程中，一个事件可能引发其它事件，事件监听和处理(The Event Listening and Processing)一章来获得更多细节。</para></sect2><sect2><title>响应阶段</title>
<para>在所有的事件都被处理后，ZK将这些组件组成一个规则的HTML页面并将这个页面送到浏览器。</para>
<para>为了发送一个组件，<code>redraw</code>会被调用。在这个方法中，一个组件的实现(implementation)并不会更改其它组件的内容。</para></sect2></sect1><sect1><title>更新页面的活动周期</title>
<para>ZK AU引擎处理从客户端来的ZK请求需要三个阶段：请求处理阶段，事件处理阶段及响应阶段。</para>
<para>ZK AU引擎将ZK请求传递到队列(每个桌面一个队列)。因此，来自相同桌面的请求可以被顺序处理，而来自不同桌面的请求可以被并行处理。</para><sect2><title>请求处理阶段</title>
<para>依赖于请求，ZK AU引擎可能会更新被影响组件的内容，这样它们的内容就和在客户端展示的一样。</para>
<para>然后，它将相应的事件提交到队列。</para></sect2><sect2><title>事件处理阶段</title>
<para>这个阶段和组件创建阶段中的事件处理阶段是类似的。它在独立的线程中依次处理事件。</para></sect2><sect2><title>响应阶段</title>
<para>在所有的事件都被处理后，ZK送出受影响的组件，产生相应的ZK响应，并将这些请求送回到客户端。然后，客户端引擎会基于这些响应更新浏览器端的DOM树。</para>
<para>是否重设一个组件的整个视觉表现或更新浏览器端的一个属性完全取决于组件的实现。平衡互动性与简易性，这是开发人员的工作。</para></sect2></sect1><sect1><title>模型(The Molds)</title><para>一个组件可以有不同的外观，甚至在同一页面内，这个概念被称为模型(aka., template)。通过使用<code>setMold</code>方法，开发人员可以动态的改变组件界面的模型。所有的组件都支持的模型(mold)为<code>default</code>，即默认值。一些组件可以支持两种或更多的模型。例如，<code>tabbox</code>同时支持<code>default</code>和<code>accordion</code>模型。</para>
<programlisting>&lt;tabbox&gt;&lt;!-- if not specified, the default mold is assumed. --&gt;&#13;   &lt;tabs&gt;&#13;      &lt;tab label="Default"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels<inlinegraphic align="right"  fileref="img/4-3.png"/>&gt;&#13;      &lt;tabpanel&gt;&#13;      &lt;tabbox mold="accordion"&gt;&#13;         &lt;tabs&gt;&#13;            &lt;tab label="First Accordion"/&gt;&#13;            &lt;tab label="Second Accordion"/&gt;&#13;         &lt;/tabs&gt;&#13;         &lt;tabpanels&gt;&#13;            &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;&#13;            &lt;tabpanel&gt;The second panel.&lt;/tabpanel&gt;&#13;         &lt;/tabpanels&gt;&#13;      &lt;/tabbox&gt;&#13;      &lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect1><sect1><title>组件垃圾回收</title>
<para>不同于其它基于组件的图形用户界面(GUI)， 组件类并没有destroy 或close方法。就像W3C的DOM，当一个组件从页面被卸载时它就从浏览器被移除。它的表现就像附着在页面上一样。</para>
<para>更确切地说，一旦一个组件被卸载，如果应用程序不再涉及到它，它就不再受ZK的管理。它所占用的内存会被Java虚拟机的垃圾回收机制(JVM's garbage collector)所释放。</para></sect1></chapter><chapter><title>5. 事件监听及处理</title><para>本章描述事件是如何被处理的。</para><sect1><title>通过标记语言添加事件监听器</title>
<para>添加一个事件监听器最简单的方法就是在一个ZUML页面内声明一个属性。用来监听的属性的值是可以被BeanShell解释的任何Java代码。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;   &lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>通过程序添加或移除事件监听器</title>
<para>有两种方法通过程序添加或移除事件监听器。</para><sect2><title>声明一个成员</title>
<para>当用你自己的类重定义(overriding)一个组件后，你可以声明一个成员函数成为事件监听器。</para>
<para>在一个ZUML页面中，你可以使用<code>use</code>属性来指定你想使用的类，即用它去替换默认类。如下所示，它使用了MyClass来替换默认的<code>org.zkoss.zul.Window</code>
<footnote>
<para>默认的类定义在 in zul.jar中的lang.xml .</para>
</footnote>。</para>
<programlisting>&lt;window use="MyClass"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>然后你淂实现MyWindow.java同过继承默认的类，就像下面一样:</para>
<programlisting>public class MyWindow extends org.zkoss.zul.Window {&#13;   public void onOK() { //add an event listener&#13;      ...//handles the onOK event (sent when ENTER is pressed)&#13;   }&#13;}&#13;</programlisting>
<para>如果你想获得关于事件的更多信息，你可以按如下方式声明：</para>
<programlisting>public void onOK(org.zkoss.zk.ui.event.KeyEvent event) {
...
}&#13;</programlisting>
<para>不同的事件或许与不同的事件对象相关联。参考附录C(Append C)来获取更多的细节。</para></sect2><sect2><title>动态地添加与移除事件监听器</title>
<para>开发人员可以使用<code>org.zkoss.zk.ui.Component</code>接口中的<code>addEventListene</code>和<code>removeEventListener</code>方法来动态地添加或移除事件监听器。如下所示，动态添加的事件监听器必须实现<code>org.zkoss.zk.ui.event.EventListener</code>接口。</para>
<programlisting>void init(Component comp) {&#13;   ...&#13;   comp.addEventListener("onClick", new MyListener());&#13;   ...&#13;}&#13;class MyListener implements org.zkoss.zk.ui.event.EventListener {&#13;   public void onEvent(Event event) throws UiException {&#13;      ...//processing the event&#13;   }&#13;}&#13;</programlisting></sect2><sect2><title>延期事件监听器</title>
<para>默认情况下，当客户端的事件被触发时就会被送到服务器。但是，许多事件仅用于维持服务器端的现状，而不是向客户端提供视觉响应(visual response)。换句话说，这些监听器的事件并不需要马上被送出。相反，它们应该仅被提交一次，以降低客户端和服务器端的来往，以提高服务器的性能。为求描述方便，我们称它们为延期事件监听器(Deferrable Event Listeners)。</para>
<para>为了使一个事件监听延期，必须实现<code>org.zkoss.zk.ui.event.Deferrable</code>接口(和 EventListener)并且使用<code>isDeferrable</code>方法返回true，就像下面一样。</para>
<programlisting>public class DeferrableListener implements EventListener, Deferrable {&#13;
   private boolean _modified;
   public void onEvent(Event event) {
      _modified = true;
   }
   public boolean isDeferrable() {
      return true;
   }
}</programlisting>
<para>当客户端的一个事件(例如，选择一个列表项目(list item))被触发时，如果没有为其注册事件监听器或仅有延期(deferrable)的监听器被注册，ZK不会将事件送出。</para>
<para>一方面，如果至少有一个非延期(non-deferrable)监听器，事件会被马上送到服务器端，和所有的队列事件(queued events)一起。没有事件会丢失，到达顺序是保存好的。</para>
<para>[提示]:当有非延期监听器为用户提供视觉响应，可以使用使用延期的(deferrable)事件监听器维持(maintaining)服务器状态。</para></sect2><sect2><title>为页面动态地添加和移除事件监听器</title>
<para>开发人员可以为页面(<code>org.zkoss.zk.ui.Page</code>)动态地添加和移除事件监听器。一旦被添加，所有被指定名字的事件会被送到指定页面的任何组件，这些页面将会被送到监听器。 </para>
<para>所有的页面级(page-level)事件监听器都是非即时。换言之，<code>isArap</code>方法被忽略了。</para>
<para>一个典型的例子是使用页面级事件监听器来维护修改标志(modification flag)，如下：</para>
<programlisting>public class ModificationListener implements EventListener, Deferrable {&#13;   private final Window _owner;&#13;   private final Page _page;&#13;   private boolean _modified;&#13;&#13;   public ModificationListener(Window owner) {&#13;      //Note: we have to remember the page because unregister might&#13;      //be called after the owner is detached&#13;      _owner = owner;&#13;      _page = owner.getPage();&#13;      _page.addEventListener("onChange", this);&#13;      _page.addEventListener("onSelect", this);&#13;      _page.addEventListener("onCheck", this);&#13;   }&#13;   /** Called to unregister the event listener.&#13;    */&#13;   public void unregister() {&#13;      _page.removeEventListener("onChange", this);&#13;      _page.removeEventListener("onSelect", this);&#13;      _page.removeEventListener("onCheck", this);&#13;   }&#13;   /** Returns whether the modified flag is set.&#13;    */&#13;   public boolean isModified() {&#13;      return _modified;&#13;   }&#13;   //-- EventListener --//&#13;   public void onEvent(Event event) throws UiException {&#13;      _modified = true;&#13;   }&#13;   //-- Deferrable --//&#13;   public boolean isDeferrable() {&#13;
      return true;
   }
}&#13;</programlisting>
<para>[注]: 在事例中是否实现<code>Deferrable</code>接口是可选的，因为页面的事件监听器总是假定为延期的，与是否实现<code>Deferrable</code>接口无关。</para></sect2><sect2><title>调用顺序</title>
<para>调用事件监听器的顺序如下。假定接收的是<code>onClick</code>事件。</para>
<orderedlist>
<listitem>
<para>如果监听器实现了<code>org.zkoss.zk.ui.event.Express</code>接口，依次为添加到目标组件(targeting component)的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
<listitem>
<para>调用目标组件的<code>onClick</code>属性指定的脚本语言。</para>
</listitem>
<listitem>
<para>如果监听器没有实现<code>org.zkoss.zk.ui.event.Express</code>接口，依次为添加到目标组件的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
<listitem>
<para>调用目标组件的<code>onClick</code>成员方法。</para>
</listitem>
<listitem>
<para>依次为添加到目标组件所属页面的的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
</orderedlist>
<para>
<code>org.zkoss.zk.ui.event.Express</code>接口是一个装饰器(decorative interface)，用来改变调用事件监听器的优先级。注意，如果事件监听器被添加到页面，而不是组件，这个接口是没有意义的。</para></sect2><sect2><title>中止调用序列</title>
<para>你可以通过调用<code>org.zkoss.zk.ui.event.Event</code>类中的<code>stopPropagation</code>方法来中止调用序列。一旦事件监听器调用了这个方法，之后所有的事件监听器将会被忽略。</para></sect2></sect1><sect1><title>事件监听器提交和发送事件</title>
<para>除了接收事件，一个应用程序可以在事件监听器间通信通过向他们发送和提交事件。</para><sect2><title>提交事件</title>
<para>通过使用<code>org.zkoss.zk.ui.event.Events</code>类中的<code>postEvent</code>方法，一个事件监听器可以把事件提提交到事件队列的末尾。将事件放到队列中后立即返回。当这个事件之前的所有事件都被处理完毕后，该事件就会被处理。</para></sect2><sect2><title>发送事件</title>
<para>通过使用<code>org.zkoss.zk.ui.event.Events</code>类中的<code>sendEvent</code>方法，一个事件监听器可以使ZK马上处理指定的事件。当指定事件的事件监听器都被处理完毕后才返回。事件是在相同的线程内被处理的。</para></sect2></sect1><sect1><title>线程(Thread)模型</title>
<para>对于每个桌面，事件总是被顺序处理的，所以线程模型是很简单的。就像开发桌面应用程序一样，你不需要担心racing和多线程(multi-threading)。所有你需要做的就是注册一个事件监听器且事件被调用时处理它。</para>
<para>[提示]:当一个ZUML页面在servlet线程中被赋值时，每一个事件监听器都在一个被称为事件处理线程的独立线程中运行。</para>
<para>[提示]:事件处理线程的使用可以被禁止，这样所有的线程都可以在Servlet线程中被处理。这样有更好一点的表现并且减少集成的问题。但是，你不能中止执行。参考高级功能(Advanced Features)一章中关于处理事件的Servlet线程(Servlet Thread to Process Events)的部分。</para><sect2><title>挂起及恢复</title>
<para>为了高级的应用，你或许必须挂起一个执行直到一些条件被满足，<code>org.zkoss.zk.ui.Executions</code>类中的<code>wait</code>，<code>notify</code>和<code>notifyAll</code>方法都是为这样的目的而设计的。</para>
<para>当一个事件监听器想挂起自己，它可以调用<code>wait</code>。如果申请的具体条件得到满足，另一个线程可以通过<code>notify</code>和<code>notifyAll</code>方法唤醒它。对话框是使用这种机制的典型例子。</para>
<programlisting>public void doModal() throws InterruptedException {&#13;...
   Executions.wait(_mutex); //suspend this thread, an event processing thread
}&#13;public void endModal() {&#13;...&#13;   Executions.notify(_mutex); //resume the suspended event processing thread&#13;}&#13;</programlisting>
<para>它们的使用类似于<code>java.lang.Object</code>中的<code>wait</code>，<code>notify</code>和<code>notifyAll</code>方法。但是，你不能使用<code>java.lang.Object</code>中的方法来挂起和恢复事件监听器。否则，关联到这个桌面的所有的事件处理都会停滞。</para>
<para>请注意，不同于Java的<code>Object</code>类的<code>wait</code>和<code>notify</code>方法，是否使用同步的<code>synchronized</code> block来包<code>Executions</code>的<code>wait</code>和<code>notify</code>是可选的。在上述情况下中，我们并不需要这样做，因为没有可能的racing问题。但是，如果存在这样的racing问题，你可以使用<code>synchronized</code> block，就像在Java <code>Object</code>的<code>wait</code>和<code>notify</code>中使用那样。</para>
<programlisting>//Thread 1&#13;public void request() {&#13;
   ...
   synchronized (mutex) {
      ...//start another thread
      Executions.wait(mutex); //wait for its completion
   }
}

//Thread 2
public void process() {
   ... //process it asynchronously
   synchronized (mutex) {
      Executions.notify(mutex);
   }
}</programlisting></sect2><sect2><title>长操作(Long Operations)</title><para>对于同一个桌面而言，事件是被顺序处理的。换言之，一个事件的处理程序可以阻塞所有的后继处理程序。如果一个事件处理程序要花费大量的时间，阻塞用户请求的时间可能是不可接受的。就像桌面应用程序那样，你需要为这种长操作(Long Operations)创建一个工作线程以减少阻塞时间。</para>
<para>限于HTTP协议，你必须遵守以下规则：</para>
<orderedlist>
<listitem>
<para>创建工作线程后，使用<code>org.zkoss.zk.ui.Executions</code>类的<code>wait</code>方法来挂起事件处理程序本身。</para>
</listitem>
<listitem>
<para>由于工作线程不是一个事件监听器，所以它不能读取任何组件，除非这个组件不属于任何桌面。因此在开始工作线程之前你可能需要手动添加(pass)一些必要信息。</para>
</listitem>
<listitem>
<para>然后，若有必要的话，工作线程可以取出信息，并且创建组件。只是不引用属于任何桌面的任何组件。</para>
</listitem>
<listitem>
<para>工作线程完成之后，在工作线程中使用<code>org.zkoss.zk.ui.Executions</code>类中的<code>notify(Desktop desktop，Object flag)</code>或 <code>notifyAll(Desktop desktop，Object flag)</code>方法来恢复事件处理程序。</para>
</listitem>
<listitem>
<para>直到另一个事件从客户端被发送过来，恢复的事件处理程序才会执行。为了强制发送一个组件，你可以使用timer组件(<code>org.zkoss.zul.Timer</code>)触发事件片刻之后或定期的。这个timer 的事件监听器可以不做任何事情或更改进展状况。</para>
</listitem>
</orderedlist><sect3><title>事例：一个异步产生标签的工作线程</title>
<para>假定我们以异步的方式创建标签。当然，用多线程来做这么小的事是没有意义的，但是我们可以用更复杂的(sophisticated)任务来代替这个。</para>
<programlisting>//WorkingThread&#13;package test;&#13;public class WorkingThread extends Thread {
   private static int _cnt;

   private Desktop _desktop;
   private Label _label;
   private final Object _mutex = new Integer(0);

   /** Called by thread.zul to create a label asynchronously.
    * To create a label, it start a thread, and wait for its completion.
    */
   public static final Label asyncCreate(Desktop desktop)
   throws InterruptedException {
      final WorkingThread worker = new WorkingThread(desktop);
      synchronized (worker._mutex) { //to avoid racing
         worker.start();
         Executions.wait(worker._mutex);
         return worker._label;
      }
   }
   public WorkingThread(Desktop desktop) {
      _desktop = desktop;
   }
   public void run() {
      _label = new Label("Execute "+ ++_cnt);
      synchronized (_mutex) { //to avoid racing
         Executions.notify(_desktop, _mutex);
      }
   }
}&#13;</programlisting>
<para>然后，在一个事件监听器中，我们使用ZUML页面来调用这个工作线程，如在<code>onClick</code>事件中。</para>
<programlisting>&lt;window id="main" title="Working Thread"&gt;
   &lt;button label="Start Working Thread"&gt;
   &lt;attribute name="onClick"&gt;
   timer.start();
   Label label = test.WorkingThread.asyncCreate(desktop);
   main.appendChild(label);
   timer.stop()
      &lt;/attribute&gt;
   &lt;/button&gt;
   &lt;timer id="timer" running="false" delay="1000" repeats="true"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>注意到我们必须使用timer来真正地恢复被挂起的事件监听器(<code>onClick</code>)。这看起来是多余的，但是由于HTTP的限制：为了保持Web页面在浏览器端的活跃，当事件处理程序被挂起时我们必须返回响应。然后，工作线程完成了工作并唤醒了事件监听器，HTTP请求已经不在了。因此，我们需要一种方式来”捎带(piggyback)”这个结果，而这就使timer为什么会被使用的原因。</para>
<para>更确切地说，当工作线程唤醒一个事件监听器时，ZK只是把它加到一个等待列表。当另一个HTTP请 求到达时，监听器才真正恢复(如上面例子中的<code>onTimer</code>事件)。</para>
<para>在这个简单的事例中，我们并没有为<code>onTimer</code>事件作任何事情。对于一个复杂的应用程序，你可以用它来返回处理状态。</para></sect3><sect3><title>选择 1: Timer(没有挂起/恢复)</title>
<para>无需挂起和恢复来实现一长操作(long operation)是由可能的。这在同步代码(synchronization codes)对于调试来说太复杂的情况下是很有用的。</para>
<para>注意是很简单的。工作线程将结果保存在一个临时空间，然后使用<code>onTimer</code>事件将结果弹到(pops)桌面。</para>
<programlisting>//WorkingThread2&#13;package test;&#13;public class WorkingThread2 extends Thread {
   private static int _cnt;

   private final Desktop _desktop;
   private final List _result;

   public WorkingThread2(Desktop desktop, List result) {
      _desktop = desktop;
      _result = result;
   }   public void run() {
      _result.add(new Label("Execute "+ ++_cnt));
   }
}&#13;</programlisting>
<para>然后，在<code>onTimer</code>事件监听器上附加标签。</para>
<programlisting>&lt;window id="main" title="Working Thread2"&gt;
   &lt;zscript&gt;
   int numPending = 0;
   List result = Collections.synchronizedList(new LinkedList());
   &lt;/zscript&gt;
   &lt;button label="Start Working Thread"&gt;
      &lt;attribute name="onClick"&gt;
   ++numPending;   timer.start;
  new test.WorkingThread2(desktop, result).start();
      &lt;/attribute&gt;
   &lt;/button&gt;
   &lt;timer id="timer" running="false" delay="1000" repeats="true"&gt;
      &lt;attribute name="onTimer"&gt;
   while (!result.isEmpty()) {
      main.appendChild(result.remove(0));
      --numPending;
   }
   if (numPending == 0) timer.stop();
      &lt;/attribute&gt;
   &lt;/timer&gt;
&lt;/window&gt;</programlisting></sect3><sect3><title>选择 2：捎带(piggyback)(没有挂起/恢复，没有Timer)</title>
<para>当用户，例如，点击一个按钮或输入一些东西时，你可以将结果捎带(piggyback)到客户端，而不必循环地检查它们。</para>
<para>为了完成捎带(piggyback)，你需要为一个根组件注册一个<code>onPiggyback</code>事件监听器。然后每次ZK更新引擎(ZK Update Engine)处理事件时，这个监听器将会被调用。例如，你可以按如下的方式重写代码。</para>
<programlisting>&lt;window id="main" title="Working Thread3" onPiggyback="checkResult()"&gt;&#13;   &lt;zscript&gt;&#13;   List result = Collections.synchronizedList(new LinkedList());&#13;&#13;   void checkResult() {&#13;      while (!result.isEmpty())&#13;         main.appendChild(result.remove(0));&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Start Working Thread"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;   timer.start();&#13;   new test.WorkingThread2(desktop, result).start();&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>捎带(piggyback)方式的优点是客户端与服务器端没有额外的往来。但是，如果用户没有任何活动(如点击或打字)的话是无法看到更新的。这种方式是否合适取决于应用程序的要求。</para>
<para>[注]: 一个延期的事件(deferrable)不会马上被送到客户端，所以，只有一个非延期的事件被触发后<code>onPiggyback</code>事件才会被触发。请参考关于延期事件监听器(Deferrable Event Listeners)的部分获得详细信息。</para></sect3></sect2></sect1><sect1><title>初始与清理事件处理线程</title><sect2><title>处理每个事件前的初始化</title>
<para>一个事件监听器是在一个事件处理线程中执行的。有时，你必须在处理所有事件前初始该线程。</para>
<para>一个典型的例子是初始化认证所使用的线程。一些J2EE或Web容器将认证信息存储在局部存储器(local storage)线程中。这样，可以在需要的时候自动进行重复验证。</para>
<para>为了初始化事件处理线，必须在<code>WEBINF/zk.xml</code>文件<footnote>
<para>the Developer's Reference 的附录(Appendix B) 进行了详细描述。</para>
</footnote>的<code>listener</code>元素中注册一个是实现了<code>org.zkoss.zk.ui.event.EventThreadInit</code>接口的类。</para>
<para>一旦注册完毕，一个指定类的实例就会在主线程中被创建。然后，在处理其他事情之前，该实例的<code>init</code>方法就会在事件处理线程的上下文中被调用。</para>
<para>请注意构造程序(constructor)和<code>init</code>方法是在不同的线程中被调用的，因此开发人员可以从一个线程取得独立线程数据并传送给另外一个线程。</para>
<para>这里有一个 JBoss<footnote>
<para>http://www.jboss.org</para>
</footnote>的认证机制。在这个例子中，我们在构造程序中获取存储在Servlet线程中的信息。然后当<code>init</code>方法被调用时初始事件处理线程。</para>
<programlisting>import java.security.Principal;&#13;import org.jboss.security.SecurityAssociation;&#13;import org.zkoss.zk.ui.Component;&#13;import org.zkoss.zk.ui.event.Event;&#13;import org.zkoss.zk.ui.event.EventThreadInit;&#13;&#13;public class JBossEventThreadInit implements EventThreadInit {&#13;   private final Principal _principal;&#13;   private final Object _credential;&#13;   /** Retrieve info at the constructor, which runs at the servlet thread. */&#13;   public JBossEventThreadInit() {&#13;      _principal = SecurityAssociation.getPrincipal();&#13;      _credential = SecurityAssociation.getCredential();&#13;   }&#13;   //-- EventThreadInit --//&#13;   /** Initial the event processing thread at this method. */&#13;   public void init(Component comp, Event evt) {&#13;      SecurityAssociation.setPrincipal(_principal);&#13;      SecurityAssociation.setCredential(_credential);&#13;   }&#13;}&#13;</programlisting>
<para>然后，在<code>WEB-INF/zk.xml</code>文件中，你需要完成如下的配置：</para>
<programlisting>&lt;zk&gt;&#13;   &lt;listener&gt;&#13;      &lt;listener-class&gt;JBossEventThreadInit&lt;/listener-class&gt;&#13;   &lt;/listener&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect2><sect2><title>处理完每个事件后清理</title>
<para>类似的，在处理完每个事件后你或许必须清理一个事件处理线程。</para>
<para>一个典型的例子是关闭事务处理，如果它没有被适时地关闭。</para>
<para>为了清理一个事件处理线程，你必须在<code>WEBINF/zk.xml</code>文件的<code>listener</code>元素中注册一个实现<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>接口的监听类。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;listener&gt;&#13;      &lt;listener-class&gt;my.MyEventThreadCleanup&lt;/listener-class&gt;&#13;   &lt;listener&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect2></sect1></chapter>

<chapter>
<title>6. ZK用户界面标记语言</title>
<para>ZK 用户界面标记语言(ZUML)是基于XML的。每一个XML元素描述了要创建的组件。一个XML属性描述了被创建组件的初始值。一个XML处理指令(processing instruction)如何处理整个页面，如页面的标题。</para>
<para>不同的组件集通过XML命名空间来区分。例如，XUL的命名空间为<ulink url="http://www.potix.com/2005/zul">
<code>http://www.zkoss.org/2005/zul</code>
</ulink>
<footnote>
<para>被称为 <ulink url="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul</ulink>。但是，添加了许多非XUL特性，所以最好使用独立的命名空间。 </para>
</footnote>，而XHTML的命名空间为<ulink url="http://www.w3.org/1999/xhtml">
<code>http://www.w3.org/1999/xhtml</code>
</ulink>。</para><sect1><title>XML</title>
<para>这一章节提供了和ZK一起工作的XML的最基本概念，如果内很熟悉XML，可以跳过这一章节。如果你想学习更多，在网络上有很多资源，如 http://www.w3schools.com/xml/xml_whatis.asp 和
<ulink url="http://www.xml.com/pub/a/98/10/guide0.html">http://www.xml.com/pub/a/98/10/guide0.html</ulink>。</para>
<para>XML是一种标记语言，就像HTML，但是有更严格和简洁(cleaner)的语法，有几点需要特别注意。</para><sect2><title>元素必须格式良好</title>
<para>首先，每个元素必须关闭。有两种元素来关闭一元素，就像下面描述的一样，它们是等价的。</para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>通过一个结束标签关闭:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt;&lt;<code>window</code>/&gt;</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>不通过一个结束标签关闭:</para>
</entry>
<entry>
<para>&lt;<code>window</code>/&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>其次, 元素要被正确的嵌套(nested)。</para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>正确:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt; &lt;<code>groupbox</code>&gt;    <code>Hello</code> <code>World</code>!    &lt;/<code>groupbox</code>&gt;&lt;/<code>window</code>&gt;</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>错误:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt; &lt;<code>groupbox</code>&gt;    <code>Hello</code> <code>World</code>! &lt;/<code>window</code>&gt;&lt;/<code>groupbox</code>&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>特殊字符必须被替换</title>
<para>XML使用&lt;<code>element-name</code>&gt;来表示一个元素，所以你必须替换特殊的字符。</para>
<para>例如，你必须使用<code>&amp;lt;</code>表示<code>&lt;</code>。 </para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>特殊字符</para>
</entry>
<entry>
<para>替换字符</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>&lt;</para>
</entry>
<entry>
<para>
<code>&amp;lt;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>&gt;</code>
</para>
</entry>
<entry>
<para>
<code>&amp;gt;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>&amp;</code>
</para>
</entry>
<entry>
<para>
<code>&amp;amp;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>"</code>
</para>
</entry>
<entry>
<para>
<code>&amp;quot;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>'</code>
</para>
</entry>
<entry>
<para>
<code>&amp;apos;</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>另外，你可以使用<code>CDATA</code>来使XML解析器不要解释其内的文本，如下：</para>
<programlisting>&lt;zscript&gt;&#13;&lt;![CDATA[&#13;void myfunc(int a, int b) {&#13;   if (a &lt; 0 &amp;&amp; b &gt; 0) {&#13;      //do something&#13;   }&#13;]]&gt;&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>有意思的是反斜杠(\)不是特殊字符，所以你不需要担心。</para></sect2><sect2><title>属性值必须被指定且用引号包围</title>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>正确:</para>
</entry>
<entry>
<para>
<code>width="100%"</code>
</para>
<para>
<code>checked="true"</code>
</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>错误:</para>
</entry>
<entry>
<para>
<code>width=100%</code>
</para>
<para>
<code>checked</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>注释</title>
<para>注释通常被用于留下一个说明或暂时便基出一部分XML源码(leave a note or to temporarily edit out a portion of XML code)。</para>
<programlisting>&lt;window&gt;&#13;&lt;!-- this is a comment and ignored by ZK --&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>字符编码</title>
<para>尽管是可选定的，但在你的XML中指定编码是个好主意，这样XML解析器可以正确的解释文本。</para>
<para>注意：它必须被放置在文件的第一行。</para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;</programlisting>
<para>除了指定正确的编码，同时也要确保你的XML编辑器支持这种编码。</para></sect2><sect2><title>命名空间</title>
<para>命名空间是区分XML文档中用到名字的一个简单易懂的办法。ZK使用XML命名空间来区分组件名称。这样，只要不在同一个命名空间，两个组件有相同的名字是可以的。ZK使用XML命名空间来表现一个组件集。这样，开发人员可以在同一个页面内混合使用两个或多个组件集，如下所示 </para>
<programlisting>&lt;html xmlns:="http://www.w3.org/1999/xhtml"&#13; xmlns:x="http://www.zkoss.org/2005/zul"&#13; xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;table&gt;&#13;   &lt;tr&gt;&#13;      &lt;td&gt;&lt;x:textbox/&gt;&lt;/td&gt;&#13;      &lt;td&gt;&lt;x:button label="Now" zk:onClick="addItem()"/&gt;&lt;/td&gt;&#13;   &lt;/tr&gt;&#13;   &lt;/table&gt;&#13;&#13;   &lt;zk:zscript&gt;&#13;   void addItem() {&#13;   }&#13;   &lt;/zk:zscript&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>在这里</para>
<orderedlist>
<listitem>
<para>
<code>xmlns:x="</code>
<code>http://www.zkoss.org/2005/zul</code>

<code>"</code> 指定一个称为http://www.zkoss.org/2005/zul的命名空间，并且使用x来呈现这个命名空间。</para>
</listitem>
<listitem>
<para>
<code>xmlns:="http://www.w3.org/1999/xhtml"</code> 指定一个称为
<code>http://www.w3.org/1999/xhtml</code>
的命名空间，且使用它作为默认的命名空间。</para>
</listitem>
<listitem>
<para>&lt;<code>html</code>&gt; 从默认的命名空间中指定一个称为 html 的元素，在这个例子中也就是 <code>http://www.w3.org/1999/xhtml</code> 。</para>
</listitem>
<listitem>
<para>
<code>&lt;</code>
<code>x:textbox/&gt;</code> 从<code>http://www.zkoss.org/2005/zul</code>命名空间中指定一个称为textbox 的元素。</para>
</listitem>
</orderedlist><sect3><title>使用Schema 自动完成</title>
<para>许多IDE，如Ecipse，支持自动完成，如果XML schema被按如下方式指定。</para>
<programlisting>&lt;window xmlns="http://www.zkoss.org/2005/zul"&#13;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&#13;xsi:schemaLocation="http://www.zkoss.org/2005/zul http://www.zkoss.org/2005/zul/zul.xsd"&gt;&#13;</programlisting>
<para>除了可以从<ulink url="http://www.zkoss.org/2005/zul/zul.xsd">http://www.zkoss.org/2005/zul/zul.xsd</ulink>
下载到，可以在ZK的binary 发行版中的<code>dist/xsd</code>目录找到<code>zul.xsd</code> 。</para></sect3></sect2></sect1><sect1><title>条件式流程</title>
<para>创建一个元素的流程可以条件式的。通过只指定if或unless属性，或都指定，开发人员可以控制是否创建相关的元素。</para>
<para>在下面的例子中，如果a为1，且b不为2 window 组件就会被创建。如果一个元素被忽略，那么它所有的组件都会忽略。</para>
<programlisting>&lt;window if="${a==1}" unless="${b==2}"&gt;&#13;   ...&#13;&lt;/window&gt;&#13;</programlisting>
<para>下面的例子控制什么时候解释Java代码。</para>
<programlisting>&lt;textbox id="contributor"/&gt;&#13;&lt;zscript if="${param.contributor}"&gt;&#13;   contributor.label = Executions.getCurrent().getParameter("contributor");&#13;&lt;/zscript&gt;&#13;</programlisting></sect1><sect1><title>反复式流程</title>
<para>创建一个元素的流程可以是反复式的。通过为<code>forEach</code>属性一个对象集合，开发人员可以控制相关元素要被创建多少次。为了描述方便，如果一个元素被<code>forEach</code>属性赋值就称其为迭代元素(iterative element)。</para>
<para>在下面的例子中，列表项目被创建了三次。注意必须使用EL表达式来指定集合。</para>
<programlisting>&lt;listbox&gt;&#13;  &lt;zscript&gt;&#13;  grades = new String[] {"Best", "Better", "Good"};&#13;  &lt;/zscript&gt;&#13;  &lt;listitem label="${each}" forEach="${grades}"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>迭代依赖于<code>forEach</code>属性指定值的类型。</para>
<orderedlist>
<listitem>
<para>如果是<code>java.util.Collection</code>，就会迭代集合(collection)的每个元素。</para>
</listitem>
<listitem>
<para>如果是<code>java.util.Map</code>，就会迭代map中的每个Map.Entry。</para>
</listitem>
<listitem>
<para>如果是<code>java.util.Iterator</code>，就会迭代迭代器(iterator)中的每个元素。</para>
</listitem>
<listitem>
<para>如果是<code>java.util.Enumeration</code>，就会迭代enumeration中的每个元素。</para>
</listitem>
<listitem>
<para>如果是<code>Object[]，int[]，short[]，byte[]，char[]，float[]或double[]</code>被指定了，就会迭代数组(array)中的每个元素。</para>
</listitem>
<listitem>
<para>如果是<code>null</code>，什么也不会产生(被忽略)。</para>
</listitem>
<listitem>
<para>如果被指定的不是以上类型，相关元素仅被赋值一次，就好像一个集合只指定了一个单 独的项目。</para>
</listitem>
</orderedlist>
<programlisting>&lt;listbox&gt;&#13;  &lt;listitem label="${each}" forEach="grades"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting><sect2><title>
<code>each</code>变量</title>
<para>在迭代中，一个变量被称为<code>each</code>，通过指定集合的项目被创建并且赋值。在上面的例子中，首次迭代中，<code>each</code>被赋值为"Best"，然后是"Better"，最后是"Good"。</para>
<para>注意<code>each</code>变量在EL表达式和<code>zscript</code>中都是可访问的。ZK将会保留以前定义的每个变量，并在迭代完每个元素后将其恢复。</para></sect2><sect2><title>
<code>forEachStatus</code>变量</title>
<para>
<code>forEachStatus</code>变量是<code>org.zkoss.ui.util.ForEachStatus</code>的一个实例，用来保存当前迭代的信息。也主要用于取得封闭元素的项目，这些元素已通过forEach属性赋值。</para>
<para>在下面的例子中，我们使用嵌套迭代元素(nested iterative elements)来产生两个listbox。</para>
<programlisting>&lt;hbox&gt;&#13;  &lt;zscript&gt;&#13;classes = new String[] {"College", "Graduate"};&#13;grades = new Object[] {&#13;  new String[] {"Best", "Better"}, new String[] {"A++", "A+", "A"}&#13;};&#13;  &lt;/zscript&gt;&#13;  &lt;listbox width="200px" forEach="${classes}"&gt;&#13;    &lt;listhead&gt;&#13;      &lt;listheader label="${each}"/&gt;&#13;    &lt;/listhead&gt;&#13;    &lt;listitem label="${forEachStatus.previous.each}: ${each}"&#13;    forEach="${grades[forEachStatus.index]}"/&gt;&#13;  &lt;/listbox&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>
<graphic fileref="img/6-3-2.png" align="center"/>注意<code>forEachStatus</code>变量在EL表达式和<code>zscript</code>中都是可访问的。</para></sect2><sect2><title>如何在事件监听器中使用 <code>each</code>和<code>forEachStatus</code> 变量</title>
<para>在事件监听器中使用<code>forEach</code>和<code>forEachStatus</code>变量有点棘手，因为它们仅在组件创建阶段(Component Creation Phase)<footnote><para>参考元件活动周期一章。</para></footnote>是可用的(available)。因此，下面的例子是不正确的。当onClick监听器被调用时，<code>each</code>变量就不可用了。</para>
<programlisting>&lt;window title="Countries" border="normal" width="100%"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   String[] countries = {&#13;     "China", "France", "Germany", "United Kindom", "United States"};&#13;   ]]&gt;&lt;/zscript&gt;&#13;&#13;   &lt;hbox&gt;&#13;      &lt;button label="${each}" forEach="${countries}"&#13;         onClick="alert(each)"/&gt; &lt;!-- incorrect!! --&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>注意按钮标签的赋值方式是错误的，因为它们在同一阶段-----组件创建阶段(Component Creation Phase)。</para>
<para>同时也要注意不能在事件监听器中使用EL表达式。例如，下列代码会执行失败，因为<code>onClick</code>的监听器并不是Java代码(也就是说，EL表达式在<code>zscript</code>中是被忽略的)。</para>
<programlisting>&lt;button label="${each}" forEach="${countries}"&#13;     onClick="alert(${each})"/&gt; &lt;!-- incorrect!! --&gt;&#13;</programlisting><sect3><title>一个解决方法：定制属性 </title>
<para>解决方法是我们必须在某处存储<code>each</code> (和<code>forEachStatus</code>)的内容，这样当监听器执行时其内容仍是可用的。你可以将其内容存储在任何地方，但是有一个简单的方法来处理，如下：</para>
<programlisting>&lt;window title="Countries" border="normal" width="100%"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   String[] countries = {&#13;      "China", "France", "Germany", "United Kindom", "United States"};&#13;   ]]&gt;&lt;/zscript&gt;&#13;&#13;   &lt;hbox&gt;&#13;      &lt;button label="${each}" forEach="${countries}"&#13;      onClick="alert(self.getAttribute(&amp;quot;country&amp;quot;))"&gt;&#13;         &lt;custom-attributes country="${each}"/&gt;&#13;      &lt;/button&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>就像按钮标签(label)，定制属性(custom attributes)的属性在组件创建阶段 (Component Creation Phase)被赋值，所以在这里你可以使用each。然后，它被存储在一个定制属性，这个定制属性会在组间存在的期间一直有效(直到组件被移除)。</para></sect3></sect2></sect1><sect1><title>随机存取(Load on Demand)</title>
<para>默认情况下，当加载页面时，ZK基于在ZUML页面内定义的内容依次创建组件。但是，我们可以推迟部分组件的创建，直到它们可见。这个特性即为随机存取(load-on-demand)。如果在初始时有许多非可见组件，随机存取可以提高性能。</para><sect2><title>使用<code>fulfill</code>属性的随机存取</title>
<para>延迟创建子组件的最简单方式是使用<code>fulfill</code>属性。例如，在下面的代码片断中，<code>comboitem</code>组件将不会被创建，<code>comboitem</code>组件接收了<code>onOpen</code>事件，此事件可使<code>comboitem</code>变为可见。</para>
<programlisting>&lt;combobox fulfill="onOpen"&gt;&#13;   &lt;comboitem label="First Option"/&gt;&#13;&lt;/combobox&gt;&#13;</programlisting>
<para>换句话说，如果一个ZUML元素使用了 <code>fulfill</code> 属性，直到 <code>fulfill</code> 指定的事件发生时这个组件的子组件才会被处理。</para>
<para>如果创建子组件创建事件的目标是另一个组件，你可以按如下描述指定目标组件的标识。</para>
<programlisting>&lt;button id="btn" label="show" onClick="content.visible = true"/&gt;&#13;&lt;div id="content" fulfill="btn.onClick"&gt;&#13;   Any content created automaticall when btn is clicked&#13;&lt;/div&gt;&#13;</programlisting>
<para>如果组件属于不同的ID空间，你可以在事件名称之后指定一个路径。</para>
<programlisting>&lt;button id="btn" label="show" onClick="content.visible = true"/&gt;&#13;&lt;window id="content" fulfill="../btn.onClick"&gt;&#13;   Any content created automaticall when btn is clicked&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>使用事件监听器的随机存取</title>
<para>如果你喜欢手动创建子组件或者你需要动态地修改它们，你可以监听使这些子组件变得可见的事件，然后在监听器中操纵它们。例如：</para>
<programlisting>&lt;combobox id="combo" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&lt;![CDATA[&#13;   void prepare() {&#13;      if (event.isOpen() &amp;&amp; combo.getItemCount() == 0) {&#13;         combo.appendItem("First Option");&#13;      }&#13;   }&#13;]]&gt;&lt;/zscript&gt;&#13;</programlisting></sect2></sect1><sect1><title>隐含对象</title>
<para>对于嵌入到ZUML页面的脚本，有一套可以使开发人员更有效地访问组件的隐含对象。这些对象对于zscript元素包含的Java代码及事件监听器指定的属性是可用的。当然对于EL表达式也是可用的。</para>
<para/>
<para>例如，<code>self</code> 是<code>org.zkoss.zk.ui.Component</code>的用来代表被处理组件的一个实例。在下面的例子中，在事件监听器中使用<code>self</code>来标识组件。</para>
<programlisting>&lt;button label="Try" onClick="alert(self.label)"/&gt;&#13;</programlisting>
<para>同样，<code>event</code>代表当前事件监听器正在处理的事件。因此上面语句的等价程序如下：</para>
<programlisting>&lt;button label="Try" onClick="alert(event.target.label)"/&gt;&#13;</programlisting><sect2><title>隐含对像列表</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>对象名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>self</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Component</code>
</para>
<para>组件本身。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>spaceOwner</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.IdSpace</code>
</para>
<para>组件的空间所有者，与<code>self.spaceOwners</code>相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>page</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Page</code>
</para>
<para>页面，与<code>self.page</code>相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>desktop</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss</code>
<code>.zk.ui.Desktop</code>
</para>
<para>桌面，与<code>self.desktop</code>相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>session</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Session</code>
</para>
<para>会话。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>application</code>
</para>
</entry>
<entry>
<para>
<code>org</code>
<code>.zkoss.zk.ui.WebApp</code>
</para>
<para>Web 应用程序.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>componentScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>在组件中定义的属性的映射(map)。与
<code>org.zkoss.zk.ui.Component</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>spaceScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>在包含此组件的命名空间内定义的属性的映射(map)。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>pageScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>定义在页面内属性的映射(map)。与<code>org.zkoss.zk.ui.Page</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>desktopScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>定义在桌面内属性的映射(map)。与
<code>org.zkoss.zk.ui.Desktop</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>sessionScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>定义在session内属性的映射(map)。与
<code>org.zkoss.zk.ui.Session</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>applicationScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>定义在web程序内属性的映射(map)。与
<code>org.zkoss.zk.ui.WebApp</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>requestScope</code>
</para>
</entry>
<entry>
<para>java.util.Map</para>
<para>在request内定义属性的映射(map)。与
<code>org.zkoss.zk.ui.Execution</code>接口中的<code>getAttributes</code>方法相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>arg</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>arg参数会被传送到<code>org.zkoss.zk.ui.Executions</code>类的<code>createComponents</code>方法。不能为null。</para>
<para>注意，只有为包含页面(<code>createComponents</code>方法的第一个参数)创建组件时arg才是可用的。另一方面，包括<code>onCreate</code>事件在内的所有事件会在之后被处理。然后，如果你想访问<code>onCreate</code>事件监听器中的<code>arg</code>，可以使用</para>
<para>
<code>org.zkoss.zk.ui.event.CreateEvent</code>类的<code>getArg</code>方法。</para>
<para>与<code>self.desktop.execution.arg</code>相同。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>each</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Object</code>
</para>
<para>当ZK 为每个迭代元素赋值时，其代表被迭代集合的当前项目。一个迭代元素即为使用<code>forEach</code>属性的元素。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>forEachStatus</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss</code>
<code>.zk.ui.util.ForEachStatus</code>
</para>
<para>一个迭代器(iteration)的状态。当为迭代元素赋值时，ZK陈列出(exposes)迭代发生时的相关信息。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>event</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss</code>
<code>.zk.ui.event.Event </code>
<code>或派生类</code>
</para>
<para>当前事件。仅对事件监听器可用。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>关于Request和Execution的信息</title>
<para>
<code>org.zkoss.zk.ui.Execution</code>接口提供了关于当前执行(execution)的信息，如请求参数。为了获取当前的execution ，你可以选择一种方法：</para>
<orderedlist>
<listitem>
<para>在组件中使用<code>getDesktop().getExecution()</code>。</para>
</listitem>
<listitem>
<para>如果没有涉及到组件，页面或桌面，使用<code>org.zkoss.zk.ui.Executions</code>类中的
<code>getCurrent</code>方法。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>进程指令</title>
<para>XML处理指令描述了如何处理ZUML页面。</para><sect2><title>page指令</title>
<para>
<code>&lt;?page [id="..."] [title="..."] [style="..."] [language="xul/html"] [zscript-language="Java"]?&gt;</code>
</para>
<para>此指令描述了页面的属性。</para>
<para>[注]：你可以将<code>page</code>指令放置在XML文档的任何地方，但是，<code>language</code>属性只有当指令位于最高层次时才是有意义的，也就是说，处于根组件的层次。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>id</code>
</para>
</entry>
<entry>
<para>[可选][默认: 自动产生]</para>
<para>指定页面的标识，这样就可以获取它。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>title</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>none</code>]</para>
<para>指定页面的标题，作为浏览器的标题。</para>
<para>可以调用<code>org.zkoss.zk.ui.Page的setTitle</code> 方法来动态的改变此属性。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>style</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>width:100%</code>]</para>
<para>指定用于输出(render)页面的CSS样式。这依赖于模型(mold)。默认为<code>width:100%</code>。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>language</code>
</para>
</entry>
<entry>
<para>[选项][默认: 依赖于扩展][<code>xul/html</code> | <code>xhtml</code>]</para>
<para>指定页面语言，目前，它支持<code>xul/html</code> 和 <code>xhtml</code>。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>zscript-language</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>Java</code>][<code>Java</code> | <code>JavaScript</code> | <code>Ruby</code> | <code>Groovy</code>]</para>
<para>假设zscript元素没有明确指明任何脚本语言，就用此属性来指明默认的脚本语言。</para>
<para>若选项被忽略，则使用Java语言。目前ZK支持四种语言：<code>Java</code>, <code>JavaScript</code>, <code>Ruby</code> 和<code>groovy</code>。此选项区分大小写。</para>
<para>例如，如果你想使用 JavaScript 作为默认的脚本语言，你可以按如下方式：</para>
<para/>
<programlisting>&lt;?page zscript-language="JavaScript"?&gt;&#13;&#13;&lt;zscript&gt;&#13;    var m = function () {&#13;        //...&#13;    }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>注意，开发人员可以扩展ZK支持的脚本语言的数量。参考如何支持更多的脚本语言(How to Support More Scripting Languages)章节获得详细信息。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>component</code>指令</title>
<para>&lt;<code>?component name="</code>
<code>myName</code>
<code>" macro-uri="</code>
<code>/mypath/my.zul</code>
<code>" </code>
<code>[</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" [class="</code>
<code>myPackage.myClass</code>
<code>"] [extends="</code>
<code>existentName</code>
<code>"] [mold-name="</code>
<code>myMoldName</code>
<code>"] [mold-uri="/</code>
<code>myMoldUri</code>
<code>"] [</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>为某一页面定义新的组件。使用此指令定义的组件，仅对于使用该指令的页面是可见的。为了定义在所有组件中可以使用的组件，可是使用附加语言插件(language addon)，即一个XML文件，用来</para>
<para>定义在Web应用程序<footnote><para>参考the Component Development Guide。</para></footnote>中所有页面都可使用的组件。</para>
<para>有两种方式：通过宏和通过类(by-macro and by-class)。</para><sect3><title>宏格式(The by-macro Format)</title>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" macro-uri="</code>
<code>/mypath/my.zul</code>
<code>" [inline="true|</code>
<code>false</code>
<code>"] [class="</code>
<code>myPackage.myClass</code>
<code>"] </code>
<code>[</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>基于ZUML页面定义一个组件，被称为宏组件。换句话说，一旦新组件的一个实例被创建，就会基于指定的ZUML页面(<code>macro-uri</code>属性指定)创建子组件。为了更多的细节，参考宏组件一章。</para></sect3><sect3><title>类格式(The by-class Format)</title>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" [class="</code>
<code>myPackage.myClass</code>
<code>"] [extends="</code>
<code>existentName</code>
<code>"] [mold-name="</code>
<code>myMoldName</code>
<code>"] [mold-uri="/</code>
<code>myMoldUri</code>
<code>"] [</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>如果扩展属性被指定，则基于类创建一个新的组件，即原组件(native component)。这个类必须实现<code>org.zkoss.zk.ui.Component</code>接口。</para>
<para>为了定义一个新的组件，你至少必须定义<code>class</code>属性。ZK用这个类属性用来实例化组件的一个新实例。</para>
<para>除了定义一个全新的组件，你可以通过指定<code>extends="existentName"</code>来重写已存在组件的属性。换句话说，如果<code>extends</code>被指定，被指定组件的定义会作为默认值被加载，然后，只有在此指令中被指定的属性会被重写。</para>
<para>例如，假定你想使用<code>MyWindow</code>定义一个名字为<code>mywindow</code>的新组件，而不是默认的<code>window</code>(ZUML页面中的<code>org.zkoss.zul.Window</code>)。然后声明如下：</para>
<programlisting>&lt;?component name="mywindow" extends="window" class="MyWindow"?&gt;&#13;...&#13;&lt;mywindow&gt;&#13;...&#13;&lt;/mywindow&gt;&#13;</programlisting>
<para>等价于下面的代码：</para>
<programlisting>&lt;window use="MyWindow"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>同样，在下面的例子中，将使用OK作为按钮默认标签，并且按钮的默认边框为蓝色，</para>
<para>当然，在仅在此页面内有效。</para>
<programlisting>&lt;?component name="okbutton" extends="button" label="OK"&#13;  style="border:1px solid blue"?&gt;&#13;</programlisting>
<para>注意，新组件的名字可以和已存在组件的名称一样。在这个例子中，所有组件指定类型的实例将会使用指定的初始属性，就好像它隐藏了存在的定义。例如，下列代码会使所有的按钮使用蓝色边框作为默认值。</para>
<programlisting>&lt;?button name="button" extends="button" style="border:1px solid blue"?&gt;&#13;
&lt;button/&gt; &lt;!-- with blue border --&gt;</programlisting>
<para>如想获得更多信息，请参考the Developer's Reference.</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>name</code>
</para>
</entry>
<entry>
<para>[必须]</para>
<para>组件名称。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>macro-uri</code>
</para>
</entry>
<entry>
<para>[必须，当使用宏格式时(by-macro)][不允许EL]</para>
<para>被宏格式用来指定ZUML页面的URI，即创建组件的模版。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[可选]</para>
<para>被用于类格式和宏格式(by-class and by-macro)，指定一个类用来初始化这种组件的一个实例。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>extends</code>
</para>
</entry>
<entry>
<para>[可选]</para>
<para>被用于类格式，用来表示一个组件的名称，使用此组件的属性作为默认值，然后仅重写在此指令中指定的属性。</para>
<para>如果此属性没有被指定，任何已存在的定义会被忽略。新组件是全新的(brand-new)，完全使用此指令中指定的属性。</para>
</entry>
</row>
<row>
<entry>
<code>mold-name</code>
</entry>
<entry>
<para>[可选][默认：<code>default</code>]</para>
<para>被用于类格式，指定<code>mold-name</code>。如果此属性被指定，<code>mold-uri</code>也必须被指定。</para>
</entry>
</row>
<row>
<entry>
<code>mold-uri</code>
</entry>
<entry>
<para>[可选][EL被允许]</para>
<para>被用于<code>by-class </code>， 指定模型(mold)的URI。如果<code>mold-uri</code>被指定，而<code>mold-name</code>没有被指定，则模型(mold)的名字为<code>default</code>。</para>
</entry>
</row>
<row>
<entry>
<code>prop1, prop2...</code>
</entry>
<entry>
<para>[可选]</para>
<para>被用于<code>by-class</code> 格式和<code>by-macro</code>格式，指定一个组件的初始属性(亦称，成员)。</para>
<para>如果一个组件被ZUML创建(亦称，作为ZUML页面的一部分被指定)，初始属性会被自动应用(applied)。</para>
<para>另一方面，如果它们是被手动创建的(也就是说，通过Java代码)，则不会被应用。如果你仍想应用它们，你必须调用<code>applyProperties</code>方法。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>init</code>指令</title>
<para>
<code>&lt;?init class="..." [arg0="..."] [arg1="..."] [arg2="..."] [arg3="..."]?&gt;</code>
</para>
<para>
<code>&lt;?init zscript="..." [arg0="..."] [arg1="..."] [arg2="..."] [arg3="..."]?&gt;</code>
</para>
<para>有两种格式。第一种格式是指定一个类用于处理具体应用(application-specific)的初始化。第二种格式是指定一个zscript文件用于处理具体应用(application-specific)的初始化。</para>
<para>初始化发生在页面被赋值前，并且和桌面联系在一起，因此，当初始化时<code>getDesktop</code>, <code>getId</code>和<code>getTitle</code>方法都会返回null。可以使用<code>org.zkoss.zk.ui.Execution</code>接口获取当前桌面。</para>
<para>你可以指定许多<code>init</code>指令。如果你选择了第一种格式，所指定的类必须实现<code>org.zkoss.zk.ui.util.Initator</code>接口。一旦指定，在页面被赋值前，此类的实例会被创建，并且其<code>doInit</code>方法会被调用。</para>
<para>另外，页面被赋值完毕后，<code>doFinally</code>方法会被调用。当例外发生时，<code>doCatch</code>方法会被调用。因此，<code>init</code>指令并不限于初始化，你可以将其用于清理及错误处理。</para>
<para>如果你选择了第二种格式，<code>zscript</code>文件会被赋值，且参数(参数0,参数1,......)会作为类型为<code>Object[]</code>的<code>args</code>调用的一个变量被传递。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[可选]</para>
<para>必须实现<code>org.zkoss.zk.ui.util.Initator</code>接口的一个类。</para>
<para>
<code>doInit</code>方法在页面初始阶段Page Initial phase (也就是说，在页面被赋值前)被调用。 <code>doFinally</code> 发法在页面被赋值后被调用。如果在赋值期间例外发生，<code>doCatch</code>方法会被调用。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>zscript</code>
</para>
</entry>
<entry>
<para>[可选]</para>
<para>要在页面初始阶段被赋值的script文件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>arg0, arg1, arg2, arg3,...</code>
</para>
</entry>
<entry>
<para>[可选]</para>
<para>你可以指定许多参数，如果使用第一种格式，它会被传递到<code>doInit</code>方法；或如果使用第二种格式，作为args变量。</para>
<para>注:参数依次为<code>arg0, arg1......</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>variable-resolver</code>指令</title>
<para>
<code>&lt;?variable-resolver class="..."?&gt;</code>
</para>
<para>为zscript解释器指定一个变量分解器(variable resolver )用以分解未知变量。被指定的类必须实现 <code>org.zkoss.zk.scripting.VariableResolver</code>接口。</para>
<para>你可以使用多个variable-resolver指令以指定多个变量分解器。声明靠后的分解器有更高的优先级。</para>
<para>下面是一个ZK结合Spring框架的例子，它分解了在Spring框架中声明的Java Beans，这样我们可以直接访问到它们。</para>
<programlisting>&lt;?variable-resolver class="org.zkoss.zkplus.spring.DelegatingVariableResolver"?&gt;&#13;</programlisting>
<para>参考 <ulink url="http://zk1.sourceforge.net/smalltalks/springdao1/sdao1.html">Small Talk: 
ZK with Spring DAO and JDBC, Part II</ulink>获取更多细节。
</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[必须]</para>
<para>一个必须实现<code>org.zkoss.zk.scripting.VariableResolver</code>接口的类。</para>
<para>指定类的实例被创建并且被添加到页面.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>import</code>指令</title>
<para>
<code>&lt;?import uri="..."?&gt;</code>
</para>
<para>引入在另一个ZUML页面内的组件定义和初始器(initiator)。换句话说，即从指定的页面引入<code>component</code>和<code>init</code>指令。 注意除了<code>component</code>和<code>init</code>之外的指令被忽略，以免混淆。</para>
<para>一个典型的应用时将一套组件定义防置在一个ZUML页面中，然后在另外的ZUML页面引入，这样除了系统默认的外(additional to the system default)，可以共享一套相同的组件定义。</para>
<programlisting>&lt;!-- special.zul: Common Definitions --&gt;&#13;&lt;?init zscript="/WEB-INF/macros/special.zs"?&gt;&#13;&lt;?component name="special" macro-uri="/macros/special.zuml" class="Special"?&gt;&#13;&lt;?component name="another" macro-uri="/WEB-INF/macros/another.zuml"?&gt;&#13;</programlisting>
<para>假定<code>Special</code>类定义在 <code>/WEB-INF/macros/special.zs</code>文件内。</para>
<para>然后，其他的ZUML页面可以按如下方式共享一套组件定义：</para>
<programlisting>&lt;?import uri="special.zul"?&gt;&#13;...&#13;&lt;special/&gt;&lt;!-- you can use the component defined in special.zul --&gt;&#13;</programlisting>
<para>不同与其他指令， <code>import</code> 指令必须位于最高层次，也就是说，处于根组件的层次。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>uri</code>
</para>
</entry>
<entry>
<para>[必须]</para>
<para>组件定义所在ZUML页面的URI。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>link</code>和<code>meta</code>指令</title>
<para>
<code>&lt;?link [href="uri"] </code>
<code>[</code>
<code>name0</code>
<code>="</code>
<code>value0</code>
<code>"] [</code>
<code>name1</code>
<code>="</code>
<code>value1</code>
<code>"] [</code>
<code>name2</code>
<code>="</code>
<code>value2</code>
<code>"]?&gt;&lt;?meta [</code>
<code>name0</code>
<code>="</code>
<code>value0</code>
<code>"] [</code>
<code>name1</code>
<code>="</code>
<code>value1</code>
<code>"] [</code>
<code>name2</code>
<code>="</code>
<code>value2</code>
<code>"]?&gt;</code>
</para>
<para>即在HTML中所谓的头元素(header element)。目前，仅基于HTML的客户端(即所谓的浏览器)支持它们。</para>
<para>开发人员可以使用这些头指令指定任何属性。ZK仅编码<code>href</code>属性的URI(通过使用<code>Executions</code>类的<code>encodeURL</code>方法)。ZK为客户端直接产生其他所有属性。</para>
<para>注意，这些头指令仅对主要的ZUML页面是有效的。换句话说，如果一个页面被其他页面或servlet包含，这些指令会被忽略。如果页面为一个zhtml页面，这些指令也会被忽略。</para>
<programlisting>&lt;?link rel="alternate" type="application/rss+xml" title="RSS feed"&#13; href="/rssfeed.php"?&gt;&lt;&#13;?link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"?&gt;&#13;&#13;&lt;window title="My App"&gt;&#13;   My content&#13;&lt;/window&gt;&#13;</programlisting></sect2></sect1><sect1><title>ZK属性</title>
<para>除了用于初始化数据成员，ZK属性还被用于控制关联元素。</para><sect2><title>
<code>use</code>属性</title>
<para>
<code>for</code>
<code>EachEnd="</code>
<code>a-class-name</code>
<code>"</code>
</para>
<para>指定一个类来创建一个组件(代替默认的)。在下面的例子中，<code>MyWindow</code> 被用于代替默认的<code>org.zkoss.zul.Window</code>。</para>
<programlisting>&lt;window use="MyWindow"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>if</code>属性</title>
<para>
<code>if="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>指定为相关元素赋值的条件。换句话说，如果条件值为假(false)，关联元素及其所有子元素会被忽略。</para></sect2><sect2><title>
<code>unless</code>属性</title>
<para>
<code>unless="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>指定不为相关元素赋值的条件。换句话说，如果条件值为真(true)，关联元素及其所有子元素会被忽略。</para></sect2><sect2><title>forEach属性</title>
<para>
<code>forEach="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>指定一个对象集合，这样关联元素可以依靠集合中的每个对象重复被赋值。如果没有指定或为空，此属性会被忽略。如果没有集合对象被指定，仅会被赋值一次就好像有一个单元素的集合被指定。</para></sect2><sect2><title>
<code>forEachBegin</code>属性</title>
<para>
<code>forEachBegin="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>被用于<code>forEach</code> 属性，指定迭代开始处索引(从0开始)。如果没有指定，迭代会从第一个元素开始，即0。</para>
<para>如果<code>forEachBegin</code>大于或等于元素的数目，则不会发生迭代。</para>
<para>[注]：forEachBegin.index对于基本的集合，数组和其他类型是绝对的。例如，如果forEachBegin为5 ，forEachStatus.index的第一个值为5。</para></sect2><sect2><title>
<code>forEachEnd</code>属性</title>
<para>
<code>for</code>
<code>EachEnd="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>被用于<code>forEach</code> 属性，指定迭代结束处索引(包括此)(从0开始)。如果没有指定，迭代会在最后一个元素处结束。</para>
<para>如果<code>forEachEnd</code>大于或等于元素的数目，则迭代会在最后一个元素处结束。</para></sect2><sect2><title>
<code>fulfill</code>属性</title>
<para>
<code>fulfill="</code>
<code>event-name"</code></para><para>
<code>fulfill="</code>
<code>target-id</code>
<code>.</code>
<code>event-name"</code></para><para>
<code>fulfill="</code>
<code>id1/id2/id3</code>
<code>.</code>
<code>event-name"</code></para><para>
<code>fulfill="${</code>
<code>el-expr</code>
<code>}.</code>
<code>event-name</code>
<code>"</code>
</para>
<para>指定何时创建子组件。默认(即没有指定<code>fulfill</code>)情况下，子组件会在父组件之后被创建，当ZUML页面被加载时。</para>
<para>如果你想推迟子组件的创建，你可以通过<code>fulfill</code>属性指定条件。条件有事件名称，还有，可选的，目标组件的标识或路径。这意味着直到目标组件指定的事件(如果指定了)发生时，子组件才会被处理。如果标识被省略，则假定为同一组件。</para>
<para>如果指定了EL表达式，则返回一个组件，标识或路径。</para>
<para>参考随机存取(Load on Demand)章节获取更多细节。</para></sect2></sect1><sect1><title>ZK元素</title>
<para>除了被用于创建组件，ZK元素还被用于控制ZUML页面。</para><sect2><title>
<code>zk</code> 元素</title>
<para>
<code>&lt;zk&gt;...&lt;/zk&gt;</code>
</para>
<para>用于聚集(aggregate)其它元素的特殊元素。不同于一个真实的组件(如<code>hbox</code>或<code>div</code>)，它并不是被创建的组件树的一部分。换句话说，它并不代表任何元素。例如：</para>
<programlisting>&lt;window&gt;&#13;   &lt;zk&gt;&#13;      &lt;textbox/&gt;&#13;      &lt;textbox/&gt;&#13;   &lt;/zk&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;   &lt;textbox/&gt;&#13;   &lt;textbox/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>那么，它是干什么用的呢？</para><sect3><title>一个页面中的多个根元素</title>
<para>由于XML语法的限制，我们只能指定一个文档根，因此，如果有多个根组件，你必须使用zk作为文档根来组织起这些根组件。</para>
<programlisting>&lt;?page title="Multiple Root"?&gt;&#13;&lt;zk&gt;&#13;   &lt;window title="First"&gt;&#13;   ...&#13;   &lt;/window&gt;&#13;   &lt;window title="Second" if="${param.secondRequired}"&gt;&#13;   ...&#13;   &lt;/window&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect3><sect3><title>通用的迭代组件</title>
<para>zk元素，像组件一样，支持<code>forEach</code>属性。因此，你可以使用它根据条件产生不同类型的组件。在下面的例子中，我们假定<code>mycols</code>是包含几个成员的对象集合 <code>isUseText()</code>
<code>，</code>
<code>isUseDate() </code>
<code>和</code>
<code> isUseCombo()</code>。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zk forEach="${mycols}"&gt;&#13;      &lt;textbox if="${each.useText}"/&gt;&#13;      &lt;datebox if="${each.useDate}"/&gt;&#13;      &lt;combobox if="${each.useCombo}"/&gt;&#13;   &lt;/zk&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>true</code>]</para>
<para>指定条件为这个元素赋值.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>false</code>]</para>
<para>指定条件不为这个元素赋值.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>for</code>
<code>Each</code>
</para>
</entry>
<entry>
<para>[可选][默认: <code>ignored</code>]</para>
<para>指定一个对象集合，这样zk元素可以依靠(against)集合中的每个对象重复被赋值。如果没有指定或为空，此属性被忽略。如果没有集合对象被指定，仅会被赋值一次就好像有一个单元素的集合被指定。</para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>zscript</code>元素</title>
<para>
<code>&lt;zscript [language="Java"]&gt;</code>
<code>Scripting codes</code>
<code>&lt;/zscript&gt;&#13;&lt;zscript src="</code>
<code>uri</code>
<code>" [language="Java"]/&gt;</code>
</para>
<para>定义脚本代码，如Java代码，当页面被赋值时会解释此代码。默认的语言为Java(见下文)。你可以使用<code>language</code>属性来选择不同的语言。 </para>
<para>
<code>zscript</code> 元素有如上所示的两种格式。第一种格式是将脚本代码直接嵌入到页面中。第二种格式是指定一个包含脚本代码的文件。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>src</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>none</code>]</para>
<para>指定包含脚本代码文件的URI。若被指定，脚本代码会被加载，就像直接嵌入到文件中一样。</para>
<para>src属性支持浏览器和按照地方的URI。换言之，你可以指定~ 或 * 来表示不同的上下文路径，浏览器或本地信息。参考国际化来获取细节。</para>
<para>[注]：文件应包含指定语言的源代码，此代码可以被直接解释。编码必须为UTF-8。不要指定类文件(亦称字节码)。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>language</code>
</para>
</entry>
<entry>
<para>[可选][默认：Java或<code>page</code>指令指定的语言][可选值：<code>Java</code> | <code>JavaScript</code> | <code>Ruby</code> | <code>Groovy</code>]</para>
<para>指定编写脚本代码的语言。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>deferred</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>false</code>]</para>
<para>是否推迟这个元素的赋值，直到第一个同种语言的非推迟zscript代码需要被赋值。参考下面的如何推迟赋值章节。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>true</code>]</para>
<para>指定为这个组件赋值的条件</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>false</code>]</para>
<para>指定不为这个组件赋值的条件</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>如何推迟赋值</title>
<para>当要为第一个<code>zscript</code>代码赋值时，ZK会加载解释器。例如，在下面的例子中，当用户点击按钮时Java解释器会被加载。</para>
<programlisting>&lt;button onClick="alert(&amp;quot;Hi&amp;quot;)"/&gt;&#13;</programlisting>
<para>另一方面，由于需要在加载页面时为<code>zscript</code>元素赋值，所以当加载下面的ZUML页面时，解释器会被加载。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;   void add() {&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button onClick="add()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>如果你想推迟解释器的加载，可以将<code>deferred</code>设为<code>true</code>。那么，直到用户点击按钮时，解释器才会被加载。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript deferred="true"&gt;&#13;   void add() {&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button onClick="add()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>[注]：在<code>if</code>，<code>unless</code>和<code>src</code>属性中指定的EL表达式的赋值也是延迟的。</para>
<para>[注]：如果到解释器时一个组件被从页面移除，<code>zscript</code>代码会被忽略。例如，前面例子中的<code>window</code>不再属于页面，延迟的<code>zscript</code>也不会被解释。</para></sect3><sect3><title>如何选择一种不同的脚本语言</title>
<para>一个页面可以有多种不同的脚本语言。</para>
<programlisting>&lt;button onClick="javascript:do_something_in_js()"/&gt;&#13;&lt;zscript language="groovy"&gt;&#13;do_something_in_Groovy();&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>如果省略脚本语言，则假定为Java。如果你想改变默认的脚本语言，可以按如下方式使用<code>page</code>指令 </para>
<programlisting>&lt;?page zscript-language="Groovy"?&gt;&#13;&#13;&lt;zscript&gt;&#13;def name = "Hello World!";&#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>如何支持更多的脚本语言</title>
<para>目前，ZK支持Java, JavaScript, Ruby 和 Groovy。但是，它很容易扩展：</para>
<orderedlist>
<listitem>
<para>一个实现<code>org.zkoss.zk.scripting.Interpreter</code>接口的类。如果你想直接处理命名空间，可以继承<code>org.zkoss.zk.scripting.util.GenericInterpreter</code>类。或者，如果解释器支持BSF(Bean Scripting Framework，Bean脚本框架)，也可以继承
<code>org.zkoss.scripting.bsh.BSFInterpreter</code>类。</para>
</listitem>
<listitem>
<para>在<code>WEB-INF/zk.xml或 zk/config.xml</code>文件中声明脚本语言。</para>
</listitem>
</orderedlist>
<programlisting>&lt;zscript-config&gt;&#13;   &lt;zscript-language&gt;&#13;      &lt;language-name&gt;SuperJava&lt;/language-name&gt;&lt;!-- case insensitive --!&gt;&#13;      &lt;interpreter-class&gt;my.MySuperJavaInterpreter&lt;/interpreter-class&gt;&#13;   &lt;/zscript-language&gt;&#13;&lt;/zscript-config&gt;&#13;</programlisting>
<para>参考the Developer's Reference来获取关于<code>WEB-INF/zk.xml</code>的细节。参考the Component Development Guide来获取关于<code>zk/config.xml</code>的细节。</para></sect3></sect2><sect2><title>
<code>attribute</code>元素</title>
<para>定义一个闭合元素的XML属性。元素的内容为属性值，而<code>name</code>属性用于指定属性名称。如果属性值比较复杂或属性为条件式的，这比较有用。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>name</code>
</para>
</entry>
<entry>
<para>[必须]</para>
<para>指定属性名称。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>trim</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>false</code>]</para>
<para>指定是否省略属性值开头及末尾的空格。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>none</code>]</para>
<para>指定为这个元素赋值的条件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>none</code>]</para>
<para>指定不为这个元素赋值的条件。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>variables</code>元素</title>
<para>定义一套变量。如果有一个父组件和页面，如果在页面级声明，它等价于<code>Component</code>的<code>setVariable</code>方法。</para>
<para>如下所述，<code>variables</code>可以很方便的指定变量而无需编程。</para>
<programlisting>&lt;window&gt;&#13;   &lt;variables rich="simple" simple="intuitive"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;      self.setVariable("rich", "simple", false);&#13;      self.setVariable("simple", "intuitive", false);&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当然，也可以为值指定EL表达式。</para>
<programlisting>&lt;window&gt;&#13;   &lt;window id="w" title="Test"&gt;&#13;<inlinegraphic fileref="img/6-8-4.png" align="right"/>      &lt;variables title="${w.title}"/&gt;&#13;      1: ${title}&#13;   &lt;/window&gt;&#13;   2: ${title}&#13;&lt;/window&gt;&#13;</programlisting>
<para>就像<code>Component</code>的<code>setVariable</code>方法，你可以按如下方式控制是否为当前的ID空间声明局部变量。如果没有指定，则假定为<code>local=”false”</code>。</para>
<programlisting>&lt;variables simple="rich" local="true"/&gt;&#13;</programlisting><sect3><title>
<code>null</code>(The <code>null</code> Value)</title>
<para>在下面的例子中，var是一个空字符串。</para>
<programlisting>&lt;variables var=""/&gt;&#13;</programlisting>
<para>为了为变量指定一个<code>null</code>值，可以使用下面的语句。</para>
<programlisting>&lt;variables var="${null}"/&gt;</programlisting></sect3></sect2><sect2><title>
<code>custom-attributes</code>元素</title>
<para>定义一套定制属性。定制属性为与一个特定范围相关联的对象。可接受的范围包括组件，空间，页面，桌面，会话和应用(component, space, page, desktop, session and application)。</para>
<para>如下所述，<code>custom-attributes</code>属性可以方便的指派定制属性而无需编程。</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes main.rich="simple" very-simple="intuitive"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;      self.setAttribute("main.rich", "simple");&#13;      self.setAttribute("very-simple", "intuitive");&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>此外，你可以指定定制属性的范围。</para>
<programlisting>&lt;window id="main" title="Welcome"&gt;&#13;   &lt;custom-attributes scope="desktop" shared="${main.title}"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window id="main"&gt;&#13;   &lt;zscript&gt;&#13;      desktop.setAttribute("shared", main.title);&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>注意EL表达式依靠创建的组件被赋值。有时它是微妙的通知(it is subtle to notice)。例如，在下面的代码中，<code>${componentScope.simple}</code>被赋值为<code>null</code>。为什么呢? 这是<code>&lt;label value=</code>
<code>"${componentScope.simple}"/&gt;</code>的一个快捷方式(shortcut)。换言之，当EL被赋值时，组件，<code>self</code>，是<code>lable</code>而不是<code>window</code>。</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes simple="intuitive"/&gt;&#13;   ${componentScope.simple}&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes simple="intuitive"/&gt;&#13;   &lt;label value="${componentScope.simple}"/&gt;&lt;!-- self is label not window --&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>[提示]：不要混淆&lt;<code>attribute</code>&gt;与&lt;<code>custom-attributes</code>&gt; 。他们毫不相干。 <code>attribute</code> 元素是定义闭合元素属性的一种方式，而<code>custom-attributes</code> 被用于为一个特定范围指派定制属性。</para>
<informaltable frame="all" align="center">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>scope</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>component</code>]</para>
<para>指定定制属性关联的范围。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>none</code>]</para>
<para>指定为这个元素赋值的条件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[可选][默认：<code>none</code>]</para>
<para>指定不为这个元素赋值的条件。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2></sect1><sect1><title>组件集及XML命名空间</title>
<para>为了在同一个ZUML页面内使用两套或更多套组件，XML使用命名空间来区分不同的组件集。例如，XUL为<code>http://www.zkoss.org/2005/zul，而XHTML为http://www.w3.org/1999/xhtml</code>。</para>
<para>另一方面，多个页面仅使用一套组件。为了使这样的页面更容易编写，ZK以扩展名为基础决定了默认的命名空间。例如，XUL和ZUL扩展名意味着使用XUL命名空间。因此，开发人员只需将ZUML页面与合适的扩展名相关联，那么再也不用担心XML命名空间。</para><sect2><title>标准的命名空间</title>
<para>如前所述，每套组件都会和一个特定的命名空间相关联。然而，开发人员可以开发或使用第三方的组件，所以我们在这里只列出ZK发布的命名空间。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>命名空间</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>http://www.zkoss.org/2005/zul</code>
</para>
</entry>
<entry>
<para>XUL组件集的命名空间。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>http://www.w3.org/1999/xhtml</code>
</para>
</entry>
<entry>
<para>XHTML组件集的命名空间。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>http://www.zkoss.org/2005/zk</code>
</para>
</entry>
<entry>
<para>ZK命名空间。指定ZK具体元素与属性的保留命名空间。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>在ZUML页面中指定命名空间是可选的，直到有冲突为止。ZK通过检测ZUML页面的扩展名来决定使用哪个命名空间。对于<code>.zul和.xul</code>，使用XUL命名空间。对于<code>html，xhtml和zhtml</code>，使用XHTML命名空间。</para>
<para>为了混合使用另一种标记语言，你可以使用<code>xmlns</code>来指定合适的命名空间。</para>
<programlisting>&lt;window xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;   &lt;h:div&gt;&#13;      &lt;button/&gt;&#13;   &lt;/h:div&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>对于XHTML组件，<code>onClick</code>和onChange属性和ZK的属性冲突。你可以使用保留的</para>
<para>
<ulink url="http://www.zkoss.org/2005/zk">
<code>http://www.zkoss.org/2005/zk</code></ulink>
命名空间来解决这个问题，如下：</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/zk/core.dsp.tld" prefix="u" ?&gt;&#13;&#13;&lt;html xmlns:x="http://www.zkoss.org/2005/zul"&#13;xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;script type="text/javascript"&gt;&#13;   function woo() { //running at the browser&#13;   }&#13;   &lt;/script&gt;&#13;   &lt;zk:zscript&gt;&#13;   void addItem() { //running at the server&#13;   }&#13;   &lt;/zk:zscript&gt;&#13;   &lt;x:window title="HTML App"&gt;&#13;     &lt;input type="button" value="Add Item"&#13;      onClick="woo()" zk:onClick="addItem()"/&gt;&#13;   &lt;/x:window&gt;&#13;&lt;/body&gt;&#13;</programlisting>
<para>在这个例子中，ZHTML的<code>onClick</code>属性用来指定在浏览器端运行的JavaScript 代码。另一方面，<code>zk:onClick </code>作为保留属性来指定一个ZK事件处理器。</para>
<para>注意，命名空间的前缀，zk，对于<code>zscript</code>元素是可选的，因为ZHTML元素没有这个元素，而ZK有足够的信息来确定它。</para>
<para>同样也要注意你必须为<code>window</code>组件指定XML命名空间，因为其来自于一个不同的组件集。</para></sect2></sect1></chapter>
<chapter>
<title>7. ZUML页面及XUL组件集</title>
<para>本章描述了XUL组件集 。不同于其他的实现，ZK的XUL组件，经过了跨越网络合作的优化。有些组件可能不会完全兼容XUL技术标准。为方便起见，我们有时指它们为XUL组件。</para><sect1><title>基本组件</title><sect2><title>标签</title>
<para>Label组件用来呈现一段文字。</para>
<programlisting>&lt;window border="normal"&gt;&#13;   Hello World&#13;<inlinegraphic fileref="img/7-1-1a.png" align="right"/>&lt;/window&gt;&#13;</programlisting>
<para>如果你想为Label指定一个属性，并且如下方式明确指定&lt;<code>label</code>&gt;。</para>
<programlisting>&lt;window border="normal"&gt;&#13;   &lt;label style="color: red" value="Hello World"/&gt;&#13;<inlinegraphic align="right"  fileref="img/7-1-1b.png"/>&lt;/window&gt;&#13;</programlisting>
<para>[提示]：ZUML为XML而不是HTML，所以并不接受<code>&amp;nbsp;</code>。但是可以用<code>&amp;#160;</code>代替。</para><sect3><title>
<code>pre</code>, <code>hyphen</code>, <code>maxlength</code> 和<code>multiline</code> 属性</title>
<para>你可以使用 <code>pre</code>
<code>，</code>
<code>hyphen</code>
<code>，</code> <code>maxlength</code> 和<code>multiline</code> 属性来控制如何展示一个label。例如，如果指定<code>pre</code>为true，所有的空格，例如换行，空白，制表符都回被保留。</para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row>
<entry>
<para>
<code>hyphen</code>
</para>
</entry>
<entry>
<para>
<code>pre</code>
</para>
</entry>
<entry>
<para>
<code>maxlenth</code>
</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>positive</code>
</para>
</entry>
<entry>
<para>切去超过指定最大长度的字符</para>
</entry>
</row>
<row>
<entry>
<para>
<code>true</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>positive</code>
</para>
</entry>
<entry>
<para>如果一个单词超过了最大长度，此单词会被截断</para>
</entry>
</row>
<row>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>true</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>maxlenth</code>被忽略</para>
</entry>
</row>
<row>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>0</code>
</para>
</entry>
<entry>
<para>
<code>pyphen</code>被忽略</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<programlisting>&lt;window border="normal" width="200px"&gt;&#13;&lt;vbox&gt;&#13;   &lt;label value="Hello, World!" maxlength="5"/&gt;&#13;   &lt;label value="Hello, WorldChampion!" hyphen="true" maxlength="10"/&gt;&#13;   &lt;label pre="true"&gt;&#13;      &lt;attribute name="value"&gt;aa&#13;    bb c&#13;<inlinegraphic fileref="img/7-1-1-1.png" align="right"/>   dd ef&lt;/attribute&gt;&#13;   &lt;/label&gt;&#13;&lt;/vbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para> </para>
<para>
<code>multiline</code> 属性与<code>pre</code>类似，除了<code>multiline</code>在每行的开始保留了换行和空格。</para></sect3></sect2><sect2><title>按钮</title>
<para>有两种类型的按钮：<code>button</code>和<code>toolbarbutton</code>。除了外观，它们的功能使相似的。<code>button</code>组件使用HTML BUTTON标记，而<code>toolbarbutton</code>组件使用HTML A标记。</para>
<para>你可以使用<code>label</code>和<code>image</code>属性来为一个按钮指定标签和图像。如果这两个属性都被指定，<code>dir</code>控制`哪个组件显示在前方，<code>orient</code>控制布局为横向或纵向。</para>
<programlisting>&lt;button label="Left" image="/img/folder.gif" width="125px"/&gt;&#13;<inlinegraphic fileref="img/7-1-2.png" align="right"/>&lt;button label="Right" image="/img/folder.gif" dir="reverse" width="125px"/&gt;&#13;&lt;button label="Above" image="/img/folder.gif" orient="vertical" width="125px"/&gt;&#13;&lt;button label="Below" image="/img/folder.gif" orient="vertical" dir="reverse" width="125px"/&gt;&#13;</programlisting>

<para>除了通过URL来指定图片，你可以使用<code>setImageContent</code>方法为按钮指定一个动态生成图像。参考下面的章节获取细节。</para>
<para>[提示]：所有包含<code>image</code>属性的组件都提供了<code>setImageContent</code>方法。简单来说，<code>setImageContent</code>方法用于动态生成图像，而image用于通过URL指定图像。</para><sect3><title>
<code>onClick</code> 事件和<code>href</code>属性</title>
<para>有两种方式为<code>button</code> 和 <code>toolbarbutton</code>添加行为。首先需要为<code>onClick</code>指定一个监听器。然后为<code>href</code>属性指定一个URL。如果都被指定，href属性拥有更高的优先级，也就是说 <code>onClick</code> 事件不会被发送。</para>
<programlisting>&lt;button onClick="do_something_in_Java()"/&gt;&#13;&lt;button href="/another_page.zul"/&gt;&#13;</programlisting></sect3><sect3><title>
<code>org.zkoss.zk.ui.Execution</code>接口的 <code>sendRedirect</code> 方法</title>
<para>当处理一个事件时， 你可以决定停止处理当前桌面，并且通过<code>sendRedirect</code> 方法来转到另一个页面。换句话说，下面的例子中两个按钮是等价的(从用户的观点来看)。</para>
<programlisting>&lt;button onClick="Executions.sendRedirect(&amp;quot;another.zul&amp;quot;)"/&gt;&#13;&lt;button href="another.zul"/&gt;&#13;</programlisting>
<para>既然 <code>onClick</code> 事件被送到了服务器去处理，你可以在调用<code>sendRedirect</code>前添加更多的逻辑，例如，当特定的条件被满足时转到另一个页面。</para>
<para>另外，<code>href</code>属性在客户端方面被完全处理。当用户点击按钮时，你的应用程序并不会被察觉。 </para></sect3></sect2><sect2><title>单选按钮和单选按钮组</title>
<para>一个单选按钮是可以被打开或关闭的组件。单选按钮可以被分组，称为<code>radiogroup</code>。在相同的组内，同一时间仅可以有一个按钮被选中。</para>
<programlisting>&lt;radiogroup onCheck="alert(self.selectedItem.label)"&gt;&#13;   &lt;radio label="Apple"/&gt;&#13;   &lt;radio label="Orange"/&gt;&#13;   &lt;radio label="Banana"/&gt;&#13;&lt;/radiogroup&gt;&#13;</programlisting><sect3><title>多用途设计版面</title>
<para>你可以混合使用<code>radiogroup</code>和<code>radio</code>来组成你想要的布局，如下所示。</para>
<programlisting>&lt;radiogroup&gt;&#13;   &lt;grid&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&lt;radio label="Apple" selected="true"/&gt; Fruit, music or computer&lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Orange"/&gt;&lt;textbox/&gt;&lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Banana"/&gt;&lt;datebox/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;<inlinegraphic fileref="img/7-1-3-1a.png" align="right"/>   &lt;/grid&gt;&#13;&lt;/radiogroup&gt;&#13;</programlisting>

<para>单选按钮属于离其最近的<code>radiogroup</code>。你甚至你可按如下方式嵌套使用<code>radiogroup</code>。每个</para>
<para>
<code>radiogroup</code>是独立的，虽然可能有某种视觉重叠(visual overlap)。</para>
<programlisting>&lt;radiogroup&gt;&#13;   &lt;grid&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&lt;radio label="Apple" selected="true"/&gt; Fruit, music or computer&lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Orange"/&gt;&#13;         &lt;radiogroup&gt;&#13;         &lt;radio label="Small"/&gt;&#13;         &lt;radio label="Large" selected="true"/&gt;&#13;         &lt;/radiogroup&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Banana"/&gt;&lt;datebox/&gt;&lt;/row&gt;&#13;<inlinegraphic align="right"  fileref="img/7-1-3-1b.png"/>   &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13;&lt;/radiogroup&gt;&#13;</programlisting></sect3></sect2><sect2><title>图像</title>
<para>
<code>image</code> 用于在浏览器端展示图像。有两种方式来为<code>image</code>组件指定一个图像。一种方法是使用<code>src</code>属性指定图像的URI，这种方法与HTML支持的相似。如果你想展示一张景台图像，或任何可以通过URL定位的图像，这种方法很有用。</para>
<programlisting>&lt;image src="/some/my.jpg"/&gt;&#13;</programlisting><sect3><title>本地图像</title>
<para>就像使用其他可以接受URI的属性一样，你可以指定"*"来定位一张本地图像。例如，如果对不同的地区对应不同的图像，你可以按如下方式使用。</para>
<programlisting>&lt;image src="/my*.png"&#13;</programlisting>
<para>然后假定你的用户以de_DE作为首选地区访问你的页面。ZK会设法定位名称为/my_de_DE.png的图像。如果没有找到，则会尝试/my_de.png ，最后是/my.png。</para>
<para>参考国际化一章中关于浏览器和本地化URI的部分来获取细节。</para>
<para>第二种方法是使用<code>setContent</code>方法来直接为image组件指定图像的内容。一旦被指定，图像会展示在浏览器端并会被动态更新。这种方法指定适用于动态生成的图像。</para>
<para>例如，你可以按如下方式为用户指定的位置生成一个映射。</para>
<programlisting>Location: &lt;textbox onChange="updateMap(self.value)"/&gt;&#13;Map: &lt;image id="image"/&gt;&#13;&lt;zscript&gt;&#13;   void updateMap(String location) {&#13;      if (location.length() &gt; 0)&#13;             image.setContent(new MapImage(location));&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>在上面的例子中，我们假定有一个<code>MapImage</code>类用于产生指定位置的映射，即所谓的商业逻辑。</para>
<para>注意，image组件仅接受<code>org.zkoss.image.Image</code>中的内容。如果有工具生成的图像不是这个格式，可以使用<code>org.zkoss.image.AImage</code>类来将一个二进制阵列数据，文件或输入流包装成<code>Image</code>接口 </para>
<para>在传统的Web应用程序中，缓存一个动态生成的图像是很复杂的。有了image组件，你就不需要担心这些了。一旦指定了一个图像的内容，它就属于<code>image</code>组件，而且当image组件不再被使用时，它所占用的内存会被自动释放。</para>
<para>[提示]：如果你想指定非图像音频文件的内容，例如PDF，可以使用<code>iframe</code>组件。参考相关章节获取细节。</para></sect3></sect2><sect2><title>图像映射(Imagemap)</title>
<para>
<code>imagemap</code> 是一个特殊的<code>image</code>组件。它接受<code>image</code>组件的所有属性。但是不同于<code>image</code>，当用户点击一张图像时，onClick 事件及鼠标坐标的位置会一起被送回服务器。相比之下，<code>image</code>发送的<code>onClick</code>事件不包含坐标。</para>
<para>鼠标位置的坐标是屏幕像素，从图像的左上角开始计数，始于(0，0)。这将会作为</para>
<para>
<code>org.zkoss.zk.ui.event.MouseEvent</code>的实例存储。一旦应用程序接收了<code>onClick</code>事件，就可以通过<code>getX</code>和<code>getY</code>方法来检查鼠标位置的坐标。</para>
<para>例如，如果用户点击了下列语句展示图像的(137,167)像素(从左上角开始) ，那么用户就会得到如下所示的结果：</para>
<programlisting>&lt;imagemap src="/img/sun.jpg" onClick="alert(event.x + &amp;quot;, &amp;quot; +event.y)"/&gt;&#13;</programlisting>
<para/><graphic fileref="img/7-1-5.png" align="center"/>
<para>应用程序通常使用坐标来决定用户点击了那个部分，然后作出相应的相应。</para><sect3><title>区域</title>
<para>通过为<code>imagemap</code>然后，组件添加<code>area</code>子组件，开发人员可以代替使用应用程序本身处理坐标的方法。</para>
<programlisting>&lt;imagemap src="/img/sun.jpg" onClick="alert(event.area)"&gt;&#13;  &lt;area id="First" coords="0, 0, 100, 100"/&gt;&#13;  &lt;area id="Second" shape="circle" coords="200, 200, 100"/&gt;&#13;&lt;/imagemap&gt;&#13;</programlisting>
<para>然后，<code>imagemap</code>组件将鼠标的位置坐标翻译成一个逻辑名字：用户点击的区域标识。</para>
<para>例如，如果用户点击(150,150)，将会得到如下描绘的结果：</para>
<para>
<graphic fileref="img/7-1-5-1.png" align="center"/>
</para></sect3><sect3><title>
<code>shape</code>属性</title>
<para>area 组件支持三种形状：圆，多边形和矩形(circle, polygon and rectangle)。鼠标位置的坐标是屏幕像素，从图像的左上角开始计数，始于(0，0)。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>形状</para>
</entry>
<entry>
<para>坐标/描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>circle</code>
</para>
</entry>
<entry>
<para>
<code>coords="x, y, r"</code>
</para>
<para>
<code>x</code>
<code>，</code>
<code>y</code>定义圆心坐标， <code>r</code> 为半径，以像素为单位。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>polygon</code>
</para>
</entry>
<entry>
<para>
<code>coords="x1, y1, x2, y2, x3, y3..."</code>
</para>
<para>一对x,y定义多边形的一个定点。定义三角形至少需要三对坐标。多边形会自动关闭，所以不需要为了关闭区域而在列表的末尾重复第一个坐标。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>rectangle</code>
</para>
</entry>
<entry>
<para>
<code>coords="x1, y1, x2, y2"</code>
</para>
<para>第一对坐标为矩形的一个角，另一对为斜对角。矩形只是为多边性指定四个顶点的简单方式。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>如果一个<code>area</code>组件内的坐标覆盖了另外一个，第一个拥有更高的优先权。</para></sect3></sect2><sect2><title>音频</title>
<para>
<code>audio</code> 组件用来在浏览器端播放音频。就像<code>image</code>，你可以使用src属性来指定音频资源的URL，或使用<code>setContent</code>方法来指定一段动态生成的音频。</para>
<para>依靠浏览器和音频插件，开发人员可以使用<code>play</code>
<code>，</code>
<code>stop</code>和<code>pause</code>方法来控制播放一段音频。目前，包含多媒体的Internet浏览器都有这种控制机制。</para></sect2><sect2><title>输入控件</title>
<para>XUL组件支持一套输入控制组件：<code>textbox</code>
<code>，</code>
<code>intbox</code>
<code>，</code> <code>decimalbox</code>
<code>，</code> <code>doublebox</code>
<code>，</code> <code>datebox</code>, <code>combobox</code>和<code>bandbox</code>，用于输入各种类型的数据 。</para>
<para>
<graphic fileref="img/7-1-7.png" align="center"/>
</para>
<programlisting>&lt;zk&gt;&#13;   &lt;textbox/&gt;&#13;   &lt;datebox/&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>[提示]：<code>combobox</code>和<code>bandbox</code> 是特殊的输入框。他们共享这里描述的公用属性。关于它们各自独特的特点，将会在之后的 <code>combobox</code>和<code>bandbox</code> 章节中讨论。</para><sect3><title>
<code>type</code>属性</title>
<para>你可以为<code>textbox</code> 组件指定值为<code>password</code>的<code>type</code>属性。这样将不会显示用户输入的内容。</para>
<programlisting>Username: &lt;textbox/&gt;&#13;Password: &lt;textbox type="password"/&gt;&#13;</programlisting></sect3><sect3><title>
<code>format</code>属性</title>
<para>通过使用<code>format</code>域，可以控制输入控件的格式。默认为<code>null</code>。对于<code>datebox</code>，意味着 <code>yyyy/MM/dd</code>。而对与<code>intbox</code>和<code>decimalbox</code>，则以为着根本没有格式。</para>
<programlisting>&lt;datebox format="MM/dd/yyyy"/&gt;&#13;&lt;decimalbox format="#,##0.##"/&gt;&#13;</programlisting>
<para>就像其他的任何属性，你可以动态的改变格式，如下所示：</para>
<programlisting>&lt;datebox id="db"/&gt;&#13;&lt;button label="set MM-dd-yyyy" onClick="db.setFormat(&amp;quot;MM-dd-yyyy&amp;quot;)"/&gt;&#13;</programlisting>
<para>无鼠标输入<code>datebox</code>
</para>
<orderedlist>
<listitem>
<para>
<code>Alt+DOWN </code>弹出日历 .</para>
</listitem>
<listitem>
<para>
<code>LEFT</code>
<code>，</code> <code>RIGHT</code>
<code>，</code>
<code>UP</code> 和 <code>DOWN</code> 改变日历中选中的日期.</para>
</listitem>
<listitem>
<para>
<code>ENTER</code> 将选中的日期复制到 <code>date</code>.</para>
</listitem>
<listitem>
<para>
<code>Alt+UP</code> 或 <code>ESC</code> 放弃选择并关闭日历.</para>
</listitem>
</orderedlist></sect3><sect3><title>约束</title>
<para>使用<code>constraint</code>属性可以控制输入控件接受什么值。它可以使<code>no positive</code>
<code>，</code>
<code>no negative</code>
<code>，</code>
<code>no zero</code>
<code>，</code>
<code>no empty</code>
<code>，</code>
<code>no future</code>
<code>，</code>
<code>no past</code>
<code>，</code>
<code>no today</code>和一个正则表达式的集合。前三个约束金使用于<code>intbox</code> 和<code>decimalbox</code>。<code>no future</code>
<code>，</code> <code>no past</code>,和<code>no today</code>约束仅适用于<code>datebox</code>。 <code>no empty</code>适用于任何组件。正则表达式约束仅适用于字符串类型组件，例如<code>textbox</code>
<code>，</code>
<code>combobox</code> 和<code>bandbox</code>。</para>
<para>使用两个或更多的约束时，用逗号翻开约束，如下：</para>
<programlisting>&lt;intbox constraint="no negative,no zero"/&gt;&#13;</programlisting>
<para>为了指定一个正则表达式，你可以使用<code>/</code>来包围表达式。如下：</para>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/"/&gt;&#13;</programlisting>
<para>[注]：</para>
<itemizedlist>
<listitem>
<para>上面的语句为XML，所以不必使用<code>\\</code>来表示反斜杠。另一方面，如果写在Java代码中，则是需要的。</para>
</listitem>
</itemizedlist>
<programlisting>new Textbox().setContraint("/.+@.+\\.[a-z]+/");</programlisting>
<itemizedlist>
<listitem>
<para>允许混合使用正则表达式与其他约束，但要用逗号分隔。 </para>
</listitem>
</itemizedlist>
<para>`如果你想为应用程序展示定制的信息，而不是默认的，可以添加约束及验证失败后的信息，用</para>
<orderedlist>
<para>冒号隔开。</para>
</orderedlist>
<para>如果你想为应用程序展示定制的信息，而不是默认的，可以添加约束及验证失败后的信息，用</para>
<para>冒号隔开。</para>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/: e-mail address only"/&gt;&#13;&lt;datebox constraint="no empty, no future: now or never"/&gt;&#13;</programlisting>
<para>[注]：</para>
<orderedlist>
<listitem>
<para>如果指定了错误信息，那么它必须为末尾元素，且以冒号开始。</para>
</listitem>
<listitem>
<para>为了支持多语言，你可以使用l函数，就像在国际化一章中描述的那样。</para>
</listitem>
</orderedlist>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/: ${c:l('err.email.required')}"/&gt;</programlisting></sect3><sect3><title>定制属性</title>
<para>如果你想使用更复杂的约束，可以指定一个实现了<code>org.zkoss.zul.Constraint</code>接口的对象。</para>
<programlisting>&lt;window title="Custom Constraint"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;Constraint ctt = new Constraint() {&#13;   public void validate(Component comp, Object value) throws WrongValueException {&#13;      if (value =e= null || ((Integer)value).intValue() &lt; 100)&#13;             throw new WrongValueException(comp, "At least 100 must be specified");&#13;   }&#13;}&#13;   ]]&gt;&lt;/zscript&gt;&#13;   &lt;intbox constraint="${ctt}"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>你可以在一个Java类中实现你的约束，例如<code>my.EmailValidator</code>，那么</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.dsp.tld" prefix="c"?&gt;&#13;&lt;textbox constraint="${c:new('my.EmailValidator')}"/&gt;&#13;</programlisting><sect4><title>
<code>org.zkoss</code>
<code>.zk.ui.WrongValueException</code>
</title>
<para>在上面的例子中，我们使用了<code>org.zkoss.zk.ui.WrongValueException</code>来表述一个错误。</para>
<para>就像描绘的那样，你需要指定两个参数，第一个为引起错误的组件，第二个为错误信息。你可以随时丢出这个异常，如下面，当<code>onChange</code>事件被接收时：</para>
<programlisting><inlinegraphic align="right" fileref="img/7-1-7-4a.png"/>&lt;textbox&gt;&#13;   &lt;attribute name="onChange"&gt;&#13;      if (!self.value.equals("good")) {&#13;             self.value = "try again";&#13;             throw new WrongValueException(self, "Not a good answer!");&#13;      }&#13;   &lt;/attribute&gt;&#13;&lt;/textbox&gt;&#13;</programlisting></sect4><sect4><title>定制方式显示错误信息</title>
<para>通过实现<code>org.zkoss.zul.CustomConstraint</code>及<code>Constraint</code>接口，你可以提供定制的外观，以代替前面例子中的默认错误框。<code>CustomConstraint</code> 有一个<code>showCustomError</code>方法，当抛出异常或验证失败时，此方法会被调用。下面是一个例子：</para>
<programlisting>&lt;window title="Custom Constraint" border="normal"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;class MyConst implements Constraint, CustomConstraint {&#13;   //Constraint//&#13;   public void validate(Component comp, Object value) {&#13;      if (value == null || ((Integer)value).intValue() &lt; 100)&#13;             throw new WrongValueException(comp, "At least 100 must be specified");&#13;   }&#13;   //CustomConstraint//&#13;   public void showCustomError(Component comp, WrongValueException ex) {&#13;      errmsg.setValue(ex != null ? ex.getMessage(): "");&#13;   }&#13;}&#13;Constraint ctt = new MyConst();&#13;   ]]&gt;&lt;/zscript&gt;&#13;   &lt;hbox&gt;&#13;      Enter a number at least 100:&#13;      &lt;intbox constraint="${ctt}"/&gt;&#13;      &lt;label id="errmsg"/&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting><graphic fileref="img/7-1-7-4b.png" align="center"/></sect4><sect4><title>提高响应能力</title>
<para>在客户端验证更多的约束可以提高能力。你得实现<code>org.zkoss.zul.ClientConstraint</code>及<code>Constraint</code>接口来实现此功能。如果完成了客户端的所有验证，可以通</para>
<para> <code>isClientComplete</code>方法返回true，那么将不会有回调服务。</para>
<para>你也可以使用纯JavaScript代码来定制一个错误信息的显示，需要提供一个叫作<code>Validate_errorbox</code>的函数。如下：</para>
<programlisting>&lt;script type="text/javascript"&gt;&lt;![CDATA[&#13;   //Running at the browser&#13;   window.Validate_errorbox = function (id, boxid, msg) {&#13;      var html = '&lt;div style="display:none;position:absolute" id="'&#13;             +boxid+'"&gt;'+zk.encodeXML(msg, true)+'&lt;/div&gt;';&#13;      document.body.insertAdjacentHTML("afterbegin", html);&#13;      return $e(boxid);   }&#13;]]&gt;&lt;/script&gt;&#13;</programlisting>
<para>[注]: <code>script</code>指定了在浏览器端运行的脚本代码类型, 而<code>script</code> 在服务器端运行的脚本代码类型.</para>
<para>[注]:如果也实现了<code>CustomConstraint</code>，那么由于在服务端完成了所有的验证，所以<code>ClientConstraint</code>会被忽略。换言之， 如果你想使用<code>ClientConstraint</code>提高响应能力，重写<code>Validate_errorbox</code>是定制错误信息显示的唯一方式。</para></sect4></sect3><sect3><title>
<code>onChange</code>事件</title>
<para>当用户已经改变了输入控件的内容，输入控件会使用<code>onChange</code>事件来通知应用程序。</para>
<para>注意，当<code>onChange</code>的事件监听器被调用时，其值已经被设定。因此，如果当你想为<code>onChange</code>的事件监听器注入一个非法值时已经晚了，除非你适当地还原其值。建议使用在定制约束(Custom Constraints)章节描述的约束。</para></sect3><sect3><title>
<code>onChanging</code>事件</title>
<para>当用户正在改变了输入控件的内容时， 输入控件会使用<code>onChanging</code>事件来通知应用程序</para>
<para>注意，当<code>onChanging</code>的事件监听器被调用时，其值并没有被设定。换言之，<code>value</code>属性原来的值。为了获取用户输入的内容，你得按如下方式访问事件的<code>value</code>属性。</para>
<programlisting>&lt;grid&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;The onChanging textbox: &#13;         &lt;textbox onChanging="copy.value = event.value"/&gt;&lt;/row&gt;&#13;      &lt;row&gt;Instant copy:&#13;         &lt;textbox id="copy" readonly="true"/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&lt;/grid&gt;&#13;</programlisting>
<para>由于用户还没有更改，所以<code>onChanging</code>的事件监听器非法值就太早了。建议使用在定制约束章节描述的约束。</para></sect3></sect2><sect2><title>日历</title>
<para>calendar 展示了一个日历并允许用户从中选择一个日期。</para>
<programlisting>&lt;hbox&gt;&#13;    &lt;calendar id="cal" onChange="in.value = cal.value"/&gt;&#13;<graphic fileref="img/7-1-8.png" align="right"/>    &lt;datebox id="in" onChange="cal.value = in.value"/&gt;&#13;&lt;/hbox&gt;</programlisting><sect3><title>
<code>value</code> 属性和<code>onChange</code>事件</title>
<para>就像输入控件，<code>calendar</code>提供了<code>value</code>属性来开发人员设置及获取选中的日期。此外如果有必要的话，开发人员还可以监听<code>onChange</code>事件以便立即加以处理。</para></sect3><sect3><title>
<code>compact</code>属性</title>
<para>calendar 支持两种不同的布局，可以通过<code>compact</code>属性控制。</para>
<programlisting>&lt;calendar compact="true"/&gt;&#13;<graphic align="right" fileref="img/7-1-8-2.png"/></programlisting>
<para>默认值为本地。</para></sect3></sect2><sect2><title>进度条</title>
<para>progress 为指示任务完成进度的棒形图。其<code>value</code>属性必须在<code>0</code>到<code>100</code>的范围内取值。</para>
<programlisting>&lt;progressmeter value="10"/&gt;&#13;<graphic fileref="img/7-1-9.png" align="right"/></programlisting></sect2><sect2><title>Slider</title>
<para>Slider以滚动(scrolling) 方式来指定值。 </para>
<programlisting>&lt;slider id="slider" onScroll="Audio.setVolume(slider.curpos)"/&gt;&#13;<graphic fileref="img/7-1-10.png" align="right"/></programlisting>
<para>slider接收在0至100范围内的值。你可以使用<code>maxpos</code> 属性来改变允许的最大值 。</para></sect2><sect2><title>计时器</title>
<para>timer是一个不可见的组件，用于在指定的时刻或一段时间内将<code>onTimer</code>事件发送到服务器。你可以使用 <code>start</code> 和<code>stop</code>方法来控制 <code>timer</code>。</para>
<programlisting>&lt;window title="Timer demo" border="normal"&gt;&#13;   &lt;label id="now"/&gt;&#13;   &lt;timer id="timer" delay="1000" repeats="true"&#13;      onTimer="now.setValue(new Date().toString())"/&gt;&#13;<inlinegraphic fileref="img/7-1-11.png" align="right"/>   &lt;separator bar="true"/&gt;&#13;   &lt;button label="Stops timer" onClick="timer.stop()"/&gt;&#13;   &lt;button label="Starts timer" onClick="timer.start()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>分页</title>
<para>paging组件用于将一段很长的内容分成多个页面。例如, 假定有100个项目，每次显示20个项目，那么可以按如下方式使用 paging 组件。 </para>
<programlisting>&lt;paging totalSize="100" pageSize="20"/&gt;&#13;<graphic fileref="img/7-1-12.png" align="right"/></programlisting>
<para>然后，当用户点击一个链接时，<code>onPaging</code>事件会和<code>org.zkoss.zul.event.PagingEvent</code>的一个实例被送到paging组件。可以为paging组件添加一个监听器以决定100个项目的哪部分是可见的。</para>
<para/>
<programlisting>&lt;paging id="paging"/&gt;&#13;&lt;zscript&gt;&#13;   List result = new SearchEngine().find("ZK");&#13;      //assume SearchEngine.find() will return a list of items.&#13;   paging.setTotalSize(result.size());&#13;   paging.addEventListener("onPaging", new EventListener() {&#13;      public void onEvent(Event event) {&#13;             int pgno = event.getPaginal().getActivePage();&#13;             int ofs = pgno * event.getPaginal().getPageSize();&#13;             new Viewer().redraw(result, ofs, ofs + event.getPaginal().getPageSize() - 1);&#13;                //assume redraw(List result, int b, int e) will display&#13;                //from the b-th item to the e-th item&#13;      }&#13;   });&#13;&lt;/zscript&gt;&#13;</programlisting><sect3><title>List Boxes 和 Grids的Paging</title>
<para>
<code>listbox</code> 和 <code>grid</code>组件本身支持paging，所以不必像上面一样明确地为其指定paging 组件，除非你想指定不同的布局或者使用一个paging组件控制多个<code>listbox</code> 和 <code>grid</code>。</para>
<para>参考网格章节获取更多的细节。</para></sect3></sect2></sect1><sect1><title>窗口</title>
<para>window , 就像HTML的 DIV 标签, 用于为组件分组。不同于其它的组件， window 有如下的特点。</para>
<orderedlist>
<listitem>
<para>window是一个ID空间的所有者。window可以包含任意组件， 包括其自身。如果通过标识指定，可以使用<code>getFellow</code>方法来找到它。</para>
</listitem>
<listitem>
<para>window 可以被重叠，弹出和嵌入(overlapped, popup, and embedded)。</para>
</listitem>
<listitem>
<para>window 可以是对话框(modal dialog)。</para>
</listitem>
</orderedlist><sect2><title>标题</title>
<para>window可以有一个title，一个caption 和 一个 border。标题(title) 是 <code>title</code> 属性指定的。 标题 (caption)是 <code>caption</code> 组件声明的。 <code>caption</code> 组件的所有子组件都会出现在 title 的右边。</para>
<programlisting>&lt;window title="Demo" border="normal" width="350px"&gt;&#13;<inlinegraphic fileref="img/7-2-1a.png" align="right"/>   &lt;caption&gt;&#13;      &lt;toolbarbutton label="More"/&gt;&#13;      &lt;toolbarbutton label="Help"/&gt;&#13;   &lt;/caption&gt;&#13;   &lt;toolbar&gt;&#13;      &lt;toolbarbutton label="Save"/&gt;&#13;      &lt;toolbarbutton label="Cancel"/&gt;&#13;   &lt;/toolbar&gt;&#13;   What is your favorite framework?&#13;   &lt;radiogroup&gt;&#13;      &lt;radio label="ZK"/&gt;&#13;      &lt;radio label="JSF"/&gt;&#13;   &lt;/radiogroup&gt;&#13;    &lt;/window&gt;&#13;</programlisting><para/>
<para/><para/><para>你可以为caption 指定标签和图像，其外观如下。</para>
<programlisting>&lt;window id="win" title="Main" border="normal" width="200px"&gt;&#13;   &lt;caption image="/img/coffee.gif" label="Hi there!"/&gt;&#13;   &lt;checkbox label="Hello, World!"/&gt;&#13;&lt;/window&gt;&#13;<graphic fileref="img/7-2-1b.png" align="right"/></programlisting><para/></sect2><para/><sect2><title>
<code>closables</code>属性</title>
<para>若将<code>closable</code>属性值设为true，close 按钮会显示在window 组件中，这样可以关闭此window 。一旦用户点击了close按钮，onClose事件会被送到window。这样此事件会被window的<code>onClose</code>方法处理。那么，<code>onClose</code>在默认情况下会把 window 自身移除。</para>
<para>你也可以重定义此方法，使其做你想做的事情。或者，注册一个监听器来改变默认的行为。例如，你可以选择隐藏而不是关闭。</para>
<programlisting>&lt;window closable="true" title="Detach on Close" border="normal" width="200px"&#13;onClose="self.visible = false; event.stopPropagation();"&gt;&#13;   In this example, this window hides itself when the close button is clicked.&#13;&lt;/window&gt;&#13;<graphic fileref="img/7-2-2.png" align="right"/></programlisting>
<para>注意，必须调用<code>event.stopPropagation</code>()阻止Window.onClose()被调用。</para>
<para>[提示]： 若为一弹出window，当由于用户点击window的外围或按下ESC键关闭此弹出<code>window</code>时， <code>onOpen</code>事件(open=false) 会被送至 window 。这会有些困惑，但是<code>onClose</code>被送至服务器来询问移除还是隐藏window。默认情况下，window会被移除。当然，应用程序可以重定义此方法并且让其做任何事情，就像上面描述的一样。另外，<code>onOpen</code>是一个通知(notification)。此事件被送出以通知应用程序客户端已经隐藏了window 。应用程序并不能阻止window被隐藏，或改变被移除的行为。</para>
<para/></sect2><sect2><title>
<code>sizable</code>属性</title>
<para>如果你允许用户重定义window的大小，可以将<code>sizable</code>属性设为<code>true</code> 。这样用户可以拖曳边框来改变<code>window</code>的尺寸。</para>
<programlisting>&lt;window id="win" title="Sizable Window" border="normal" width="200px" sizable="true"&gt;&#13;   This is a sizable window.&#13;   &lt;button label="Change Sizable" onClick="win.sizable = !win.sizable"/&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect3><title>
<code>onSize</code>事件</title>
<para>一旦用户改变了window 的尺寸，onSize事件及的org.zkoss.zul.event.SizeEvent一个实例会被送出。注意改变window的大小是在onSize事件被送出前发生的。换言之，事件就像一个通知那样服务。当然，你可以在事件监听器中做任何事情。</para>
<para>[注]: 如果用户拖曳上边框或左边框，onMove事件也会被送出，因为位置也改变了。</para></sect3></sect2><sect2><title>样式类</title>
<para>Zk的window支持四种样式类：<code>embedded</code>
<code>，</code>
<code>overlapped</code>
<code>，</code>
<code>popup</code> 和 <code>wndcyan</code>。当然，你可以添加更多。</para>
<para>默认情况下，<code>sclass</code>属性与 window 模式是一样的，所以不同模式window 的外观是不同的。要想改变外观，可以按下例描述的那样简单的为 <code>sclass</code> 属性指定一个值。</para>
<programlisting>&lt;hbox&gt;&#13;   &lt;window title="Embedded Style" border="normal" width="200px"&gt;&#13;      Hello, Embedded!&#13;   &lt;/window&gt;&#13;   &lt;window title="Cyan Style" sclass="wndcyan" border="normal" width="200px"&gt;&#13;      Hello, Cyan!&#13;   &lt;/window&gt;&#13;   &lt;window title="Popup Style" sclass="popup" border="normal" width="200px"&gt;&#13;      Hello, Popup!&#13;   &lt;/window&gt;&#13;   &lt;window title="Modal Style" sclass="modal" border="normal" width="200px"&gt;&#13;      Hello, Modal!&#13;   &lt;/window&gt;&#13;&lt;/hbox&gt;&#13;</programlisting><graphic fileref="img/7-2-4.png" align="center"/></sect2><sect2><title>
<code>contentStyle</code>属性</title>
<para>通过指定<code>contentStyle</code>属性可以改变window中内容块的亲自体会(look and feel)。</para>

<programlisting>&lt;window title="My Window" border="normal" width="200px" contentStyle="background:yellow"&gt;&#13;   Hello, World!&#13;&lt;/window&gt;&#13;<graphic fileref="img/7-2-5.png" align="right"/></programlisting><sect3><title>滚动窗口</title>
<para>
<code>contentType</code>的一个典型应用是使一个 <code>window</code>变得可滚动。</para>
<programlisting>&lt;window id="win" title="Hi" width="150px" height="100px" contentStyle="overflow:auto" border="normal"&gt;&#13;This is a long line to spead over several lines, and more content to display.&#13;Finally, the scrollbar becomes visible.&#13;This is another line.&#13;&lt;/window&gt;&#13;&#13;<graphic fileref="img/7-2-5-1.png" align="right"/></programlisting></sect3></sect2><sect2><title>边框</title>
<para>
<code>border</code>属性是否显示window 的边框。默认的样式仅支持<code>normal</code> 和 <code>none</code>。默认为<code>none</code>。</para>
<para>当然，你可以提供额外的样式类(style class)。例如，</para>
<programlisting>&lt;zk&gt;&#13;   &lt;style&gt;&#13;   div.wc-embedded-dash {&#13;   padding: 2px; border: 3px dashed #aab;&#13;   }&#13;   &lt;/style&gt;&#13;   &lt;window title="My Window" border="dash" width="200px"&gt;&#13;   Hello, World!&#13;   &lt;/window&gt;&#13;&lt;/zk&gt;&#13;<graphic fileref="img/7-2-6.png" align="right"/></programlisting>
<para>
<code>wc-embedded-dash</code>定义了window 内框(inner box)的样式。样式类通过连锁(concatenating)<code>wc</code>
<footnote>
<para>
<code>wc</code> 为 window 内容, 而 <code>wt</code> 为 window title.</para>
</footnote>命名，<code>sclass</code>属性和border属性是一起的，并且以横线(-)分开它们。在此例中，由于此窗口是嵌入式的(embedded)，所以为<code>sclass</code>为<code>embedded</code> ，而且没有明确的<code>sclass</code>被指定(所以使用了默认的<code>sclass</code>)。</para></sect2><sect2><title>重叠，弹出，Modal，标示和嵌入</title>
<para>window有四种模式：重叠，弹出，Modal，标示和嵌入。嵌入为默认模式。可以使用<code>doOverlapped</code>
<code>，</code> <code>doPopup</code>
<code>，</code>
<code>doModal</code>
<code>，</code>
<code>doHighlighted</code>和 <code>doEmbedded</code>方法来改变模式。如下，</para>
<programlisting>&lt;zk&gt;&#13;   &lt;window id="win" title="Hi!" border="normal" width="200px"&gt;&#13;      &lt;caption&gt;&#13;             &lt;toolbarbutton label="Close" onClick="win.setVisible(false)"/&gt;&#13;      &lt;/caption&gt;&#13;      &lt;checkbox label="Hello, Wolrd!"/&gt;&#13;   &lt;/window&gt;&#13;    &#13;   &lt;button label="Overlap" onClick="win.doOverlapped();"/&gt;&#13;   &lt;button label="Popup" onClick="win.doPopup();"/&gt;&#13;   &lt;button label="Modal" onClick="win.doModal();"/&gt;&#13;   &lt;button label="Embed" onClick="win.doEmbedded();"/&gt;&#13;   &lt;button label="Highlighted" onClick="win.doHighlighed();"/&gt;&#13;&lt;/zk&gt;&#13;</programlisting><sect3><title>嵌入</title>
<para>嵌入window 和其它组件一起被插入在文字之间。在这种模式中，你不能改变window的位置，因为其位置是由浏览器决定的。</para></sect3><sect3><title>重叠</title>
<para>重叠window 和其它组件是重叠的，这样用户可以到处拖曳此window，并且开发人员可以使用<code>setLeft</code>和<code>setTop</code>方法来设置其位置。 </para>
<para>除了<code>doOverlapped</code>，你也可以按如下方式使用<code>mode</code>属性，</para>
<programlisting>&lt;window title="My Overlapped" width="300px" mode="overlapped"&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect3><sect3><title>弹出</title>
<para>弹出window 与重叠window类似，除了弹出window 在用户点击任一组件(不包括弹出window本身及其所有子组件)时会自动关闭。就像其名字一样，它被设计成实现弹出window。</para></sect3><sect3><title>Modal</title>
<para>modal window (亦称对话框，modal dialog)与重叠window 类似，除了modal window可以挂起执行，直到<code>endModal</code>, <code>doEmbedded</code>, <code>doOverlapped</code>, <code>doHighlighted</code>, 和 <code>doPopup</code>方法中的一个被调用。</para>
<para>除了挂起执行，modal window还可以使不属于其的组件失效。</para>
<para>modal window会自动位于浏览器的中央，你可以控制它的位置。</para></sect3><sect3><title>标示</title>
<para>标示window 与重叠window 类似，除了标示window 的视觉效果与modal window相同。换言之，标示window 位于浏览器的中央，并且使不属于其的组件失效。</para>
<para>但是，标示window 不会挂起执行。就像重叠window，一旦模式改变，执行会继续。例如，仅当win1被关闭后f1()才会被调用，而在win2变为标示后g()被立即调用。</para>
<programlisting>win1.doModal(); //the execution is suspended until win1 is closed&#13;f1();&#13;&#13;win2.doHighlighted(); //the execution won't be suspended&#13;g1()&#13;</programlisting>
<para>如果你不喜欢挂起事件处理线程，可以使用标示window 代替modal window。参考高级特性(Advanced Features)一章中关于使用Servlet线程处理事件(Use the Servlet Thread to Process Events)的部分。</para></sect3><sect3><title>Modal窗口和事件监听器</title>
<para>不同于其它的模式，你仅能在事件监听器中将window 放置在modal模式中。换言之，你可以在事件监听器中调用<code>doModal</code>()或 <code>setMode</code>("<code>modal</code>")。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;window id="wnd" title="My Modal" visible="false" width="300px"&gt;&#13;      &lt;button label="close" onClick="wnd.visible = false"/&gt;&#13;   &lt;/window&gt;&#13;   &lt;button label="do it" onClick="wnd.doModal()"/&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>另外，如果在组件创建阶段(Component Creation Phase)<footnote>
<para>参考组件活动周期一章.</para>
</footnote> 执行，下面的例子是错误的。</para>
<programlisting>//t1.zul&#13;&lt;window title="My Modal" width="300px" closable="true" mode="modal"&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<graphic fileref="img/7-2-7-6.png" align="center"/>如果在浏览器中直接打开，将会导致如下结果<footnote>
<para>假定使用Tomcat.</para>
</footnote> 。</para>
<para>下面的代码会导致相同的结果。</para>
<programlisting>//t2.zul&#13;&lt;window title="My Modal" width="300px" closable="true"&gt;&#13;   &lt;zscript&gt;&#13;          self.doModal();&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>如果你需要在页面加载时创建一个modal window，可以按如下方式提交<code>onModal</code>事件。</para>
<programlisting>//t3.zul&#13;&lt;window title="My Modal" width="300px" closable="true"&gt;&#13;   &lt;zscript&gt;&#13;   Events.postEvent("onModal", self, null);&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>[注]: 下面的代码会正确执行，甚至<code>t1</code>.<code>zul</code>将window直接设置为modal模式(就像上面一样)。为什么呢？它在一个事件监听器中执行(<code>onClick</code>)。 </para>
<programlisting>&lt;button label="do it"&gt;&#13;   &lt;attribute name="onClick"&gt;&#13;   Executions.createComponents("t1.zul", null, null);&#13;      //it loads t1.zul in this event listener for onClick&#13;   &lt;/attribute&gt;&#13;&lt;/button&gt;&#13;</programlisting></sect3></sect2><sect2><title>
<code>position</code>属性</title>
<para>除了<code>left</code>和<code>top</code>属性，你可以使用<code>position</code>属性来控制重叠/弹出/modal window 的位置。例如，下面的代码片断将window置于右下角。 </para>
<programlisting>&lt;window width="300px" mode="overlapped" position="right,bottom"&gt;&#13;...&#13;</programlisting>
<para>
<code>position</code>属性可以是下列常量的集合，各常量之间以逗号 (,)隔开。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>常量</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>center</code>
</para>
</entry>
<entry>
<para>将winow组件放置在中间。若制定了<code>left</code>和<code>right</code>属性，则为垂直中心。若指定了<code>top</code>和<code>buttom</code>属性，则为水平中心。若均未指定，则以为着在两个方向均居中。</para>
<para>
<code>left</code>和<code>top</code> 属性被忽略。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>left</code>
</para>
</entry>
<entry>
<para>将winow组件在左边。</para>
<para>left属性被忽略。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>right</code>
</para>
</entry>
<entry>
<para>将winow组件在右边。</para>
<para>
<code>left</code>属性被忽略。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>top</code>
</para>
</entry>
<entry>
<para>将winow组件在顶部。</para>
<para>
<code>top</code>属性被忽略。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>bottom</code>
</para>
</entry>
<entry>
<para>将winow组件在底部。</para>
<para>
<code>top</code>属性被忽略。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>默认情况下，其值为null。也就是，重叠和弹出window 的位置由<code>left</code>和<code>top</code>决定，而modal window居中。</para></sect2><sect2><title>通用对话框</title>
<para>XUL组件集支持下列通用对话框来简化一些通用任务。</para><sect3><title>消息框</title>
<para>
<code>org.zkoss.zul.Messagebox</code>类提供了一套功能来显示消息框。典型应用是当发生错误时警告用户，或促使用户作出决定。</para>
<programlisting>if (Messagebox.show("Remove this file?", "Remove?", Messagebox.YES | Messagebox.NO,&#13; Messagebox.QUESTION) == Messagebox.YES) {&#13;   ...//remove the file&#13;}&#13;</programlisting>
<para>由于警告用户有误是很平常的，所以一个称为<code>alert</code>的全局函数被加进了zscript。<code>alert</code>函数是<code>Messagebox</code>类中<code>show</code>方法的一个捷径。换言之，下列两条语句是等价的。</para>
<programlisting>alert("Wrong");&#13;Messagebox.show("Wrong");&#13;</programlisting>
<para>注意<code>Messagebox</code>为一个modal window，所以它也受相同的约束：仅在事件监听器中是可执行的。因此，下列代码将会失败。参考上面的Modal窗口和事件监听器(Modal Windows and Event Listeners)章节获取更多的描述。</para>
<programlisting>&lt;window title="Messagebox not allowed in paging loading"&gt;&#13;   &lt;zscript&gt;&#13;   //failed since show cannot be called in paging loading&#13;   if (Messagebox.show("Redirect?", "Redirect?",&#13;   Messagebox.YES | Messagebox.NO, Messagebox.QUESTION) == Messagebox.YES)&#13;      Executions.sendRedirect("another.zul");&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect3><sect3><title>文件上传对话框</title>
<para>
<code>org.zkoss.zul.Fileupload</code>类提供了一套功能用以帮助用户向服务器上传文件。一旦调用了get方法，浏览器端会显示一个文件上传对话框来促使用户指定要上传的文件。直到用户已经上传了文件或点击了放弃按钮其才会返回。</para>
<programlisting>&lt;window title="Fileupload Demo" border="normal"&gt;&#13;   &lt;image id="image"/&gt;&#13;   &lt;button label="Upload"&gt;&#13;      &lt;attribute name="onClick"&gt;{&#13;             Object media = Fileupload.get();&#13;             if (media instanceof org.zkoss.image.Image)&#13;                image.setContent(media);&#13;             else if (media != null)&#13;                Messagebox.show("Not an image: "+media, "Error",&#13;               Messagebox.OK, Messagebox.ERROR);&#13;      }&lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/window&gt;&#13;</programlisting><graphic fileref="img/7-2-9-2a.png" align="center"/><sect4><title>一次上传多个文件</title>
<para>如果你允许一次上传多个文件，可以按如下方式指定允许数字的最大值。</para>
<programlisting>&lt;window title="fileupload demo" border="normal"&gt;&#13;   &lt;button label="Upload"&gt;&#13;      &lt;attribute name="onClick"&gt;&lt;![CDATA[{&#13;   Object media = Fileupload.get(5);&#13;   if (media != null)&#13;      for (int j = 0; j &lt; media.length; ++j) {&#13;             if (media[j] instanceof org.zkoss.image.Image) {&#13;                Image image = new Image();&#13;                image.setContent(media[j]);&#13;                image.setParent(pics);&#13;             } else if (media[j] != null) {&#13;                Messagebox.show("Not an image: "+media[j], "Error",&#13;<inlinegraphic fileref="img/7-2-9-2b.png" align="right"/>                       Messagebox.OK, Messagebox.ERROR);&#13;         }&#13;      }&#13;      }]]&gt;&lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;   &lt;vbox id="pics"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect4></sect3><sect3><title>
<code>fileupload</code>组件</title>
<para>fileupload不是一个modal对话框。它是一个组件，所以fileupload可以和其它组件一起插入文字之间。</para>
<para>[注]:除了静态的<code>get</code>方法用于打开文件上传对话框，<code>org.zkoss.zul.Fileupload</code>本身即为一个组件。 即所谓的<code>fileuplod</code> 组件。</para>
<para>例如，</para>

<programlisting>&lt;image id="img"/&gt;&#13;<inlinegraphic fileref="img/7-2-9-3.png" align="right"/>Upload your hot shot:&#13;&lt;fileupload onUpload="img.setContent(event.media)"/&gt;&#13;</programlisting><sect4><title>
<code>onUpload</code>事件</title>
<para>当按下上传按钮后，<code>onUpload</code>事件及<code>org.zkoss.zk.ui.event.UploadEvent</code>事件的一个实例被送出。你可以使用<code>getMedia</code> 或 <code>getMedias</code>方法获取上传文件的内容。</para>
<para>注意<code>getMedia</code> 和 <code>getMedias</code>方法返回null即表示没有文件被指定但上传按钮被按下了。</para></sect4><sect4><title>
<code>OnClose</code>事件</title>
<para>除了<code>onUpload</code>，<code>onClose</code>事件也被送出以通知上传按钮还是放弃按钮被按下。默认情况下，如果监听了此事件来实现定制行为，<code>fileupload</code>组件会失效，也就是说，所有的域会被清空或重设。</para></sect4></sect3><sect3><title>文件下载对话框</title>
<para>
<code>org</code>
<code>.zkoss.zul.Filedownload</code>类提供了一套功能用以帮助用户从服务器下载文件。不同于<code>iframe</code>组件在浏览器窗口显示文件，如果其中的一个<code>save</code>方法被调用，则文件下载对话框会显示在浏览器端。然后，用户可以指定在本地文件系统中的存储路径。</para>
<programlisting>&lt;button label="Download download.html"&gt;&#13;<inlinegraphic fileref="img/7-2-9-4.png" align="right"/>   &lt;attribute name="onClick"&gt;{&#13;   java.io.InputStream is =&#13; desktop.getWebApp().getResourceAsStream("/test/download.html");&#13;   if (is != null)&#13;      Filedownload.save(is, "text/html", "download.html");&#13;   else&#13;      alert("/test/download.html not found");&#13;   }&lt;/attribute&gt;&#13;&lt;/button&gt;&#13;&#13;</programlisting></sect3></sect2></sect1><sect1><title>箱式模型</title>
<para>组件： <code>vbox</code>
<code>，</code>
<code>hbox</code>
<code>和</code>
<code>box</code>
<code>。</code>
</para>
<para>XUL的箱式模型用于将显示部分分割成一系列的box。Box 内的组件需要将它们定位成水平或垂直的。通过一系列的box及 separator，可以控制视觉表现的布局(visual representation)。</para>
<para>box可以将其子组件布局成两种方位，水平的或垂直的。水平box可以将其子组件排成一条线，而垂直box可以将其子组件定位成垂直方向。你可以将其想象成HTML 表格的行或里列。</para>
<para>下面是一些例子。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;vbox&gt;&#13;      &lt;button label="Button 1"/&gt;&#13;      &lt;button label="Button 2"/&gt;&#13;   &lt;/vbox&gt;&#13;<inlinegraphic fileref="img/7-3.png" align="right"/>   &lt;hbox&gt;&#13;      &lt;button label="Button 3"/&gt;&#13;      &lt;button label="Button 4"/&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>
<code>hbox</code>组件用于创建水平box。放置在<code>hbox</code>内的组件会被水平排成一行。<code>vbox</code>组件用于创建垂直box。添加于其内的组件会被垂直的排成一列。</para>
<para>也有一个一般的box组件，默认水平布局，这意味着等价于<code>hbox</code>。但是，可以使用<code>orient</code>属性用于控制box的布局方位。你可以将其赋值为<code>horizontal</code>以创建一个水平box，或<code>vertical</code>以创建一个垂直box。</para>
<para>因此下面的两行语句是等价的：</para>
<programlisting>&lt;vbox&gt;&#13;&lt;box orient="vertical"&gt;&#13;</programlisting>
<para>在box内可以添加任意多的组件，包括其它的box。例如水平box，每一个新添的组件都会被放置在前一个的右边。组件是不会包裹(wrap)的，所以添加多少组件，window就会有多宽。相似的，每个垂直box中的组件会被置于前一个组件的正下方。</para><sect2><title>
<code>spacing</code>属性</title>
<para>
<code>box</code>控件组件之间的间隙是可以控制的。例如，下面的例子在上边缘与下边缘均放置了<code>5em</code>的间隙。注意：两个输入域的总间隙为<code>10em</code>。</para>
<programlisting>&lt;vbox spacing="5em"&gt;&#13;   &lt;textbox/&gt;&#13;   &lt;datebox/&gt;&#13;&lt;/vbox&gt;&#13;</programlisting>
<para>另一个例子是使用无间隙(zero spacing)的有趣布局。</para>
<programlisting>&lt;window title="Box Layout Demo" border="normal"&gt;&#13;   &lt;hbox spacing="0"&gt;&#13;<inlinegraphic fileref="img/7-3-1.png" align="right"/>      &lt;window border="normal"&gt;0&lt;/window&gt;&#13;      &lt;vbox spacing="0"&gt;&#13;             &lt;hbox spacing="0"&gt;&#13;                &lt;window border="normal"&gt;1&lt;/window&gt;&#13;                &lt;window border="normal"&gt;2&lt;/window&gt;&#13;                &lt;vbox spacing="0"&gt;&#13;                       &lt;window border="normal"&gt;3&lt;/window&gt;&#13;                   &lt;window border="normal"&gt;4&lt;/window&gt;&#13;                &lt;/vbox&gt;&#13;             &lt;/hbox&gt;&#13;             &lt;hbox spacing="0"&gt;&#13;                &lt;vbox spacing="0"&gt;&#13;                   &lt;window border="normal"&gt;5&lt;/window&gt; &#13;                   &lt;window border="normal"&gt;6&lt;/window&gt;&#13;                &lt;/vbox&gt;&#13;                &lt;window border="normal"&gt;7&lt;/window&gt;&#13;                &lt;window border="normal"&gt;8&lt;/window&gt;&#13;                &lt;window border="normal"&gt;9&lt;/window&gt;&#13;             &lt;/hbox&gt;&#13;      &lt;/vbox&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>
<code>widths</code> 和 <code>heights</code> 属性</title>
<para>使用<code>widths</code>属性可以指定<code>hbox</code>每个元素(cell)的宽度，如下。</para>
<programlisting>&lt;hbox width="100%" widths="10%,20%,30%,40%"&gt;&#13;   &lt;label value="10%"/&gt;&#13;   &lt;label value="20%"/&gt;&#13;   &lt;label value="30%"/&gt;&#13;   &lt;label value="40%"/&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>其值为宽度值的列表，以逗号分隔。若未指定其值，则不会为相应的元素产生宽度，同时真实的宽度值被送至浏览器。</para>
<para>类似的，你可以使用<code>heights</code>属性指定<code>vbox</code>每个元素的高度。实际上，由于box的方向是水平或垂直的依赖于<code>orient</code>属性，所以这两个属性是相同的。</para></sect2><sect2><title>分割器</title>
<para>组件: <code>splitter</code>.</para>
<para>或许有些时候你想把一个window分成两个部分，这样用户可以改变这些部分的大小。可以使用spliter组件来实现此功能。此组件在两部分间创建一个细小的bar，可以允许用户修改任一边的大小。</para>
<para>splitter必须放置在box内。当splitter放置在水平box(<code>hbox</code>)内时，它将会允许水平的改变大小。当splitter放置在处置box(<code>vbox</code>)内时，它将会允许水平的改变大小。例如，</para>
<para>
<graphic fileref="img/7-3-3.png"/>
</para>
<para>代码如下：</para>
<programlisting>&lt;hbox spacing="0" style="border: 1px solid grey" width="100%"&gt;&#13;   &lt;vbox height="200px"&gt;&#13;      Column 1-1: The left-top box. To know whether a splitter&#13;      is collapsed, you can listen to the onOpen event.&#13;      &lt;splitter collapse="after"/&gt;&#13;      Column 1-2: You can enforce to open or collapse programming&#13;      by calling setOpen method.&#13;   &lt;/vbox&gt;&#13;   &lt;splitter collapse="before"/&gt;&#13;   Column 2: Whether a splitter allows users to open or collapse&#13;   depending on the collapse attribue.&#13;&lt;/hbox&gt;&#13;</programlisting><sect3><title>
<code>collapse</code>属性</title>
<para>指定当splitter的按键(亦作,按钮)被点击时哪边被折叠。若未指定此属性，splitter是不会引起折叠的(按键不会出现)。 </para>
<para>允许值及它们的意义如下。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>值</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>none</para>
</entry>
<entry>
<para>无折叠发生。</para>
</entry>
</row>
<row>
<entry>
<para>before</para>
</entry>
<entry>
<para>当按下按键时，相同组件内的元素立即在分割器(splitter)前折叠起来，这样其宽度或高度将变为0。</para>
</entry>
</row>
<row>
<entry>
<para>after</para>
</entry>
<entry>
<para>当按下按键时，相同组件内的元素立即在分割器(splitter)后折叠起来，这样其宽度或高度将变为0。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>
<code>open</code>属性</title>
<para>为了知道splitter是否折叠，你可以检查<code>open</code>属性的值(也就是<code>isOpen</code>方法)。为了在程序中打开或折叠，你可以设置<code>open</code>属性的值(也就是<code>setOpen</code>方法)。</para></sect3><sect3><title>
<code>onOpen</code>事件</title>
<para>当一个用户打开或折叠splitter 时，<code>onOpen</code>事件会被送至应用程序。</para></sect3></sect2></sect1><sect1><title>Tab箱</title>
<para>组件: <code>tabbox</code>
<code>，</code>
<code>tabs</code>
<code>，</code>
<code>tab</code>
<code>，</code>
<code>tabpanels</code> 和<code>tabpanel</code>
<code>。</code>
</para>
<para>Tab box 允许开发人员将大量组件分别置于几个组内，且每次只显示一组，这样用户界面不会太难于阅读。在同一时间内仅会显示一组(亦作，面板)。一旦一个隐藏组的tab被点击后，此组的组件变得可见而前一个可见组变得不可见。</para>
<para>tab box的通用语法如下。</para>
<programlisting>&lt;tabbox&gt;&#13;   &lt;tabs&gt;&#13;<inlinegraphic fileref="img/7-4.png" align="right"/>      &lt;tab label="First"/&gt;&#13;      &lt;tab label="Second"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>tabbox</code>: 外层的box ， 包括一系列 tab 和tab面板。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabs</code>: tab的容器， 也就是，tab 组件的集合。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tab</code>: 一个特定的tab。点击tab可以将其tab面板显示在前。你可以将标签或图像置于其中。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabpanels</code>: tab面板的容器，也就是，<code>tabpanel</code> 组件的集合。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabpanel</code>: 单一tab面板的主体。你可以将一组组件放置于一个tab面板内。第一个<code>tabpanel</code> 对应于第一个<code>tab</code>, 第二个<code>tabpanel</code>对应于第二个tab，依次类推。 </para>
</listitem>
</itemizedlist>
<para>当前选中的tab组件由<code>selected</code>属性给出，将其设为<code>true</code>。这样可以给当前选中tab不同的外观，这样可以容易看出被选中。在同一时间内，仅有一个tab的值为<code>true</code>。</para>
<para>通过Java代码有两种方式可以改变选中的tab。如下所示，它们是等价的。</para>
<programlisting>tab1.setSelected(true);&#13;tabbox.setSelectedTab(tab1);&#13;</programlisting>
<para>当然，你可以直接将<code>selected</code>属性设为true。</para>
<programlisting>&lt;tab label="My Tab" selected="true"/&gt;&#13;</programlisting>
<para>若没有tab被选中，则第一个自动被选中。</para><sect2><title>嵌套tab box</title>
<para>tab面板可以包含任何组件包括另一个tab box。</para>
<programlisting>&lt;tabbox&gt;&#13;   &lt;tabs&gt;&#13;<inlinegraphic fileref="img/7-4-1.png" align="right"/>      &lt;tab label="First"/&gt;&#13;      &lt;tab label="Second"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;&#13;      The first panel.&#13;      &lt;tabbox&gt;&#13;             &lt;tabs&gt;&#13;                &lt;tab label="Nested 1"/&gt;&#13;                &lt;tab label="Nested 2"/&gt;&#13;                &lt;tab label="Nested 3"/&gt;&#13;             &lt;/tabs&gt;&#13;             &lt;tabpanels&gt;&#13;                &lt;tabpanel&gt;The first nested panel&lt;/tabpanel&gt;&#13;                &lt;tabpanel&gt;The second nested panel&lt;/tabpanel&gt;&#13;                &lt;tabpanel&gt;The third nested panel&lt;/tabpanel&gt;&#13;             &lt;/tabpanels&gt;&#13;      &lt;/tabbox&gt;&#13;      &lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>The Accordion Tab Boxes</title>
<para>Tab box 支持两种模式(mold)：<code>default</code>和<code>accordion</code>。<code>accordion</code>模式的效果如下。</para>
<programlisting>&lt;tabbox mold="accordion"&gt;&#13;<inlinegraphic fileref="img/7-4-2.png" align="right"/>   &lt;tabs&gt;&#13;      &lt;tab label="First"/&gt;&#13;      &lt;tab label="Second"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>
<code>orient</code>属性</title>
<para>开发人员可以使用<code>orient</code>属性来控制tab的方位。默认为水平布局。你可以将其变为垂直的，效果如下。</para>
<programlisting>&lt;tabbox width="400px" orient="vertical"&gt;&#13;<inlinegraphic fileref="img/7-4-3.png" align="right"/>   &lt;tabs&gt;&#13;      &lt;tab label="A"/&gt;&#13;      &lt;tab label="B"/&gt;&#13;      &lt;tab label="C"/&gt;&#13;      &lt;tab label="D"/&gt;&#13;      &lt;tab label="E"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;This is panel A&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;This is panel B&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;This is panel C&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;This is panel D&lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;This is panel E&lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>
<code>closable</code>属性</title>
<para>将<code>closable</code>属性设置为true，tab会显示关闭按钮，这样用户可以通过点击按钮来关闭tab和相应的tab面板。一旦用户点击了<code>close</code>按钮，<code>onClose</code>事件会被送至tab。此事件会由Tab的<code>onClose</code>方法来处理。然后，默认情况下，<code>onClose</code>方法将tab本身及相应的tab面板移除。</para>
<para>参考window的<code>closable</code>属性 。</para></sect2><sect2><title>Tab面板的随机存取</title>
<para>就像其它组件，你可以仅在tab面板变为可见时加载其内容。最简单的方式是使用<code>fulfill</code>属性来推迟tab面板子组件的创建。</para>
<programlisting>&lt;tabbox&gt;&#13;   &lt;tabs&gt;&#13;      &lt;tab label="Preload" selected="true"/&gt;&#13;      &lt;tab id="tab2" label="OnDemand"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;&#13;   This panel is pre-loaded since no fulfill specified&#13;      &lt;/tabpanel&gt;&#13;      &lt;tabpanel fulfill="tab2.onSelect"&gt;&#13;   This panel is loaded only tab2 receives the onSelect event&#13;      &lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting>
<para>如果你更加喜欢手动创建子组件或自动操纵面板，你可以监听<code>onSelect</code>事件，然后当面板被选中时填充其内容。如下所示，</para>
<programlisting>&lt;tabbox id="tabbox" width="400" mold="accordion"&gt;&#13;   &lt;tabs&gt;&#13;      &lt;tab label="Preload"/&gt;&#13;      &lt;tab label="OnDemand" onSelect="load(self.linkedPanel)"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;&#13;   This panel is pre-loaded.&#13;      &lt;/tabpanel&gt;&#13;      &lt;tabpanel&gt;&#13;      &lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   void load(Tabpanel panel) {&#13;      if (panel != null &amp;&amp; panel.getChildren().isEmpty())&#13;             new Label("Second panel is loaded").setParent(panel);&#13;   }&#13;   ]]&gt;&lt;/zscript&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect2></sect1><sect1><title>网格</title>
<para>组件：<code>grid</code>，<code>columns</code>，<code>column</code>，<code>rows</code> 和 <code>row</code>。</para>
<para>Grid包含排列整齐的组件就像表格一样。在grid内，你可以声明columns，定义了header及column属性；还可以声明 rows，提供内容。</para>
<para>使用rows组件可以声明一套row，即为grid元素的子组件。在rows内可以为每一行添加row组件。你可以 在row元素内添加你想要的内容。每个子元素为指定行的一列。</para>
<para>类似的，columns是由<code>columns</code>组件声明的，其将作为grid的一个子组件。不同于row用于保留每行的内容，column声明了每列的通用属性，例如宽度和对齐方式，还有可选的headers，也就是标签或图像。</para>
<programlisting>&lt;grid&gt;&#13;   &lt;columns&gt;&#13;<inlinegraphic fileref="img/7-5.png" align="right"/>      &lt;column label="Type"/&gt;&#13;      &lt;column label="Content"/&gt;&#13;   &lt;/columns&gt;&#13;
   &lt;rows&gt;&#13;      &lt;row&gt;&#13;             &lt;label value="File:"/&gt;&#13;             &lt;textbox width="99%"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;             &lt;label value="Type:"/&gt;&#13;             &lt;hbox&gt;&#13;                &lt;listbox rows="1" mold="select"&gt;&#13;                           &lt;listitem label="Java Files,(*.java)"/&gt;&#13;                       &lt;listitem label="All Files,(*.*)"/&gt;&#13;                &lt;/listbox&gt;&#13;                &lt;button label="Browse..."/&gt;&#13;             &lt;/hbox&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;
   &#13;&lt;/grid&gt;&#13;</programlisting><sect2><title>滚动网格</title>
<para>当指定了<code>height</code>属性且没有足够的空间来显示数据时，grid会变为滚动的。</para>
<programlisting>&lt;grid width="500px" height="130px"&gt;&#13;   &lt;columns&gt;&#13;<inlinegraphic fileref="img/7-5-1.png" align="right"/>      &lt;column label="Head 1"/&gt;&#13;      &lt;column label="Head 2" align="center"/&gt;&#13;      &lt;column label="Head 3" align="right"/&gt;&#13;   &lt;/columns&gt;   &lt;rows&gt;&#13;      &lt;row&gt;&#13;         &lt;listbox mold="select"&gt;&#13;            &lt;listitem label="Faster"/&gt;&#13;            &lt;listitem label="Fast"/&gt;&#13;            &lt;listitem label="Average"/&gt;&#13;         &lt;/listbox&gt;&#13;         &lt;datebox/&gt;&#13;         &lt;textbox rows="2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;checkbox checked="true" label="Option 1"/&gt;&#13;         &lt;checkbox label="Option 2"/&gt;&#13;         &lt;radiogroup&gt;&#13;            &lt;radio label="Apple"/&gt;&#13;            &lt;radio label="Orange" checked="true"/&gt;&#13;            &lt;radio label="Lemon"/&gt;&#13;         &lt;/radiogroup&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;checkbox checked="true" label="Option 1"/&gt;&#13;         &lt;checkbox label="Option 2"/&gt;&#13;         &lt;radiogroup orient="vertical"&gt;&#13;            &lt;radio label="Apple"/&gt;&#13;            &lt;radio label="Orange" checked="true"/&gt;&#13;            &lt;radio label="Lemon"/&gt;&#13;         &lt;/radiogroup&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;&lt;/grid&gt;&#13;</programlisting></sect2><sect2><title>可变列宽</title>
<para>如果你允许用户改变每列的宽度，可以将<code>columns</code>的<code>sizable</code>属性的设为<code>true</code>。一旦允许用户进行此操作，用户可以通过拖动相邻列的边框来改变列宽，如下，</para>
<programlisting>&lt;window&gt;&#13;   &lt;grid&gt;&#13;      &lt;columns id="cs" sizable="true"&gt;&#13;         &lt;column label="AA"/&gt;&#13;         &lt;column label="BB"/&gt;&#13;         &lt;column label="CC"/&gt;&#13;      &lt;/columns&gt;&#13;      &lt;rows&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="AA01"/&gt;&#13;            &lt;label value="BB01"/&gt;&#13;            &lt;label value="CC01"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="AA01"/&gt;&#13;            &lt;label value="BB01"/&gt;&#13;            &lt;label value="CC01"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="AA01"/&gt;&#13;            &lt;label value="BB01"/&gt;&#13;            &lt;label value="CC01"/&gt;&#13;         &lt;/row&gt;&#13;      &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13;   &lt;checkbox label="sizeable" checked="true" onCheck="cs.sizeable = self.checked"/&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect3><title>
<code>onColSize</code>事件</title>
<para>一旦用户改变了列宽，<code>onColSize</code>事件及<code>org.zkoss.zul.event.ColSizeEvent</code>的一个实例会被送出。注意列宽是在<code>onColSize</code>事件被送出前被调整的。换言之，你可以忽略作为一个通知的事件。当然，你可以在事件监听器中做你想做的事。</para></sect3></sect2><sect2><title>分页网格</title>
<para>有两种方式在grid中处理较长的内容：滚动及分页。滚动可以由指定<code>height</code>属性来实现，就像在前面讨论的一样。分页可以通过将<code>mold</code>属性设为<code>paging</code>来实现的。一旦分页可用，grid会将内容分为几页并且在同一时间内只显示一页。如下所示，</para>
<programlisting>&lt;grid width="300px" mold="paging" pageSize="4"&gt;&#13;   &lt;columns&gt;&#13;<inlinegraphic fileref="img/7-5-3.png" align="right"/>      &lt;column label="Left"/&gt;&#13;      &lt;column label="Right"/&gt;&#13;   &lt;/columns&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 1.1"/&gt;&lt;label value="Item 1.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 2.1"/&gt;&lt;label value="Item 2.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 3.1"/&gt;&lt;label value="Item 3.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 4.1"/&gt;&lt;label value="Item 4.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 5.1"/&gt;&lt;label value="Item 5.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 6.1"/&gt;&lt;label value="Item 6.2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;label value="Item 7.1"/&gt;&lt;label value="Item 7.2"/&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&lt;/grid&gt;&#13;</programlisting>

<para>一旦设置为分页模式，grid将会创建<code>paging</code>组件的一个实例作为其子组件。然后它将会关注分页。</para><sect3><title>
<code>pageSize</code>属性</title>
<para>一旦设置为分页模式，你可以通过<code>pageSize</code>属性指定每次的可见行数(也就是页面大小，page size)。默认为20。</para></sect3><sect3><title>
<code>paginal</code>属性</title>
<para>如果你喜欢将<code>paging</code>组件置于不同的位置或你想使用同一个<code>paging</code>组件控制两个或更多的grid，可以明确指明<code>paginal</code>属性。注意：如果没有明确指明，即同于<code>paging</code>属性。</para><graphic fileref="img/7-5-3-2.png" align="center"/>
<programlisting>&lt;vbox&gt;&#13;&lt;paging id="pg" pageSize="4"/&gt;&#13;&lt;hbox&gt;&#13;   &lt;grid width="300px" mold="paging" paginal="${pg}"&gt;&#13;      &lt;columns&gt;&#13;         &lt;column label="Left"/&gt;&#13;&lt;column label="Right"/&gt;&#13;      &lt;/columns&gt;&#13;      &lt;rows&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 1.1"/&gt;&lt;label value="Item 1.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 2.1"/&gt;&lt;label value="Item 2.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 3.1"/&gt;&lt;label value="Item 3.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 4.1"/&gt;&lt;label value="Item 4.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 5.1"/&gt;&lt;label value="Item 5.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 6.1"/&gt;&lt;label value="Item 6.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item 7.1"/&gt;&lt;label value="Item 7.2"/&gt;&#13;         &lt;/row&gt;&#13;      &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13;   &lt;grid width="300px" mold="paging" paginal="${pg}"&gt;&#13;      &lt;columns&gt;&#13;         &lt;column label="Left"/&gt;&lt;column label="Right"/&gt;&#13;     &lt;/columns&gt;&#13;      &lt;rows&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item A.1"/&gt;&lt;label value="Item A.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item B.1"/&gt;&lt;label value="Item B.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item C.1"/&gt;&lt;label value="Item C.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item D.1"/&gt;&lt;label value="Item D.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item E.1"/&gt;&lt;label value="Item E.2"/&gt;&#13;         &lt;/row&gt;&#13;         &lt;row&gt;&#13;            &lt;label value="Item F.1"/&gt;&lt;label value="Item F.2"/&gt;&#13;         &lt;/row&gt;&#13;      &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13; &lt;/hbox&gt;&#13;&lt;/vbox&gt;&#13;</programlisting></sect3><sect3><title>
<code>paging</code>属性</title>
<para>其为一个用来呈现<code>paging</code>子组件(自动创建来处理分页)只读属性。如果你通过<code>paginal</code>属性指派了额外的分页，它的值将为空。你很少会访问到此属性。相反，使用<code>paginal</code>属性。</para></sect3><sect3><title>
<code>OnPaging</code>事件及方法</title>
<para>一旦用户点击了<code>paging</code>组件的分页数字，<code>onPaging</code>事件会被送至grid。<code>onPaging</code>方法会处理此事件。默情况下，此方法或使<code>rows</code>的内容无效，也就是刷新。</para>
<para>如果你想实现"(依要求创建)create-on-demand" 特性，你可以为grid的<code>onPaging</code>事件添加一个事件监听器。</para>
<programlisting>grid.addEventListener(org.zkoss.zul.event.ZulEvents.ON_PAGING, new MyListener());&#13;</programlisting></sect3></sect2><sect2><title>排序</title>
<para>grid支持直接的行排序。如果你想打开某一列的递增排序，可以为<code>sortAscending</code>属性指派一个<code>java.util.Comparator</code>实例。类似的，可以为<code>sortDescending</code>属性指派一个comparator来打开递减排序。</para>
<para>如下所示，首先得实现comparator 接口来比较grid的任意两行，然后将其实例指派给<code>sortAscending</code>和<code>sortDescending</code>属性。注意：<code>compare</code>方法由<code>org.zkoss.zul.Row</code>的实例调用。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;zscript&gt;&#13;      class MyRowComparator implements Comparator {&#13;             public MyRowComparator(boolean ascending) {&#13;         ...&#13;         }&#13;         public int compare(Object o1, Object o2) {&#13;            Row r1 = (Row)o1, r2 = (Row)o2;&#13;            ....&#13;         }&#13;      }&#13;      Comparator asc = new MyRowComparator(true);&#13;      Comparator dsc = new MyRowComparator(false);&#13;   &lt;/zscript&gt;&#13;   &lt;grid&gt;&#13;      &lt;columns&gt;&#13;         &lt;column sortAscending="${asc}" sortDescending="${dsc}"/&gt;&#13;...&#13;</programlisting><sect3><title>
<code>sortDirection</code>属性</title>
<para>
<code>sortDirection</code>属性用来控制是否在客户端显示一个图标，以显示特定列的排列顺序。如果每行元素在添加到grid前即已排好序，则需要明确设定这个属性。</para>
<programlisting>&lt;column sortDirection="ascending"/&gt;&#13;</programlisting>
<para>然后，只要你为相应的列指定比较器，grid会自动维护此属性。</para></sect3><sect3><title>
<code>onSort</code>事件</title>
<para>当你为某一列至少指定了一个比较器，则若用户点击了此列<code>onSort</code>事件会被送至服务器。<code>column</code>组件实现了监听器，基于指定的比较器自动为行(rows)排序。</para>
<para>若你倾向于手工处理，可以为<code>onSort</code>事件将你自己的监听器添加到指定列。为了阻止默认的监听器调用<code>sort</code>方法，你必须调用<code>stopPropagation</code>方法来阻止事件被接收。另外，你可以重定义<code>sort</code>方法，见下文。</para></sect3><sect3><title>
<code>sort</code>方法</title>
<para>
<code>sort</code>方法是<code>onSort</code>事件监听器的最底层实现。如果你使用Java代码为行排序，则这会非常有用。例如，你或许必须在添加行(假定未排序)后调用此方法。</para>
<programlisting>Row row = new Row();&#13;row.setParent(rows);&#13;row.appendChild(...);&#13;...&#13;if (!"natural".column.getSortDirection())&#13;   column.sort("ascending".equals(column.getSortDirection()));&#13;</programlisting>
<para>默认排序算法为快速排序(quick-sort)(<code>org.zkoss.zk.ui.Components</code>类的<code>sort</code>方法)。你可以使用自己的实现来重定义此方法。</para>
<para>注：<code>sort</code>方法会检测排序顺序(通过调用<code>getSortDirection</code>)。仅在排序顺序不同时sort才会为行排序。若想强制排序，可按如下方式，</para>
<programlisting>column.setSortDirection("natural");&#13;sort(myorder);&#13;</programlisting>
<para>等价于：</para>
<programlisting>sort(myorder, true);&#13;</programlisting></sect3></sect2><sect2><title>实况数据</title>
<para>就像listbox,gird支持live data一样。使用实况数据，开发人员可以将数据从视图分离。换言之，开发人员仅需实现<code>rg.zkoss.zul.ListMode</code>l接口类提供数据。而非直接操作grid。好处有以下两点，</para>
<orderedlist>
<listitem>
<para>易于使用不同的视图来显示相同的数据。</para>
</listitem>
<listitem>
<para>grid仅在其可见时才会将数据送至客户端。在数据量巨大时可以减少大量的网络流量(network traffic)。</para>
</listitem>
</orderedlist>
<para>使用实况数据需要经过三步，</para>
<orderedlist>
<listitem>
<para>以<code>ListModel</code>形式准备好数据。ZK有一个称为<code>org.zkoss.zul.SimpleListModel</code>的具体实现，用于显示一个数组对象。 </para>
</listitem>
<listitem>
<para>实现<code>org.zkoss.zul.RowRenderer</code>接口用于将数据行送至grid。</para>
</listitem>
<listitem>
<para>在model属性中指定数据，并且可以选择在<code>rowRenderer</code>属性指定渲染器。</para>
</listitem>
</orderedlist>
<para>其中第二项又分两点</para>
<itemizedlist>
<listitem>
<para>这是可选的。若为指定，默认的渲染器(renderer)会启，并将数据送至第一列。</para>
</listitem>
<listitem>
<para>你可以实现不同的，这样可以在不同的视图中显示相同的数据。</para>
</listitem>
</itemizedlist>
<para>在下面的例子中，我们准备了一个称为<code>strset</code>的列表模型，通过grid的<code>model</code>属性为其指定此值。然后，grid会处理剩下的工作。</para>
<programlisting>    &lt;window title="Live Grid" border="normal"&gt;&#13;   &lt;zscript&gt;&#13;      String[] data = new String[30];&#13;<inlinegraphic fileref="img/7-5-5.png" align="right"/>      for(int j=0; j &amp;lt; data.length; ++j) {&#13;         data[j] = "option "+j;&#13;      }&#13;      ListModel strset = new SimpleListModel(data);&#13;   &lt;/zscript&gt;&#13;   &lt;grid width="100px" height="100px" model="${strset}"&gt;&#13;      &lt;columns&gt;&#13;         &lt;column label="options"/&gt;&#13;      &lt;/columns&gt;&#13;   &lt;/grid&gt;&lt;/window&gt;&#13;</programlisting><sect3><title>实况数据的排序</title>
<para>如果你允许用户为提供实况数据的grid排序，则必须要实现<code>org.zkoss.zul.ListModel</code>及<code>org.zkoss.zul.ListModelExt</code>接口。</para>
<programlisting>class MyListModel implements ListModel, ListModelExt {&#13;   public void sort(Comparator cmpr, boolean ascending) {&#13;      //do the real sorting&#13;      //notify the grid (or listbox) that data is changed by use of ListDataEvent&#13;   }&#13;}&#13;</programlisting>
<para>当用户请求grid排序时，grid将会调的用<code>ListModelExt</code>的<code>sort</code>方法来为数据排序。换言之，排序 是由列表模型(list mode)完成的，而不是grid。</para>
<para>排序完成之后，列表模型会调用<code>org.zkoss.zul.event.ListDataListener</code>实例(通过<code>addListDataListener</code>方法注册在grid)的<code>onChange</code>方法来通知grid。在大多数情况下，所有的数据通常会变化，所以列表模型通常会发送下列事件：</para>
<programlisting>new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1) &#13;</programlisting></sect3></sect2><sect2><title>特殊属性</title><sect3><title>
<code>spans</code>属性</title>
<para>为一个整数列表，以逗号分隔，用于就控制是否将一个元素(cell)跨越几列。列表中的第一个数字表示第一个元素跨越的列数，第二个数字表示第二个元素跨越的列数，依次类推。若省略数字，则为1。</para>
<para>例如，</para>
<programlisting>&lt;grid&gt;&#13;   &lt;columns&gt;&#13;      &lt;column label="Left" align="left"/&gt;&lt;column label="Center" align="center"/&gt;&#13;      &lt;column label="Right" align="right"/&gt;&lt;column label="Column 4"/&gt;&#13;      &lt;column label="Column 5"/&gt;&lt;column label="Column 6"/&gt;&#13;   &lt;/columns&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&#13;             &lt;label value="Item A.1"/&gt;&lt;label value="Item A.2"/&gt;&#13;             &lt;label value="Item A.3"/&gt;&lt;label value="Item A.4"/&gt;&#13;             &lt;label value="Item A.5"/&gt;&lt;label value="Item A.6"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row spans="1,2,2"&gt;&#13;             &lt;label value="Item B.1"/&gt;&lt;label value="Item B.2"/&gt;&#13;             &lt;label value="Item B.4"/&gt;&lt;label value="Item B.6"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row spans="3"&gt;&#13;             &lt;label value="Item C.1"/&gt;&lt;label value="Item C.4"/&gt;&#13;             &lt;label value="Item C.5"/&gt;&lt;label value="Item C.6"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row spans=",,2,2"&gt;&#13;             &lt;label value="Item D.1"/&gt;&lt;label value="Item D.2"/&gt;&#13;             label value="Item D.3"/&gt;&lt;label value="Item D.5"/&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&lt;/grid&gt;&#13;</programlisting><graphic fileref="img/7-5-6-1.png" align="center"/></sect3></sect2></sect1><sect1><title>更多的布局组件</title><sect2><title>Separators and Spaces</title>
<para>组件: <code>separator</code> 和 <code>space</code>
<code>。</code>
</para>
<para>separator用于在两个组件间插入一定的空间。有几种方式来定制<code>separator</code> 。</para>
<orderedlist>
<listitem>
<para>使用<code>orient</code>属性，你可以指定一个垂直或水平的separator。默认为水平separator，即插入一条水平线。 而垂直的separator为插入一个空格。另外，<code>space</code>是默认为垂直方向的<code>separator</code>的一种变体型(variant)。</para>
</listitem>
<listitem>
<para>使用<code>bar</code>属性，你可以控制在组件间显示水平线还是垂直线。 </para>
</listitem>
<listitem>
<para>使用<code>spacing</code>属性，你可以控制spacing的大小。</para>
</listitem>
</orderedlist>
<programlisting>&lt;window&gt;&#13;   line 1 by separator&#13;   &lt;separator/&gt;&#13;<inlinegraphic fileref="img/7-6-1.png" align="right"/>   line 2 by separator&#13;   &lt;separator/&gt;&#13;   line 3 by separator&lt;space bar="true"/&gt;another piece&#13;   &lt;separator spacing="20px"/&gt;&#13;   line 4 by separator&lt;space bar="true" spacing="20px"/&gt;another piece&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>Group boxes</title>
<para>组件: <code>groupbox</code>
<code>。</code>
</para>
<para>group box用于将组件分组。典型情况下，被group box分组的组件周围会显示边框，以显示它们是相关联的。</para>
<para>使用<code>caption</code>组件可以创建group box 的顶部标签。就像HTML的图例(legend)元素一样工作。</para>
<para>不同于 windows， group box 并不是一个ID空间的所有者。 group box 并不能重叠或弹出。</para>
<programlisting>&lt;groupbox width="250px"&gt;&#13;<inlinegraphic fileref="img/7-6-2a.png" align="right"/>   &lt;caption label="Fruits"/&gt;&#13;   &lt;radiogroup&gt;&#13;      &lt;radio label="Apple"/&gt;&#13;      &lt;radio label="Orange"/&gt;&#13;      &lt;radio label="Banana"/&gt;&#13;   &lt;/radiogroup&gt;&#13;&lt;/groupbox&gt;&#13;</programlisting>
<para>除了<code>default</code>模型(mold)， group box 还支持<code>3d</code>模型。如果使用了<code>3d</code>模型， group box就像简单的tab box 一样工作。首先，你可以使用<code>open</code>属性来控制是否显示其内容。类似的，你可以在接收<code>onOpen</code>事件时创建group box的内容。</para>
<programlisting>&lt;groupbox mold="3d" open="true" width="250px"&gt;&#13;<inlinegraphic fileref="img/7-6-2b.png" align="right"/>   &lt;caption label="fruits"/&gt;&#13;   &lt;radiogroup&gt;&#13;      &lt;radio label="Apple"/&gt;&#13;      &lt;radio label="Orange"/&gt;&#13;      &lt;radio label="Banana"/&gt;&#13;   &lt;/radiogroup&gt;&#13;&lt;/groupbox&gt;&#13;</programlisting><sect3><title>
<code>contentStyle</code>属性及滚动<code>Groupbox</code>
</title>
<para>
<code>contentStyle</code>属性用于为groupbox的内容块指定CSS样式。因此，你可以使用<code>overflow</code>:auto (或 <code>overflow</code>:scroll)来将groupbox 设置为滚动样式，如下，</para>
<programlisting>&lt;groupbox mold="3d" width="150px" contentStyle="height:50px;overflow:auto"&gt;&#13;<inlinegraphic fileref="img/7-6-2-1.png" align="right"/>   &lt;caption label="fruits"/&gt;&#13;   &lt;radiogroup onCheck="fruit.value = self.selectedItem.label" orient="vertical"&gt;&#13;      &lt;radio label="Apple"/&gt;&#13;      &lt;radio label="Orange"/&gt;&#13;      &lt;radio label="Banana"/&gt;&#13;   &lt;/radiogroup&gt;&#13;&lt;/groupbox&gt;&#13;</programlisting>
<para>[注]: 若使用default模型则<code>contentStyle</code>属性会被忽略。 </para>
<para>
<code>contentStyle</code>属性中指定的height为内容块的高度，不包括caption。因此，如果groupbox被忽略(也就是内容块不可见)了，整个groupbox的高度会收缩到仅能包含caption。另外，如果你为整个groupbox 指定了高度(使用<code>height</code>属性)，当忽略groupbox时，仅仅是内容块消失而整个groupbox的高度是不会变的。</para></sect3></sect2><sect2><title>工具栏</title>
<para>组件: <code>toolbar</code> 和 <code>toolbarbutton</code>.</para>
<para>toolbar用于放置一系列的按钮，如toolbar 按钮。toolbar 按钮可以不在toolbar 内使用，所以同样toolbar可以不使用工具按钮。但是，放置在toolbar 内的工具按钮会改变外观。</para>
<para>toolbar有两种布局方向：<code>horizontal</code> 和 <code>vertical</code>。它们可以控制如何放置按钮。</para>
<programlisting>&lt;toolbar&gt;&#13;<inlinegraphic fileref="img/7-6-3.png" align="right"/>   &lt;toolbarbutton label="button1"/&gt;&#13;   &lt;toolbarbutton label="button2"/&gt;&#13;&lt;/toolbar&gt;&#13;</programlisting></sect2></sect1><sect1><title>菜单栏</title>
<para>组件： <code>menubar</code>
<code>，</code>
<code>menupopup</code>
<code>，</code>
<code>menu</code>
<code>，</code>
<code>menuitem</code> 和 <code>menuseparator</code>
<code>。</code>
</para>
<para>菜单栏包括了菜单项目及子菜单项目的集合。子菜单栏包括菜单项目及其它子菜单项目的集合。因此，它们组成了一个树状菜单项目，这样用户可以选择执行。</para>
<para>一个使用菜单栏的例子如下，</para>
<programlisting>&lt;menubar&gt;&#13;   &lt;menu label="File"&gt;&#13;      &lt;menupopup&gt;&#13;<inlinegraphic fileref="img/7-7.png" align="right"/>             &lt;menuitem label="New"/&gt;&#13;             &lt;menuitem label="Open"/&gt;&#13;             &lt;menuseparator/&gt;&#13;             &lt;menuitem label="Exit"/&gt;&#13;      &lt;/menupopup&gt;&#13;   &lt;/menu&gt;&#13;   &lt;menu label="Help"&gt;&#13;      &lt;menupopup&gt;&#13;             &lt;menuitem label="Index"/&gt;&#13;             &lt;menu label="About"&gt;&#13;                &lt;menupopup&gt;&#13;                           &lt;menuitem label="About ZK"/&gt;&#13;                       &lt;menuitem label="About Potix"/&gt;&#13;                &lt;/menupopup&gt;&#13;             &lt;/menu&gt;&#13;      &lt;/menupopup&gt;&#13;   &lt;/menu&gt;&#13;&lt;/menubar&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>menubar</code>: 菜单项目(<code>menuitem</code>)和菜单(<code>menu</code>)集合的最顶层容器。</para>
</listitem>
<listitem>
<para>
<code>menu</code>: 弹出(popup)菜单的容器，<code>menu</code>定义了一个用于显示的标签。当用户点击标签时，弹出菜单就会出现。</para>
</listitem>
<listitem>
<para>
<code>menupopup</code>: 一个菜单项目(<code>menuitem</code>)和菜单(<code>menu</code>)集合的容器。同时它为<code>menu</code>的一个子组件并且当<code>menu</code>的标签被点击时它就会出现。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>menuitem</code>: menu的私有命令。可以被放置在 a menu bar或弹出菜单内。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>menuseparator</code>: 一个菜单内的分割栏。需要放置在弹出菜单内。 </para>
</listitem>
</itemizedlist><sect2><title>执行一个菜单命令</title>
<para>菜单命令是和菜单项目相关联的。有两种方式将一个命令关联到菜单：<code>onClick</code>事件及<code>href</code>属性。如果添加一个事件监听器到菜单项目的<code>onClick</code>事件，当此项目被点击时监听器就会被调用。</para>
<programlisting>&lt;menuitem onClick="draft.save()"/&gt;&#13;</programlisting>
<para>另外，你可以为<code>href</code>属性指定一个超链接，则当用户点击菜单项目时会转向指定的URL。</para>
<programlisting>&lt;menuitem href="/edit"/&gt;&#13;&lt;menuitem href="http://zk1.sourceforge.net"/&gt;&#13;</programlisting>
<para>若事件监听器和<code>href</code>属性都被指定了，则都会执行。但是，当事件监听器在服务器开始执行时，浏览器或许已经将当前的URL转向了指定的链接。因此，所有由事件监听器产生的响应都会被忽略。</para></sect2><sect2><title>像复选框一样使用菜单项目</title>
<para>菜单项目可以像复选框一样使用。<code>checked</code>属性表示此菜单项目是否被选中。若选中，一个选中图标就会出现在菜单项目的前面。</para>
<para>除了编程使用<code>checked</code>属性，你还可以将<code>autocheck</code>属性设为<code>true</code>，这样当用户点击此菜单项目时<code>checked</code>属性就会被自动切换。</para>
<programlisting>&lt;menuitem label="" autocheck="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>autodrop</code>属性</title>
<para>默认情况下，弹出菜单会在被点击时打开。你可以将其改变为当鼠标移动到菜单上方时它自动打开。将<code>autodrop</code>属性设为true即可实现。</para>
<programlisting>&lt;menubar autodrop="true"&gt;&#13;...&#13;&lt;/menubar&gt;&#13;</programlisting></sect2><sect2><title>
<code>onOpen</code>事件
</title>
<para>当menupopup将要出现(或要隐藏) 时，<code>onOpen</code>事件会被送至menupopup用于通知。 对于更复杂的应用程序，你可以推迟menupopup 内容的创建或自动操纵内容，直到接收了<code>onOpen</code>事件。参考用户界面标记语言一章中关于随机存取(Load on Demand)的部分。</para></sect2><sect2><title>更多的菜单特性</title>
<para>就像<code>box</code>，你可以使用<code>orient</code>属性控制菜单的方向。默认方向为<code>horizontal</code>。</para>
<para>就像其它的组件，你可以自动的改变菜单，包括属性和创建子菜单。参考<code>zkdemo</code>中<code>test</code>目录下的<code>menu.zul</code>。</para></sect2></sect1><sect1><title>上下文菜单</title>
<para>组件: <code>popup</code> 和 <code>menupopup</code>
<code>。</code>
</para>
<para>你可以将<code>popup</code>或<code>menupopup</code>组件的ID指派给任一个XUL组件的<code>context</code>属性，这样，当用户右击此组件时<code>popup</code>或<code>menupopup</code>组件就会打开。</para>
<para>如下所示，通过将ID指派给<code>context</code>属性可以很容易的启动context菜单。当然，你可以为多个组件指派相同的ID。</para>
<programlisting>&lt;label value="Right Click Me!" context="editPopup"/&gt;&#13;&lt;separator bar="true"/&gt;&lt;label value="Right Click Me!" onRightClick="alert(self.value)"/&gt;&#13;&lt;menupopup id="editPopup"&gt;&#13;   &lt;menuitem label="Undo"/&gt;&#13;   &lt;menuitem label="Redo"/&gt;&#13;   &lt;menu label="Sort"&gt;&#13;      &lt;menupopup&gt;&#13;            &lt;menuitem label="Sort by Name" autocheck="true"/&gt;&#13;            &lt;menuitem label="Sort by Date" autocheck="true"/&gt;&#13;      &lt;/menupopup&gt;&#13;   &lt;/menu&gt;&#13;&lt;/menupopup&gt;&#13;</programlisting>
<para>
<graphic fileref="img/7-8.png"/>
</para>
<para>注意直到用户右击与其组件(通过ID关联)时<code>menupopup</code>才会变得可见。</para>
<para>[技巧]: 如果你只是想禁用浏览器默认的上下文菜单，可以为context属性指定一个并不存在的ID. </para>
<para>
<code>popup</code>是一个比<code>menupopup</code>更通用的popup组件。你可以在popup内放置任意类型的组件。</para>
<programlisting>&lt;label value="Right Click Me!" context="any"/&gt;&#13;&#13;&lt;popup id="any" width="300px"&gt;&#13;   &lt;vbox&gt;&#13;      It can be anything.&#13;      &lt;toolbarbutton label="ZK" href="http://zk1.sourceforge.net"/&gt;&#13;   &lt;/vbox&gt;&#13;&lt;/popup&gt;&#13;</programlisting><sect2><title>定制的tooltip及弹出菜单</title>
<para>除了当用户右击组件时打开一个 popup，ZK也可以其它情况下打开一个popup。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>属性</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>context</code>
</para>
</entry>
<entry>
<para>当用户右键点击一个带有<code>context</code>属性的组件时，将会显示已指定id的<code>popup</code>或<code>menupopup</code>组件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>tooltip</code>
</para>
</entry>
<entry>
<para>当用户鼠标经过一个带有<code>tooltip</code>属性的组件时，将会显示已指定id的<code>popup</code>或<code>menupopup</code>组件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>pop</code>
<code>up</code>
</para>
</entry>
<entry>
<para>当用户点击一个带有<code>popup</code>属性的组件时，将会显示已指定<code>id</code>的popup或<code>menupopup</code>组件。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>例如：</para>
<programlisting>&lt;window title="Context Menu and Right Click" border="normal" width="360px"&gt;&#13;   &lt;label value="Move Mouse Over Me!" tooltip="editPopup"/&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;label value="Tooptip for Another Popup" tooltip="any"/&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;label value="Click Me!" popup="editPopup"/&gt;&#13;   &lt;menupopup id="editPopup"&gt;&#13;        &lt;menuitem label="Undo"/&gt;&#13;       &lt;menuitem label="Redo"/&gt;&#13;        &lt;menu label="Sort"&gt;&#13;         &lt;menupopup&gt;&#13;              &lt;menuitem label="Sort by Name" autocheck="true"/&gt;&#13;              &lt;menuitem label="Sort by Date" autocheck="true"/&gt;&#13;         &lt;/menupopup&gt;&#13;        &lt;/menu&gt;   &lt;/menupopup&gt;&#13;   &lt;popup id="any" width="300px"&gt;&#13;      &lt;vbox&gt;&#13;         ZK simply rich.         &lt;&#13;toolbarbutton label="ZK your killer Web application now!" href="http://zk1.sourceforge.net"/&gt;&#13;      &lt;/vbox&gt;&#13;   &lt;/popup&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>注意，你可以在<code>popup</code>, <code>tooltip</code> 和 <code>context</code>属性内指定任意的标识，只要它们在同一页面。换句话说，它并不限于(confine)ID空间。</para></sect2><sect2><title>
<code>onOpen</code>事件</title>
<para>当一个context menu, tooltip 或 popup 将要显示(或隐藏)时，<code>onOpen</code>事件会被送至ontext, tooltip 或poup menu用于通知。事件为<code>org.zkoss.zk.ui.event.OpenEvent</code>类的一个实例，而你可以使用<code>getReference</code>方法来获取致使context menu, tooltip 或 popup出现的组件。</para>
<para>为了提高性能，你可以推迟内容的创建直到它们变得可见，也就是，直到接收<code>onOpen</code>事件。</para>
<para>推迟创建内容的最简单方式是使用<code>fulfill</code>属性，如下，</para>
<programlisting>&lt;popup id="any" width="300px" fulfill="onOpen"&gt;&#13;   &lt;button label="Hi"/&gt;&lt;!-- whatever content --&gt;&#13;&lt;/popup&gt;&#13;</programlisting>
<para>然后。当加载页面时，内容(Hi按钮)不会被创建。在接收到<code>onOpen</code>事件的第一时间，内容就会被创建。</para>
<para>若你喜欢在Java代码中动态的操纵内容，可以按如下描绘的方式监听<code>onOpen</code>事件。</para>
<programlisting>&lt;popup id="any" width="300px"&gt;&#13;   &lt;attribute name="onOpen"&gt;&#13;   if (event.isOpen()) {&#13;      if (self.getChildren().isEmpty()) {&#13;             new Button("Hi").seParent(self);&#13;         ...&#13;      }&#13;      if (event.getReference() instanceof Textbox) {&#13;         //you can do component-dependent manipulation here&#13;         ...&#13;      }&#13;   }&#13;   &lt;/attribute&gt;&#13;&lt;/popup&gt;&#13;</programlisting></sect2></sect1><sect1><title>列表框</title>
<para>组件: <code>listboxlistitem</code>
<code>，</code>
<code>listcell</code>
<code>，</code>
<code>listhead</code> 和 <code>listheader</code>
<code>。</code>
</para>
<para>list box 用于显示列表中的若干项目。用户可以从列表中选取某一项目。最简单的形式如下。这是一个单列单选择的列表框。</para>
<programlisting>&lt;listbox&gt;&#13;<inlinegraphic fileref="img/7-9a.png" align="right"/>   &lt;listitem label="Butter Pecan"/&gt;&#13;   &lt;listitem label="Chocolate Chip"/&gt;&#13;   &lt;listitem label="Raspberry Ripple"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>Listbox有两种模型：<code>default</code>和<code>select</code>。若使用了<code>select</code>，就会产生HTML的<code>SELECT</code>标签。</para>
<programlisting>&lt;listbox mold="select"&gt;...&lt;/listbox&gt;&#13;<inlinegraphic fileref="img/7-9b.png" align="right"/></programlisting>
<para>注意: 若为"<code>select</code>"模型, 则行数为"1", 且并没有项目被标明选中，浏览器就像第一行被选中一样显示<code>listbox</code>。最坏的情况事，若用户选中了此事例中的首项目，则不会发出<code>onSelect</code>事件。为了避免这种困惑，开发人员至少要为<code>mold="select"</code> 及 <code>rows="1"</code> 选择一个项目。</para>

<para>除了标签，你可以使用<code>setValue</code>方法为每个项目指派一个特定应用程序值。</para>
<para>无鼠标输入 <code>listbox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>UP</code> 和 <code>DOWN</code>, 上下移动选中的列表项目。</para>
</listitem>
<listitem>
<para>
<code>PgUp</code> 和<code>PgDn</code> ，以一页的步长上下移动选中项。</para>
</listitem>
<listitem>
<para>
<code>HOME</code> ，选中首行，<code>END</code> ，选中末行。</para>
</listitem>
<listitem>
<para>
<code>Ctrl+UP</code> 和 <code>Ctrl+DOWN</code> ，上下移动列表项目的聚焦但并不改变选中项目。 </para>
</listitem>
<listitem>
<para>
<code>SPACE</code>，选中聚焦项目。</para>
</listitem>
</itemizedlist><sect2><title>多列列表框</title>
<para>List box也支持多列。当用户选中以一个项目时，整行都会被选中。</para>
<para>为了指定一个多列列表，你需要指定listcell组件作为每个listitem(作为一行)的列。</para>
<programlisting>&lt;listbox width="200px"&gt;&#13;<inlinegraphic fileref="img/7-9-1.png" align="right"/>   &lt;listitem&gt;&#13;      &lt;listcell label="George"/&gt;&#13;      &lt;listcell label="House Painter"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Mary Ellen"/&gt;&#13;      &lt;listcell label="Candle Maker"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Roger"/&gt;&#13;      &lt;listcell label="Swashbuckler"/&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>栏头</title>
<para>通过使用<code>listhead</code>和<code>listheader</code>可以指定栏头，如下<footnote>
<para>在使用listhead 和 listheader的地方，此特性与XUL有一些不同。</para>
</footnote>。除了标签，通过使用<code>image</code>属性你可以指定一张图像作为栏头。</para>
<programlisting>&lt;listbox width="200px"&gt;&#13;<inlinegraphic fileref="img/7-9-2.png" align="right"/>   &lt;listhead&gt;&#13;      &lt;listheader label="Name"/&gt;&#13;      &lt;listheader label="Occupation"/&gt;&#13;   &lt;/listhead&gt;&#13;...&#13;&lt;/listbox&gt;&#13;</programlisting></sect2>
<sect2><title>栏尾</title>
<para>通过使用<code>listfoot</code>和<code>listfooter</code>，你可以指定栏尾，如下。注意<code>listhead</code>和<code>listfoot</code>的顺序是不匹配的。每次<code>listhead</code>实例被添加到一个<code>listbox</code>时，它必须为第一个子组件，而<code>listfooter</code>实例为最后一个子组件。 </para>
<programlisting>&lt;listbox width="200px"&gt;&#13;<inlinegraphic fileref="img/7-9-3.png" align="right"/>   &lt;listhead&gt;&#13;      &lt;listheader label="Population"/&gt;&#13;      &lt;listheader align="right" label="%"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem id="a" value="A"&gt;&#13;      &lt;listcell label="A. Graduate"/&gt;&#13;      &lt;listcell label="20%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem id="b" value="B"&gt;&#13;      &lt;listcell label="B. College"/&gt;&#13;      &lt;listcell label="23%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem id="c" value="C"&gt;&#13;      &lt;listcell label="C. High School"/&gt;&#13;      &lt;listcell label="40%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem id="d" value="D"&gt;&#13;      &lt;listcell label="D. Others"/&gt;&#13;      &lt;listcell label="17%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listfoot&gt;&#13;      &lt;listfooter label="More or less"/&gt;&#13;      &lt;listfooter label="100%"/&gt;&#13;   &lt;/listfoot&gt;&#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>下拉列表</title>
<para>通过指定select模型及单行可以创建一个下拉列表。注意不能为下拉列表指定多列。</para>
<programlisting>&lt;listbox mold="select" rows="1"&gt;&#13;<inlinegraphic fileref="img/7-9-4.png" align="right"/>   &lt;listitem label="Car"/&gt;&#13;   &lt;listitem label="Taxi"/&gt;&#13;   &lt;listitem label="Bus" selected="true"/&gt;&#13;   &lt;listitem label="Train"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>多选</title>
<para>当用户点击一个列表项目时，这个项目会被选中，且<code>onSelect</code>事件会被送回服务器以通知应用程序。通过将<code>multiple</code>属性设置为 true，你可以控制一个listbox 是否允许选中多行。默认为false。</para></sect2><sect2><title>滚动列表框</title>
<para>若指定了<code>rows</code>或<code>height</code>属性且不足以显示所有项目时， listbox 会变为滚动的。</para>
<programlisting>&lt;listbox width="250px" rows="4"&gt;&#13;<inlinegraphic fileref="img/7-9-6.png" align="right"/>   &lt;listhead&gt;&#13;      &lt;listheader label="Name" sort="auto"/&gt;&#13;      &lt;listheader label="Gender" sort="auto"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Mary"/&gt;&#13;      &lt;listcell label="FEMALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="John"/&gt;&#13;      &lt;listcell label="MALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Jane"/&gt;&#13;      &lt;listcell label="FEMALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Henry"/&gt;&#13;      &lt;listcell label="MALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem&gt;&#13;      &lt;listcell label="Michelle"/&gt;&#13;      &lt;listcell label="FEMALE"/&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting><sect3><title>
<code>rows</code>属性</title>
<para>
<code>rows</code>属性用于控制显示多少行。若将其设置为0，listbox会将自身大小调整到容纳所有的项目。</para></sect3></sect2><sect2><title>可变列表头</title>
<para>就像<code>columns</code>，你可以将<code>listhead</code>的<code>sizable</code>属性设为true，以允许用户改变列表头的宽度。类似的当用户改变列宽时<code>onColSize</code>事件会被送出。</para></sect2><sect2><title>分页列表框</title>
<para>就像grid，指定<code>paging</code>模型，你就可以使用多页来呈现listbox的较长内容。类似的，你可以控制每页显示多少项目，是否使用额外的paging组件，以及当选中某一页面时是否定制行为。参考Grids章节获取细节。</para></sect2><sect2><title>排序</title>
<para>Listbox直接支持列表项目的排序。有几种方式来启动某一列的排序。最简单的方式是将listheader 的<code>sort</code>属性设为auto，如下。然后，与listheader 关联的列会基于指定列的每个列表元素的标签排序。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;listbox width="200px"&gt;&#13;<inlinegraphic fileref="img/7-9-9.png" align="right"/>      &lt;listhead&gt;&#13;         &lt;listheader label="name" sort="auto"/&gt;&#13;         &lt;listheader label="gender" sort="auto"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem&gt;&#13;         &lt;listcell label="Mary"/&gt;&#13;         &lt;listcell label="FEMALE"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem&gt;&#13;         &lt;listcell label="John"/&gt;&#13;         &lt;listcell label="MALE"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem&gt;&#13;         &lt;listcell label="Jane"/&gt;&#13;         &lt;listcell label="FEMALE"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem&gt;&#13;         &lt;listcell label="Henry"/&gt;&#13;         &lt;listcell label="MALE"/&gt;&#13;      &lt;/listitem&gt;&#13;         &lt;/listbox&gt;&#13;&lt;/zk&gt;&#13;</programlisting><sect3><title>
<code>sortAscending</code> 和 <code>sortDescending</code>
<code>属性</code>
</title>
<para>若你想用不同的方式为列表项目排序，可以为<code>sortAscending</code>和<code>/</code>或<code>sortDescending</code>属性指派一个<code>java.util.Comparator</code>实例。一旦指定了，列表项目会使用你指派的比较器以升序或降序存储。</para>
<para>调用值为auto的sort属性实际上是自动为<code>sortAsceding</code> 和 <code>sortDescending</code>指定了两个比较器。你可以重定义它们中的任意一个通过为其指派另一个比较器。</para>
<para>例如，假定你想基于列表项目的值排序，而不是列表元素的标签，可以按如下方式为这些属性指派以一个<code>ListitemComparator</code>的实例。</para>
<programlisting>&lt;zscript&gt;&#13;   Comparator asc = new ListitemComarator(-1, true, true);&#13;   Comparator dsc = new ListitemComarator(-1, false, true);&#13;&lt;/zscript&gt;&#13;&lt;listbox&gt;&#13;   &lt;listhead&gt;&#13;      &lt;listheader sortAscending="${asc}" sortDescending="${dsc}"/&gt;&#13;...&#13;</programlisting></sect3><sect3><title>
<code>sortDirection</code>属性</title>
<para>
<code>sortDirection</code>属性控制是否在客户端显示一个图标，以指明特定列的排列顺序。若列表项目在添加到listbox前已排好序，你需要明确设置这个属性。</para>
<programlisting>&lt;listheader sortDirection="ascending"/&gt;&#13;</programlisting>
<para>然后，只要你为相应的listheader指派了比较器listbox会自动维护。</para></sect3><sect3><title>
<code>onSort</code>事件</title>
<para>当你为listheader 至少指派了一个比较器时，若用户点击了它，<code>onSort</code>事件就会被送至服务器。 listheader 实现了一个监听器来自动处理排序。</para>
<para>若你喜欢受手动处理，可以将你的监听器添加到listheader的<code>onSort</code>事件。为了阻止默认的监听器调用sort方法，你必须调用<code>stopPropagation</code>方法来阻止接收事件。另外，你可以重定义<code>sort</code>方法，见下文。</para></sect3><sect3><title>
<code>sort</code>方法</title>
<para>
<code>sort</code>方法是默认的<code>onSort</code>事件监听器的最底层实现。若你想使用Java代码为列表项目排序这也是很有用的。例如，你可以在添加项目(假定并未排好序)之后调用此方法。</para>
<programlisting>new Listem("New Stuff").setParent(listbox);&#13;if (!"natural".header.getSortDirection())&#13;   header.sort("ascending".equals(header.getSortDirection()));&#13;</programlisting>
<para>默认的排序算法为快速排序(使用<code>org.zkoss.zk.ui.Components</code>类的<code>sort</code>方法)。你可以将其用自己的实现来重定义，或像前一章节描述的那样监听<code>onSort</code>事件。</para>
<para>[提示]： 为大量实况数据排序或许会显著的降低性能。最好是侦听onSort事件或sort方法以有效处理排序。参考下面的为实况数据排序(Sort Live Data)章节。</para></sect3></sect2><sect2><title>特殊属性</title><sect3><title>
<code>checkmark</code>属性</title>
<para>
<code>checkmark</code>属性控制是否在每个listitem前显示一个checkbox 或radio按钮。</para>
<para>在下面的例子中，当你将一个listitem 从左边的listbox 移到右边的listbox时，会自动添加一个checkbox。反过来checkbox会被移去。</para>
<programlisting>&lt;hbox&gt;&#13;<inlinegraphic fileref="img/7-9-10-1a.png" align="right"/>   &lt;listbox id="src" rows="0" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader label="Percentage"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem id="a" value="A"&gt;&#13;         &lt;listcell label="A. Graduate"/&gt;&#13;         &lt;listcell label="20%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem id="b" value="B"&gt;&#13;         &lt;listcell label="B. College"/&gt;&#13;         &lt;listcell label="23%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem id="c" value="C"&gt;&#13;         &lt;listcell label="C. High School"/&gt;&#13;         &lt;listcell label="40%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem id="d" value="D"&gt;&#13;         &lt;listcell label="D. Others"/&gt;&#13;         &lt;listcell label="17%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;   &lt;vbox&gt;&#13;      &lt;button label="=&amp;gt;" onClick="move(src, dst)"/&gt;&#13;      &lt;button label="&amp;lt;=" onClick="move(dst, src)"/&gt;&#13;   &lt;/vbox&gt;&#13;   &lt;listbox id="dst" checkmark="true" rows="0" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader label="Percentage"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem id="e" value="E"&gt;&#13;         &lt;listcell label="E. Supermen"/&gt;&#13;         &lt;listcell label="21%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;   &lt;zscript&gt;&#13;void move(Listbox src, Listbox dst) {&#13;   Listitem s = src.getSelectedItem();&#13;   if (s == null)&#13;      Messagebox.show("Select an item first");&#13;   else&#13;      s.setParent(dst);&#13;}&#13;   &lt;/zscript&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>

<para>注意若<code>multiple</code>属性为 false，则会显示radio 按钮，如右图所示。<graphic fileref="img/7-9-10-1b.png" align="center"/></para></sect3><sect3><title>
<code>vflex</code>属性</title>
<para>
<code>vflex</code>属性控制是否在垂直方向增长或缩小以适合指定空间。即所谓的垂直柔性(vertical flexibility)。例如，如果列表太长以至于不适合浏览器窗口，此属性会缩小列表的高度以控制整个列表在浏览器内可见。</para>
<para>若指定了<code>rows</code>属性则此属性会被忽略。</para></sect3><sect3><title>
<code>maxlength</code> 属性</title>
<para>
<code>maxlength</code>属性定义了浏览器端可见字符的最大允许字节数。通过设置这个属性，你可以将listbox变窄。</para></sect3></sect2><sect2><title>实况数据</title>
<para>就像grid<footnote>
<para>此概念类似于Swing(<code>javax.swing.ListModel</code>)。 </para>
</footnote>，listbox支持live data。使用了实况数据，开发人员可以将数据从视图分离。换句话说，开发人员仅需要实现<code>org.zkoss.zul.ListModel</code>接口提供数据，而不用直接操作listbox。好处有以下两点，</para>
<itemizedlist>
<listitem>
<para>易于使用不同的视图来显示相同的数据。</para>
</listitem>
<listitem>
<para>listbox仅在其可见时才会将数据送至客户端。在数据量巨大时可以减少大量的网络流量。</para>
</listitem>
</itemizedlist>
<para>使用实况数据需要经过三步，</para>
<orderedlist>
<listitem>
<para>以<code>ListModel</code>形式准备好数据。ZK有一个称为<code>org.zkoss.zul.SimpleListModel</code>的具体实现，用于显示一个数组对象。 </para>
</listitem>
<listitem>
<para>实现<code>org.zkoss.zul.ListitemRenderer</code>接口用于将一个数据项目送至listbox的一个列白哦项目。</para>
</listitem>
<itemizedlist>
<listitem>
<para>这是可选的。若为指定，默认的渲染器(renderer)会启，并将数据送至第一列。</para>
</listitem>
<listitem>
<para>你可以实现不同的渲染器(renderer)，这样可以在不同的视图中显示相同的数据。</para>
</listitem>
</itemizedlist>
<listitem>
<para>在<code>model</code>属性中指定数据，并且可以选择在<code>itemRenderer</code>属性指定渲染器(renderer)。</para>
</listitem>
</orderedlist>
<para>在下面的例子中,我们准备了一个<code>strset</code>列表模型(list model)，通过model属性将其指派给一个listbox。然后，listbox会处理余下的工作。</para>
<programlisting>&lt;window title="Livedata Demo" border="normal"&gt;&#13;<inlinegraphic fileref="img/7-9-11.png" align="right"/>   &lt;zscript&gt;&#13;      String[] data = new String[30];&#13;      for(int j=0; j &amp;lt; data.length; ++j) {&#13;         data[j] = "option "+j;&#13;      }&#13;      ListModel strset = new SimpleListModel(data);&#13;   &lt;/zscript&gt;&#13;   &lt;listbox width="200px" rows="10" model="${strset}"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Load on demend"/&gt;&#13;      &lt;/listhead&gt;&#13;   &lt;/listbox&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect3><title>为实况数据排序</title>
<para>若你允许用户为一个提供实况数据的listbox排序，你可以实现<code>org.zkoss.zul.ListModel</code>和<code>org.zkoss.zul.ListModelExt</code>接口。</para>
<programlisting>class MyListModel implements ListModel, ListModelExt {&#13;   public void sort(Comparator cmpr, boolean ascending) {&#13;      //do the real sorting&#13;      //notify the listbox (or grid) that data is changed by use of ListDataEvent&#13;   }&#13;}&#13;</programlisting>
<para>当用户向listbox发出排序请求时，listbox将会调用<code>ListModelExt</code>的<code>sort</code>方法为数据排序。换句话说，排序是由列表模型处理的，而不是listbox。</para>
<para>排好序之后，列表模型会调用<code>org.zkoss.zul.event.ListDataListener</code>实例(通过<code>addListDataListener</code>方法注册到<code>listbox</code>)的<code>onChange</code>方法通知listbox。在大多数情况下，所有的数据通常会改变，所以列表模型通常发出下列事件：</para>
<para>
<programlisting>new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1)</programlisting>
</para>
<para>注:<code>ListModel</code> 和 <code>ListModelExt</code>的实现与视觉表现是独立的。换言之，它可以被用于grid ,listbox及其它支持<code>ListModel</code>的任意组件。 </para>
<para>换言之，为了获得最大的灵活性，你应该假定不使用组件，而使用<code>ListDataEvent</code>通信。</para></sect3></sect2><sect2><title>包含按钮的列表框</title>
<para>理论上，listcell可以包含任意的其它组件，如下所述。</para>
<programlisting>&lt;listbox width="250px"&gt;&#13;<inlinegraphic fileref="img/7-9-12.png" align="right"/>   &lt;listhead&gt;&#13;      &lt;listheader label="Population"/&gt;&#13;      &lt;listheader label="Percentage"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem value="A"&gt;&#13;      &lt;listcell&gt;&lt;textbox value="A. Graduate"/&gt;&lt;/listcell&gt;&#13;      &lt;listcell label="20%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="B"&gt;&#13;      &lt;listcell&gt;&lt;checkbox label="B. College"/&gt;&lt;/listcell&gt;&#13;      &lt;listcell&gt;&lt;button label="23%"/&gt;&lt;/listcell&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="C"&gt;&#13;      &lt;listcell label="C. High School"/&gt;&#13;      &lt;listcell&gt;&lt;textbox cols="8" value="40%"/&gt;&lt;/listcell&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>

<para>[注]:</para>
<orderedlist>
<listitem>
<para>若使用grid更好，则不要使用listbox。它们的外观类似，但listbox应仅用于呈现可选项目的列表。</para>
</listitem>
<listitem>
<para>若listbox包括可编辑的组件，例如<code>textbox</code>和<code>checkbox</code>，则会引起用户的困惑。一个普遍的问题使，用户在一个未选中的项目内输入文本。</para>
</listitem>
<listitem>
<para>由于浏览器的限制，用户不能从文本框(text box)内选择一段文字。 </para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>树控件</title>
<para>组件: <code>tree</code>，<code>treechildren</code>，<code>treeitem</code>，<code>treerow</code>，<code>treecell</code>，<code>treecols</code> 和 <code>treecol</code>。</para>
<para>tree包含了两部分：一套专栏 (column)，及树体(tree body)。 专栏由若干<code>treecol</code>组件定义，一个对应一个专栏。每个专栏都会作为页眉(header)出现在树顶。第二部分，树体，包含了出现在树中的数据，由<code>treechildren</code>组件创建。</para>
<para>一个数控件的例子如下：</para>
<programlisting>&lt;tree id="tree" rows="5"&gt;&#13;<inlinegraphic fileref="img/7-10.png" align="right"/>   &lt;treecols&gt;&#13;      &lt;treecol label="Name"/&gt;&#13;      &lt;treecol label="Description"/&gt;&#13;   &lt;/treecols&gt;&#13;   &lt;treechildren&gt;&#13;      &lt;treeitem&gt;&#13;         &lt;treerow&gt;&#13;                &lt;treecell label="Item 1"/&gt;&#13;                &lt;treecell label="Item 1 description"/&gt;&#13;         &lt;/treerow&gt;&#13;      &lt;/treeitem&gt;&#13;      &lt;treeitem&gt;&#13;         &lt;treerow&gt;&#13;            &lt;treecell label="Item 2"/&gt;&#13;            &lt;treecell label="Item 2 description"/&gt;&#13;         &lt;/treerow&gt;&#13;         &lt;treechildren&gt;&#13;            &lt;treeitem&gt;&#13;                   &lt;treerow&gt;&#13;                  &lt;treecell label="Item 2.1"/&gt;&#13;               &lt;/treerow&gt;&#13;                   &lt;treechildren&gt;&#13;                  &lt;treeitem&gt;&#13;                   &lt;treerow&gt;&#13;                          &lt;treecell label="Item 2.1.1"/&gt;&#13;                   &lt;/treerow&gt;&#13;                  &lt;/treeitem&gt;&#13;                  &lt;treeitem&gt;&#13;                   &lt;treerow&gt;&#13;                          &lt;treecell label="Item 2.1.2"/&gt;&#13;                   &lt;/treerow&gt;&#13;                  &lt;/treeitem&gt;&#13;               &lt;/treechildren&gt;&#13;            &lt;/treeitem&gt;&#13;            &lt;treeitem&gt;&#13;               &lt;treerow&gt;&#13;                      &lt;treecell label="Item 2.2"/&gt;&#13;                  &lt;treecell label="Item 2.2 is something who cares"/&gt;&#13;               &lt;/treerow&gt;&#13;            &lt;/treeitem&gt;&#13;         &lt;/treechildren&gt;&#13;      &lt;/treeitem&gt;&#13;      &lt;treeitem label="Item 3"/&gt;&#13;   &lt;/treechildren&gt;&#13;&lt;/tree&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>tree</code>：这是<code>tree</code>组件的外层。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treecols</code>：<code>treecol</code>组件的容器。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treecol</code>：用于声明<code>tree</code>的一列(<code>column</code>)。使用此组件，你可以指定额外的信息，如列的标头。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treechildren</code>：包含了<code>tree</code>的主体，此组件包含了一个<code>treeitem</code>的集合。</para>
</listitem>
<listitem>
<para>
<code>treeitem</code>：此组件包含了一行数据(<code>treerow</code>)，及可选的<code>treechildren</code>。</para>
<itemizedlist>
<listitem>
<para>若组件没有包含<code>treechildren</code>，则它为一个不接受任何子项目的叶子节点。</para>
</listitem>
<listitem>
<para>若组件包含了<code>treechildren</code>，则它为一个可以可以包含其它项的分支节点。 </para>
</listitem>
<listitem>
<para>对于一个分支节点，一个+/-按钮将会出现在此行的开始，这样用户可以通过点击+/- 按钮来打开或关闭此项。 </para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
<code>treerow</code>： tree中的单独行，需要放置在<code>treeitem</code>组件内。 </para>
</listitem>
<listitem>
<para>
<code>treecell</code>： treerow中的单独元素(cell) 。此元素将要放在<code>treerow</code>组件内。 </para>
</listitem>
</itemizedlist>
<para>无鼠标输入<code>tree</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>UP</code> 和 <code>DOWN</code> ，上下移动tree项目中的选中项。 </para>
</listitem>
<listitem>
<para>
<code>PgUp</code> 和 <code>PgDn</code> ，以一页的步长上下移动选中项。 </para>
</listitem>
<listitem>
<para>
<code>HOME</code> ，选中首行， <code>END</code> ，选中末行。</para>
</listitem>
<listitem>
<para>
<code>RIGHT</code> ，打开一个tree项目， <code>LEFT</code> 关闭一个tree项。</para>
</listitem>
<listitem>
<para>
<code>Ctrl+UP</code> 和 <code>Ctrl+DOWN</code>，上下移动一个<code>tree</code>项的聚焦，但并不改变选中项。 </para>
</listitem>
<listitem>
<para>
<code>SPACE</code> 选中聚焦项。</para>
</listitem>
</itemizedlist><sect2><title>
<code>open</code>属性和<code>onOpen</code>事件</title>
<para>每一个tree项都有一个<code>open</code>属性来控制是否显示其子项目。默认值为true。通过将此属性设置为false，你可以控制tree的哪部分不可见。 </para>
<programlisting>&lt;treeitem open="false"&gt; &#13;</programlisting>
<para>当用户点击+/-按钮时，他会打开tree项并使其子项目可见。<code>onOpen</code>事件会被发送至服务器通知应用程序。</para>
<para>对于更复杂的应用程序，你可以延迟tree项的创建或动态操作tree项的内容，直到接收了<code>onOpen</code>事件。参考ZK用户标记语言(ZK User Interface Markup Language)一章中的随机存取(Load on Demand)部分获取细节。</para></sect2><sect2><title>多选</title>
<para>当用户点击一个tree项时，整个项目会被选中且<code>onSelect</code>事件会被送回至服务器通知应用程序。通过将<code>multiple</code>属性设置为true，你可以控制tree控件是否允许多选。默认值为false。</para></sect2><sect2><title>分页</title>
<para>
<code>pageSize</code>属性控制一次显示的tree项目的个数。默认为10。也就是在客户端每一层最多显示10个tree项目，如右图所示。</para>
<para>
用户可以通过点击<inlinegraphic fileref="img/7-10-2b.png"/>来显示更多的tree项目(即加大<code>pageSize</code>)，或点击<inlinegraphic fileref="img/7-10-2c.png"/>或<inlinegraphic fileref="img/7-10-2d.png"/>来上下滚动。</para>
<para>若你想显示所有的tree项目，只需简单的将<code>pageSize</code>设为-1。但是，由于浏览器处理含有大量项目的tree时是非常慢的，所以若tree控件比较大的话不推荐这样做。<inlinegraphic fileref="img/7-10-2a.png" align="right"/></para>
<para>除了tree控件的<code>pageSize</code>属性，你可以通过每个<code>treechildren</code>相应的<code>pageSize</code>属性改变每个<code>treechildren</code>实例的页大小。</para><sect3><title>
<code>onPaging</code>和 <code>onPageSize</code>事件</title>
<para>
当用户点击<inlinegraphic fileref="img/7-10-2c.png"/>或
<inlinegraphic fileref="img/7-10-2d.png"/>来上下滚动某一页时，<code>onPaging</code>事件会协同 <code>org.zkoss.zul.event.PagingEvent</code>实例被发出。类似的，当用户点击<inlinegraphic fileref="img/7-10-2b.png"/>时，<code>onPageSize</code>事件会协同<code>org.zkoss.zul.event.PageSize</code>实例被发出。</para></sect3></sect2><sect2><title>特殊属性</title><sect3><title>
<code>rows</code>属性</title>
<para>
<code>rows</code>属性控制多少行可见。通过将其设置为zero，tree控件会改变其自身大小来容纳近可能多的项目。</para></sect3><sect3><title>
<code>checkmark</code>属性</title>
<para>
<code>c</code>
<code>heckmark</code>属性控制是否在每个tree项的前面显示一个复选框或一个单选按钮。</para>
<para>
<graphic fileref="img/7-10-3-2.png" align="center"/>
</para></sect3><sect3><title>
<code>vflex</code>属性</title>
<para>
<code>vflex</code>属性控制是否在垂直方向增长或缩小以适合指定空间。即所谓的垂直柔性。例如，如果tree太大以至于不适合浏览器窗口，此属性会缩小tree的高度以控制整个tree在浏览器内可见。</para>
<para>若指定了rows属性则此属性会被忽略。</para></sect3><sect3><title>
<code>maxlength</code>属性</title>
<para>
<code>maxlength</code>属性定义了浏览器端可见字符的最大允许字节数。通过设置这个属性，你可以将tree变窄。</para></sect3><sect3><title>可变列宽</title>
<para>就像<code>columns</code>，你可以将<code>treecols</code>的<code>sizable</code>属性设置为<code>true</code>来允许用户改变tree的列宽。类似的，当用户改变宽度时<code>onColSize</code>事件被发出。</para></sect3></sect2><sect2><title>Tree控件的打开时创建</title>
<para>如下所述，你可以监听<code>onOpen</code>事件，然后加载一个tree项目的子组件。类似的，你也可以groupbox为这样做。</para>
<programlisting>&lt;tree width="200px"&gt;&#13;   &lt;treecols&gt;&#13;      &lt;treecol label="Subject"/&gt;&#13;      &lt;treecol label="From"/&gt;&#13;   &lt;/treecols&gt;&#13;   &lt;treechildren&gt;&#13;      &lt;treeitem open="false" onOpen="load()"&gt;&#13;         &lt;treerow&gt;&#13;                &lt;treecell label="Intel Snares XML"/&gt;&#13;                &lt;treecell label="David Needle"/&gt;&#13;         &lt;/treerow&gt;&#13;         &lt;treechildren/&gt;&#13;      &lt;/treeitem&gt;&#13;   &lt;/treechildren&gt;&#13;   &lt;zscript&gt;&#13;   void load() {&#13;      Treechildren tc = self.getTreechildren();&#13;      if (tc.getChildren().isEmpty()) {&#13;         Treeitem ti = new Treeitem();&#13;         ti.setLabel("New added");&#13;         ti.setParent(tc);&#13;      }&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/tree&gt;&#13;</programlisting></sect2></sect1><sect1><title>下拉列表框</title>
<para>组件： <code>combobox</code> 和 <code>comboitem</code>。</para>
<para>combobox是一个内嵌下拉列表的特殊文本框。使用combobox，除了直接输入文本，用户还可以从下拉列表中选择一项。</para>
<programlisting>&lt;combobox&gt;&#13;<inlinegraphic fileref="img/7-11.png" align="right"/>   &lt;comboitem label="Simple and Rich"/&gt;&#13;   &lt;comboitem label="Cool!"/&gt;&#13;   &lt;comboitem label="Ajax and RIA"/&gt;&#13;&lt;/combobox&gt;&#13;</programlisting>
<para>无鼠标输入combobox</para>
<itemizedlist>
<listitem>
<para>
<code>Alt+DOWN</code> ，弹出列表。</para>
</listitem>
<listitem>
<para>
<code>Alt+UP</code> 或 <code>ESC</code> 关闭列表 。</para>
</listitem>
<listitem>
<para>
<code>UP</code> 和 <code>DOWN</code> 改变列表项目的选种项。 </para>
</listitem>
</itemizedlist><sect2><title>
<code>autodrop</code>属性</title>
<para>
默认情况下，直到用户点击<inlinegraphic fileref="img/7-11-1.png"/>，或按下<code>Alt+DOWN</code>后，列表才会打开。但是，你可以将<code>autodrop</code>属性设为 true ，这样当用户键入任何字符时下拉列表就会打开。这对于初学者来说是有帮助的，但是这或许会令有经验的用户感到厌烦。</para>
<programlisting>&lt;combobox autodrop="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>description</code>属性</title>
<para>你可以为每个comboitem添加一个描述使其易于理解。此外，你可以为每个comboitem指派一张图像。</para>
<programlisting>&lt;combobox&gt;&#13;   &lt;comboitem label="Simple and Rich" image="/img/coffee.gif"&#13;   description="The simplest way to make Web applications rich"/&gt;&#13;   &lt;comboitem label="Cool!" image="/img/corner.gif"&#13;   description="The coolest technology"/&gt;&#13;   &lt;comboitem label="Ajax and RIA" image="/img/cubfirs.gif"&#13;   description="Rich Internet Application by Ajax"/&gt;&#13;&lt;/combobox&gt;&#13;</programlisting>
<para>就像其它的支持图像的组件，你可以使用<code>setImageContent</code>方法来为<code>comboitem</code>组件指派一个动态生成的图像。参考图像章节来获取细节。<graphic fileref="img/7-11-2.png" align="center"/></para></sect2><sect2><title>
<code>onOpen事件</code>
</title>
<para>当用户打开下拉列表时，<code>onOpen</code>事件被发送至应用程序。为了延迟comboitem的创建，你可以按如下所示的方法使用<code>fulfill</code>属性。</para>
<programlisting>&lt;combobox fulfill="onOpen"&gt;&#13;<inlinegraphic fileref="img/7-11-3.png" align="right"/>   &lt;comboitem label="Simple and Rich"/&gt;&#13;   &lt;comboitem label="Cool!"/&gt;&#13;   &lt;comboitem label="Ajax and RIA"/&gt;&#13;&lt;/combobox&gt;&#13;</programlisting>
<para>或者，你可以监听<code>onOpen</code>事件，然后在事件监听器中准备下拉列表或动态的改变列表，如下所示，</para>
<programlisting>&lt;combobox id="combo" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&#13;   void prepare() {&#13;      if (event.isOpen() &amp;amp;&amp;amp; combo.getItemCount() == 0) {&#13;         combo.appendItem("Simple and Rich");&#13;         combo.appendItem("Cool!");&#13;         combo.appendItem("Ajax and RIA");&#13;      }&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>
<code>appendItem</code>方法等价于创建一个comboitem，然后将其父组件指派为comobox。</para></sect2><sect2><title>
<code>onChanging</code>事件</title>
<para>由于combobox也是一个文本框，如果你为它添加了一个事件监听器，<code>onChanging</code>事件会被发出。通过监听此事件，你可以像Google Suggests<footnote>
<para>http://www.google.com/webhp?complete=1&amp;hl=en</para>
</footnote>那样操纵下拉列表。此特性有时被称为文本框的自动填充(autocomplete)。</para>
<para>如下所示，你可以基于用户的输入来填充下拉列表。</para>
<programlisting>&lt;combobox id="combo" autodrop="true" onChanging="suggest()"/&gt;&#13;&lt;zscript&gt;&#13;   void suggest() {&#13;      combo.getItems().clear();&#13;      if (event.value.startsWith("A")) {&#13;         combo.appendItem("Ace");&#13;         combo.appendItem("Ajax");&#13;         combo.appendItem("Apple");&#13;      } else if (event.value.startsWith("B")) {&#13;         combo.appendItem("Best");&#13;         combo.appendItem("Blog");&#13;      }&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>注意，当接收<code>onChanging</code>事件时，combobox的内容并不会改改变。因此，你不能使用combobox的<code>value</code>属性。而要使用事件 (<code>org.zkoss.zk.ui.event.InputEvent</code>)的<code>value</code>属性。</para></sect2></sect1><sect1><title>Bandboxes</title>
<para>组件： <code>bandbox</code> 和 <code>bandpopup</code>。</para>
<para>
bandbox是一个内嵌定制弹出window (亦称下拉window )的特殊文本框，bandbox由一个输入文本框和一个弹出window组成。当用户按下<code>Alt+DOWN</code>或点击<inlinegraphic fileref="img/7-12-2.png"/>按钮时，弹出window会自动打开。</para>
<para>不同于combobox，bandbox的弹出window可以包含任何组件。这样的设计给了开发人员最大的自由。一个典型的应用是将弹出window 作为一个查询对话框。</para>
<para/>
<programlisting>&lt;bandbox id="bd"&gt;&#13;      &lt;bandpopup&gt;&lt;vbox&gt;&#13;      &lt;hbox&gt;Search &lt;textbox/&gt;&lt;/hbox&gt;&#13;      &lt;listbox width="200px"      onSelect="bd.value=self.selectedItem.label; bd.closeDropdown();"&gt;&#13;         &lt;listhead&gt;&#13;            &lt;listheader label="Name"/&gt;&#13;<inlinegraphic fileref="img/7-12b.png" align="right"/>            &lt;listheader label="Description"/&gt;&#13;         &lt;/listhead&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="John"/&gt;&#13;            &lt;listcell label="CEO"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Joe"/&gt;&#13;            &lt;listcell label="Engineer"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Mary"/&gt;&#13;            &lt;listcell label="Supervisor"/&gt;&#13;         &lt;/listitem&gt;&#13;      &lt;/listbox&gt;&lt;/vbox&gt;&#13;      &lt;/bandpopup&gt;&#13;   &lt;/bandbox&gt;&#13;</programlisting>
<para/>
<para>无鼠标输入<code>bandbox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>Alt+DOWN</code> ，弹出列表。</para>
</listitem>
<listitem>
<para>
<code>Alt</code>+<code>UP</code> 或 <code>ESC</code> 关闭列表。</para>
</listitem>
<listitem>
<para>
<code>UP</code> 和 <code>DOWN</code> 改变列表的选中项。</para>
</listitem>
</itemizedlist><sect2><title>
<code>closeDropdown</code>方法</title>
<para>弹出window可以包含任意类型的组件，所以当一个列表的某个项目被选中时，复制出选中值或关闭弹出window是开发人员的工作。</para>
<para>在上面的例子中，我们复制选中项目的标签到bandbox ，然后使用下面的语句关闭弹出window。</para>
<programlisting>&lt;listbox width="200px"  onSelect="bd.value=self.selectedItem.label; bd.closeDropdown();"&gt;&#13;</programlisting></sect2><sect2><title>
<code>autodrop</code>属性</title>
<para>
默认情况下，直到用户点击<inlinegraphic fileref="img/7-12a.png"/>按钮或按下<code>Alt</code>+<code>DOWN</code>时，弹出window才会打开。但是，你可以将<code>autodrop</code>属性设置为true，这样当用户键入任意字符时弹出window就会打开。这对于初学者来说是有帮助的，但是这或许会令有经验的用户感到厌烦。</para>
<programlisting>&lt;bandbox autodrop="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>onOpen</code>
<code>事件</code>
</title>
<para>若用户打开了弹出window，<code>onOpen</code>事件会被发送至应用程序。通过将<code>fulfill</code>属性设置为<code>onOpen</code>，你可以延迟弹出window的创建。</para>
<programlisting>&lt;bandbox fulfill="onOpen"&gt;&#13;   &lt;bandpopup&gt;&#13;   ...&#13;   &lt;/bandpopup&gt;&#13;&lt;/bandbox&gt;&#13;</programlisting>
<para>或者，通过监听<code>onOpen</code>事件你可以在Java代码中准备弹出window，如下所示。</para>
<programlisting>&lt;bandbox id="band" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&#13;   void prepare() {&#13;      if (event.isOpen() &amp;amp;&amp;amp; band.getPopup() == null) {&#13;         ...//create child elements&#13;      }&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting></sect2><sect2><title>
<code>onChanging</code>事件</title>
<para>由于bandbox也是一个文本框，如果你为它添加了一个事件监听器，<code>onChanging</code>事件会被发出。通过监听此事件，你可以随意操纵弹出window。</para>
<para>如下所示，你可以基于用户的输入来填充下拉列表。</para>
<programlisting>&lt;bandbox id="band" autodrop="true" onChanging="suggest()"/&gt;&#13;&lt;zscript&gt;&#13;   void suggest() {&#13;      if (event.value.startsWith("A")) {&#13;         ...//do something&#13;      } else if (event.value.startsWith("B")) {&#13;         ...//do another&#13;      }&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>注意，当接收<code>onChanging</code>事件时，bandbox的内容并不会改改变。因此，你不能使用bandbox的<code>value</code>属性。而要使用事件 (<code>org.zkoss.zk.ui.event.InputEvent</code>)的<code>value</code>属性。</para></sect2></sect1><sect1><title>图表</title>
<para>组件:<code>chart</code>
</para>
<para>chart用于显示以图形方式一组数据。它可以帮助用户以快照形式判断某事物。</para>
<para>使用<code>chart</code>组件非常直观。在数据模型中准备合适的数据且将其送入chart。下面为一个饼图的例子。</para>
<para/>
<programlisting>&lt;chart id="mychart" type="pie" width="400" height="200" threeD="true" fgAlpha="128"&gt;&#13;  &lt;zscript&gt;&lt;![CDATA[&#13;   PieModel model = new SimplePieModel();&#13;   model.setValue("C/C++", new Double(17.5));&#13;   model.setValue("PHP", new Double(32.5));&#13;   model.setValue("Java", new Double(43.2));&#13;   model.setValue("VB", new Double(10.0));&#13;   mychart.setModel(model);&#13;  ]]&gt;&lt;/zscript&gt;&#13;&lt;/chart&gt;&#13;</programlisting>
<para>
<graphic fileref="img/7-13.png"/>
</para>
<para>不同类型的chart 用于展示不同类型的数据；因此，chart必须提供合适的数据模型。对于饼图，开发人员必须提供PieModel 作为它们的数据模型，而柱状图，线图，面积图和瀑布图 (bar chart，line chart， area chart， and waterfall chart) 需要 CategoryModel 和 XYModel 。</para><sect2><title>实况数据</title>
<para>上面的例子有一点点令人误解。实际上，在将数据填充到chart前，开发人员不一定必须准备真实的数据，因为chart组件支持实况数据机制。使用实况数据，开发人员可以从视图分离出数据。换言之，开发人员可以从数据模型添加，更改及移除数据，而chart会根据此刷新。对于一些高级实现，开发人员甚至可以实现<code>org.zkoss.zul.ChartModel</code>接口来提供他们自己的chart模型。</para></sect2><sect2><title>向下钻取(<code>onClick</code>事件)</title>
<para>当用户查看一个chart，且发现了一些有趣的东西，很自然的用户会想了解关于兴趣点的详细信息。兴趣点通常会是饼图中的一块，柱状图中的一个条形柱，线图中的一点。chart组件支持这样的向下钻取(drill down)功能，通过自动将<code>chart</code>分割成<code>area</code>组件，然后用户可以点击<code>chart</code>来触发一个<code>onClick</code>鼠标事件。然后，开发人员可以定位<code>area</code>组件，并处理相应的向下钻取(do whatever appropriate drill down)。</para>
<para>在<code>area</code>组件的<code>componentScope</code>内，有一些开发人员可以使用的有用信息。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>名称</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>entity</para>
</entry>
<entry>
<para>区域的实体类型。(例如 TITLE, DATA, CATEGORY, LEGEND)</para>
</entry>
</row>
<row>
<entry>
<para>series</para>
</entry>
<entry>
<para>关联数据的连续名称(CategoryModel, XYModel, or HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>category</para>
</entry>
<entry>
<para>关联数据的类别名称 (PieModel or CategoryModel)。</para>
</entry>
</row>
<row>
<entry>
<para>url</para>
</entry>
<entry>
<para>字符串类型的url，用于向下钻取一个遗留(legacy)页面。</para>
</entry>
</row>
<row>
<entry>
<para>value</para>
</entry>
<entry>
<para>关联数据的数值( PieModel or CategoryModel)。</para>
</entry>
</row>
<row>
<entry>
<para>x</para>
</entry>
<entry>
<para>关联数据的x值 (XYModel)。</para>
</entry>
</row>
<row>
<entry>
<para>y</para>
</entry>
<entry>
<para>关联数据的y值 (XYModel)。</para>
</entry>
</row>
<row>
<entry>
<para>date</para>
</entry>
<entry>
<para>关联数据的date值 (HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>open</para>
</entry>
<entry>
<para>关联数据的open值(HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>high</para>
</entry>
<entry>
<para>关联数据的high值 (HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>low</para>
</entry>
<entry>
<para>关联数据的low值 (HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>close</para>
</entry>
<entry>
<para>关联数据的close值 (HiLoModel)。</para>
</entry>
</row>
<row>
<entry>
<para>volume</para>
</entry>
<entry>
<para>关联数据的volume值 (HiLoModel)。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>在下面的例子中，在<code>chart</code>中我们提供了一个<code>onClick</code>事件监听器。它定位<code>area</code>组件并且显示<code>area</code>组件(也就是<code>pie</code>)的分类(category)。</para>
<programlisting>&lt;chart id="mychart" type="pie" width="400" height="250"&gt;&#13;  &lt;attribute name="onClick"&gt;&#13;    alert(self.getFellow(event.getArea()).getAttribute("category"));&#13;  &lt;/attribute&gt;&#13;  &lt;zscript&gt;&lt;![CDATA[&#13;    PieModel model = new PieModel();&#13;    model.setValue("C/C++", new Double(17.5));&#13;    model.setValue("PHP", new Double(32.5));&#13;    model.setValue("Java", new Double(43.2));&#13;    model.setValue("VB", new Double(10.0));&#13;    mychart.setModel(model);&#13;  ]]&gt;&lt;/zscript&gt;&#13;&lt;/chart&gt;&#13;</programlisting></sect2><sect2><title>操作区</title>
<para>Chart组件也提供了一个area渲染器(renderer) 机制，开发人员可以操纵<code>chart</code>的<code>area</code>组件。</para>
<para>使用area渲染器仅需两步。</para>
<orderedlist>
<listitem>
<para>实现<code>org.zkoss.zul.event.ChartAreaListener</code>接口操纵area组件，例如，改变<code>area</code>的 <code>tooltiptext</code>。</para>
</listitem>
<listitem>
<para>将 <code>chart</code>的 <code>areaListener</code>属性设置为监听对象或监听类的名称。 </para>
</listitem>
</orderedlist>
<para>这样，开发人员取得了以一个机会，改变area组件属性或将更多的信息插入打到area组件的<code>componentScope</code>属性，因此可以通过<code>onClick</code>事件监听器。</para></sect2></sect1><sect1><title>拖放</title>
<para>ZK允许用户在用户界面内拖曳特定的组件。例如，将文件拖至其它的目录，或将商品拖至购物车。</para>
<para>若一个组件可以被拖曳则它是可拖曳的。若用户可以将一个可拖曳的组件放入到某一组件内，则称该组件是可放下的(droppable)。</para>
<para>[注]: 在放下后，ZK并不假定关于发生什么的任何行为。这由应用程序开发人员编写<code>onDrop</code>事件监听器来决定。如果应用程序什么也不做，被拖曳的组件只是简单的移回它的初始位置.</para><sect2><title>
<code>draggable</code> 和 <code>droppable</code>属性</title>
<para>使用ZK，通过指派<code>draggable</code>属性除了"<code>false</code>"外的任何值，你可以使一个组件变为可拖曳的。若想禁用，则将其设为"<code>false</code>"。</para>
<programlisting>&lt;image draggable="true"/&gt;&#13;</programlisting>
<para>类似的，可以将droppable属性赋值为"<code>true</code>"来将一个组件变为可放下的。</para>
<programlisting>&lt;hbox droppable="true"/&gt;&#13;</programlisting>
<para>然后，用户可以拖曳一个可拖曳的组件，并将其放入一个可放下的组件。</para></sect2><sect2><title>
<code>onDrop</code> 事件</title>
<para>一旦用户拖曳一个组件并将其放入可放下的另一个组件，<code>onDrop</code>事件会通知用户放入组件的组件。<code>onDrop</code>事件是<code>org.zkoss.ui.event.DropEvent</code>的一个实例。调用<code>getDragged</code>方法，你可以获取什么被拖曳(及放下)了。</para>
<para>注意 <code>onDrop</code>事件的目标是可放下的组件，而不是被拖曳的组件。</para>
<para>下面是一个简单的例子，允许用户使用拖放对列表项目重新排序。</para>
<para>
<graphic fileref="img/7-14-2.png" align="center"/>
</para>
<programlisting>&lt;window title="Reorder by Drag-and-Drop" border="normal"&gt;&#13;   Unique Visitors of ZK:   &lt;listbox id="src" multiple="true" width="300px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Country/Area"/&gt;&#13;         &lt;listheader align="right" label="Visits"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="United States"/&gt;&#13;         &lt;listcell label="5,093"/&gt;&#13;         &lt;listcell label="19.39%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="China"/&gt;&#13;         &lt;listcell label="4,274"/&gt;&#13;         &lt;listcell label="16.27%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="France"/&gt;&#13;         &lt;listcell label="1,892"/&gt;&#13;         &lt;listcell label="7.20%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="Germany"/&gt;&#13;         &lt;listcell label="1,846"/&gt;&#13;         &lt;listcell label="7.03%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="(other)"/&gt;&#13;         &lt;listcell label="13,162"/&gt;&#13;         &lt;listcell label="50.01%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listfoot&gt;&#13;         &lt;listfooter label="Total 132"/&gt;&#13;         &lt;listfooter label="26,267"/&gt;&#13;         &lt;listfooter label="100.00%"/&gt;&#13;      &lt;/listfoot&gt;&#13;   &lt;/listbox&gt;&#13;   &lt;zscript&gt;&#13;   void move(Component dragged) {&#13;      self.parent.insertBefore(dragged, self);&#13;   &#13;}&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>使用多选拖曳</title>
<para>当用户拖放一个列表项或tree项时，这些项目的选择状态不会改变。仅当移动拖曳项时是可视的，但是， 通过查询所有选中项的集合，你可以处理所有的选中项，如下所示。</para>
<programlisting>public void onDrop(DropEvent evt) {&#13;   Set selected = ((Listitem)evt.getDragged()).getListbox().getSelectedItems();&#13;   //then, you can handle the whole set at once&#13;}&#13;</programlisting>
<para>注意，被拖曳项允许并未被选中。因此对于此事例，你或许更喜欢将选中项改变为拖曳项，如下所示。</para>
<programlisting>Listitem li = (Listitem)evt.getDragged();&#13;if (li.isSelected()) {&#13;   Set selected = ((Listitem)evt.getDragged()).getListbox().getSelectedItems();&#13;   //then, you can handle the whole set at once&#13;} else {&#13;   li.setSelected(true);&#13;   //handle li only&#13;}&#13;</programlisting></sect2><sect2><title>可拖曳组件的多种类型的</title>
<para>可放下组件不接受所有的可拖曳组件是和平常的。例如，一个e-mail文件夹只接受e-mail且拒绝联系(contacts)或其它。当调用<code>onDrop</code>时，你可以默默地忽略不可接受的组件，或是发出警告消息。</para>
<para>为了获得更好的视觉效果，你可以使用一个标识来确定每种类型的可拖曳组件，然后将标识赋予<code>draggable</code>属性。</para>
<programlisting>&lt;listitem draggable="email"/&gt;&#13;...&#13;&lt;listitem draggable="contact"/&gt;&#13;</programlisting>
<para>然后，你可以为<code>droppable</code>属性指定一个标识列表来限制可被放下的组件。例如，下面的图像仅接受<code>email</code>和<code>contact</code>。</para>
<programlisting>&lt;image src="/img/send.png" droppable="email, contact" onDrop="send(event.dragged)"/&gt;&#13;</programlisting>
<para>若想接受任何类型的组件，你可以将<code>droppable</code>属性的值设为"<code>true</code>"。例如，下面的图像可以接受任意类型的可拖曳组件。</para>
<programlisting>&lt;image src="/img/trash.png" droppable="true" onDrop="remove(event.dragged)"/&gt;&#13;</programlisting>
<para>另外，如果<code>draggable</code>属性的值为 "<code>true</code>"，则意味着此组件属于匿名类型。此外，只有<code>droppable</code>属性值为"<code>true</code>" 的组件接受此组件。</para></sect2></sect1><sect1><title>HTML相关组件</title>
<para>有两种方法在同一ZUML页面内混合使用HTML组件和XUL组件。</para><sect2><title>
<code>html</code>组件</title>
<para>最简单的方式是使用称为<code>html</code>
<footnote>
<para>html元素内的文本实际上是由html组件的content属性赋值的(而不是成为一个子标签)。 </para>
</footnote> 的XUL组件，在其中嵌入你想直接发送至浏览器的HTML标签。为了避免ZK解释HTML标签，通常要使用&lt;![<code>CDATA</code>[ and ]]&gt;将HTML标签围入其中。换言之，他们并不是子组件。而是被存储在<code>content</code>属性<footnote>
<para>若你不熟悉XML, 参考ZK用户界面标记语言(ZK User Interface Markup Language)一章中关于XML的部分。 </para>
</footnote>内。注意在其中可以使用EL表达式。</para>
<programlisting>&lt;window title="Html Demo"&gt;&#13;   &lt;html&gt;&lt;![CDATA[&#13;      &lt;h4&gt;Hi ${parent.title}&lt;/h4&gt;&#13;      &lt;p&gt;It is the content of the html component. &lt;/p&gt;&#13;   ]]&gt;&lt;/html&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>html</code>组件会产生 HTML <code>SPAN</code> 标签来包围这些内容。因此，你可以像使用其它的XUL组件一样使用它。例如，我们可以指定CSS样式，动态的改变它的内容。</para>
<programlisting>&lt;html id="h" style="border: 1px solid blue;background: yellow"&gt;&lt;![CDATA[&#13;   &lt;ul&gt;&#13;      &lt;li&gt;Native browser content&lt;/li&gt;&#13;   &lt;/ul&gt;&#13;]]&gt;&lt;/html&gt;&#13;&lt;button label="change" onClick="l.setContent(&amp;quot;Hi Update&amp;quot;)"/&gt;&#13;</programlisting>
<para>注意，由于<code>SPAN</code>用于包围嵌入的HTML标签，下面的语句是错误的。</para>
<programlisting>&lt;html&gt;&lt;![CDATA[&#13;   &lt;ul&gt;&#13;      &lt;li&gt; &lt;!-- incomplete since &lt;ul&gt;&lt;li&gt; is inside &lt;span&gt; --&gt;&#13;]]&gt;&lt;/html&gt;&#13;&#13;&lt;textbox/&gt;&#13;&#13;&lt;html&gt;&lt;![CDATA[&#13;      &lt;/li&gt;&#13;   &lt;/ul&gt;&#13;]]&lt;/html&gt;&#13;</programlisting>
<para>如果你需要直接产生嵌入的HTML标签，而不用<code>SPAN</code>包围，你可以使用<code>inline</code>组件，如下所示。</para></sect2><sect2><title>
<code>inline</code>组件</title>
<para>就像<code>html</code>组件，<code>inline</code>用于嵌入你想发送至客户端的HTML标签。但是，并不使用<code>SPAN</code>或其它标签来包围HTML标签。因此，<code>inline</code>可以更灵活的混合HTML标签。例如，</para>
<programlisting>&lt;inline&gt;&lt;![CDATA[&#13;   &lt;ul&gt;&#13;      &lt;li&gt; &lt;!-- incomplete since &lt;ul&gt;&lt;li&gt; is inside &lt;span&gt; --&gt;&#13;]]&gt;&lt;/inline&gt;&#13;&#13;&lt;textbox/&gt;&#13;&#13;&lt;inline&gt;&lt;![CDATA[&#13;      &lt;/li&gt;&#13;   &lt;/ul&gt;&#13;]]&lt;/inline&gt;&#13;</programlisting>
<para>因为只有内容被发送至了客户端，客户端并不知道关于<code>inline</code>组件的一切(也就是，<code>inline</code>在客户端没有可视部分)。因此，介绍一些限制。</para>
<orderedlist>
<listitem>
<para>嵌入的内容不能动态改变。换言之，一旦<code>inline</code>组件的内容被发送至客户端，任何随后更新的内容都不会被送至客户端。也就是说，用户不会看到更新的结果。最遭的情况是，若你将<code>inline</code>组件移到其它父组件，或许会造成客户端的某些运行时错误。因此，最好考虑为<code>inline</code>嵌入static内容。</para>
<para>当然，若你真想更新，可以让父组件失效(invalidate)。然后，父组件及其所有子组件(包括<code>inline</code>组件)会刷新。</para>
</listitem>
<listitem>
<para>
<code>inline</code>并不是一个XUL组件。你可以为它设置CSS样式， tooltip，拖放或其它。</para>
</listitem>
</orderedlist></sect2><sect2><title>混合HTML和XUL组件</title>
<para>使用XML命名空间，开发人员可以混合使用来自HTML和XUL 的组件，如下所示。</para>
<programlisting>&lt;window title="mix HTML demo" xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;<inlinegraphic fileref="img/7-15-3.png" align="right"/>   &lt;h:table border="1"&gt;&#13;      &lt;h:tr id="row1"&gt;&#13;         &lt;h:td&gt;column 1&lt;/h:td&gt;&#13;         &lt;h:td&gt;&#13;            &lt;listbox id="list" mold="select"&gt;&#13;               &lt;listitem label="AA"/&gt;&#13;               &lt;listitem label="BB"/&gt;&#13;                &lt;/listbox&gt;&#13;             &lt;/h:td&gt;&#13;      &lt;/h:tr&gt;&#13;   &lt;/h:table&gt;&#13;   &lt;button label="add" onClick="new org.zkoss.zhtml.Td().append(row1)"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>不同于<code>html</code>和<code>inline</code>组件，在<code>content</code>属性内存储HTML标签的地方， ZK实际上为每个HTML标签(与<ulink url="http://www.w3.org/1999/xhtml">
<code>http://www.w3.org/1999/xhtml</code>
</ulink>关联)创建了组件。 这样做的优点是可以动态使用每个独立的HTML标签，就像在上面例子中描述的那样(add按钮)。</para>
<para>但是，由于每个HTML标签都与服务器端的一个XHTML组件相关联，所以这样会消耗更多的内存。</para></sect2><sect2><title>
<code>include</code>组件</title>
<para>
<code>include</code>组件用于包含由另一个servlet 产生的输出。servlet可以是任何页面，包括JSF，JSP，甚至另一个ZUML页面。</para>
<programlisting>&lt;window title="include demo" border="normal" width="300px"&gt;&#13;   Hello, World!&#13;   &lt;include src="/userguide/misc/includedHello.zul"/&gt;&#13;   &lt;include src="/html/frag.html"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>就像所有的其它属性，你可以在运行时动态的改变src属性包括来自于不同servlet的输出。</para>
<para>若被包括的输出是另一个ZUML，开发人员被允许访问此ZUML的组件，就好像它们是包含(containing)页面的一部分。</para><sect3><title>包含ZUML页面</title>
<para>如果<code>include</code>组件被用于包含一个ZUML页面，那么被包含的页面会成为桌面的一部分。但是，直到请求被完全处理被包含页面才会可见。换言之，仅当下列的事件被用户或计时器(timer)触发时被包含页面才会可见。</para>
<para>理由是include组件到页面响应阶段<footnote>
<para>参考组件活动周期(Component Lifecycle )一章获取细节。</para>
</footnote>才会包含一个页面。另外zscript 发生在组件创建阶段， onCreate 发生在事件处理阶段。它们都在包含前执行。</para>
<programlisting>&lt;window onCreate="desktop.getPages()"&gt; &lt;!-- the included page not available --&gt;&#13;   &lt;include src="/my.zul"/&gt;&#13;   &lt;zscript&gt;&#13;      desktop.getPages(); //the included page not available yet&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Hit" onClick="desktop.getPages()"/&gt;&#13;      &lt;!-- Yes, the included page is available when onClick is received --&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>若你想浏览被包含页面的组件，宏(macro)组件通常是更好的选择。参考ZK用户界面标记语言一章中关于宏组件的部分。</para></sect3></sect2><sect2><title>
<code>style</code>组件</title>
<para>
<code>style</code>组件被用于在ZUML页面中指定CSS样式。最简单的格式如下。</para>
<programlisting>&lt;style&gt;&#13;<inlinegraphic fileref="img/7-15-4-1.png" align="right"/>.blue {&#13;color: white; background-color: blue;&#13;}&#13;&lt;/style&gt;&#13;&lt;button label="OK" sclass="blue"/&gt;&#13;</programlisting>
<para>[提示]：为整个应用程序配置样式表，可以在zk.xm内指定<code>theme</code>-<code>uri</code>，参考the Developer's Reference中的附录B(Appendix B) 获取细节。 为一中语言配置样式表，可以使用语言插件(language addon)，参考 the Component Development Guide。 </para>
<para>有时将所有的CSS定义放在一个单独的文件中是更好的选择，例如<code>my.css</code>。然后，我们可以使用style组件来引用它，如下。</para>
<programlisting>&lt;style src="/my.css"/&gt;&#13;</programlisting>
<para>上面的语句实际下列的HTMl标签<footnote>
<para>实际的结果取决于Web应用程序的配置。</para>
</footnote>送至服务器，所以指定的文件必须是可被浏览器访问的。</para>
<programlisting>&lt;link rel="stylesheet" href="/css/mystyles.css"/&gt;&#13;</programlisting>
<para>换言之，你不能指定<code>"/WEB-INF/xx" </code>
<code>或</code>
<code>"C:/XX/YY"</code>。</para>
<para>就像其它的URI，<code>style</code>接受"*"来加载浏览器和本地化样式表。参考国际化 一章中关于浏览器和本地化URI的部分获取细节。</para></sect2><sect2><title>
<code>script</code>组件</title>
<para>
<code>script</code>组件用于指定运行在浏览器的脚本代码。注意，不同于<code>zscript</code>，脚本代码运行在浏览器。通常由大多数浏览器支持的JavaScript编写。最简单的格式如下。</para>
<programlisting>&lt;script type="text/javascript"&gt;&#13;function myfunc() {&#13;   $e("${win.uuid}").style.backgroundColor = "blue";&#13;}&#13;&lt;/script&gt;&#13;</programlisting>
<para>如上所示，你可以在脚本代码内使用EL表达式 ($<code>{win.uuid</code>})。</para>
<para>当然，你可以使用<code>src</code>属性引用额外的JavaScript文件，如下。</para>
<programlisting>&lt;script src="/js/super.js" type="text/javascript"/&gt;&#13;</programlisting>
<para>由于ZK应用程序运行在服务器端(使用你最喜欢的语言执行)，开发人员很少需要使用JavaScript代码来执行。它们通常定制ZK客户端引擎的行为，或运行遗留下来的JavaScript库。</para></sect2><sect2><title>
<code>iframe</code>组件</title>
<para>
<code>iframe</code>组件使用HTML IFRAME标签将显示的一部分委托(delegate)给另一个URL。尽管外观看起来与<code>include</code>组件相似，但是<code>iframe</code>组件的概念及意义是不同的。</para>
<para>被<code>include</code>组件包含的内容是整个HTML页面的片断。由于内容是HTML页面的一部分，所以也是桌面的一部分，你可以访问<code>include</code>组件内的任何组件。包含是在服务器进行的，浏览器并不知道。这意味着<code>src</code>属性指定的URL可以是任何内部资源。</para>
<para>
<code>iframe</code>组件的内容是由浏览器加载的，作为一个单独的页面。由于是作为单独的页面被加载，所以内容的格式可以不同于HTML。例如，你可以嵌入一个PDF文件。</para>
<programlisting>&lt;iframe src="/my.pdf"/&gt;&#13;...other HTML content&#13;</programlisting>
<para>[提示]： 默认没有边框。若想启用，使用style属性指定，例如， &lt;<code>iframe style="border:1px inset" src="http://www.zkoss.org"</code>/&gt;</para>
<para>当解释包含IFRAME的标签时，embedding是被浏览器处理的。这也暗示着URL必须为从浏览器可访问的资源。</para>
<para>就像<code>image</code> 和 <code>audio</code>组件<footnote>
<para>在许多方面，<code>iframe</code>类似于<code>image</code> 和 <code>audio</code>。你可以将<code>iframe</code>当成一个可以包含任意内容的组件。</para>
</footnote>，你可以动态指定生成的内容。典型的例子是使用JasperReport<footnote>
<para>http://jasperreports.sourceforge.net</para>
</footnote>生成一个PDF报告，以二进制数组或流格式，然后将结果包装成<code>org.zkoss.util.media.AMedia</code>类传递给<code>iframe</code>组件。</para>
<para>在下面的例子中，我们说明，你可以使用<code>iframe</code>嵌入任何内容，只要客户端支持内容的格式。</para>
<programlisting>&lt;window title="iframe demo" border="normal"&gt;&#13;   &lt;iframe id="iframe" width="95%"/&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;button label="Upload"&gt;&#13;      &lt;attribute name="onClick"&gt;{&#13;         Object media = Fileupload.get();&#13;         if (media != null)&#13;                iframe.setContent(media);&#13;      }&lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>
<graphic fileref="img/7-15-5.png"/>
</para>
</entry>
<entry>
<para>用户上传一个Microsoft PowerPoint文件 ，这张图片描述了上传后的外观。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2></sect1><sect1><title>用HTML FORM 和Java Servlets</title>
<para>事件驱动模型是简单但强大的，但是用事件监听器重写所有的servlets是不实际的。</para><sect2><title>
<code>name</code>属性</title>
<para>为了用遗留的(legacy)Web应用程序，你可以指定<code>name</code>属性，就像在HTML页面那样。例如，</para>
<graphic fileref="img/7-16-1.png"/>
<programlisting>&lt;window xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;  &lt;h:form method="post" action="/my-old-servlet"&gt;&#13;  &lt;grid&gt;&#13;    &lt;rows&gt;&#13;  &lt;row&gt;When &lt;datebox name="when"/&gt; Name &lt;textbox name="name"/&gt; Department&#13;  &lt;combobox name="department"&gt;&#13;    &lt;comboitem label="RD"/&gt;&#13;    &lt;comboitem label="Manufactory"/&gt;&#13;    &lt;comboitem label="Logistics"/&gt;&#13;  &lt;/combobox&gt;&#13;  &lt;/row&gt;&#13;  &lt;row&gt;&#13;    &lt;h:input type="submit" value="Submit"/&gt;&#13;  &lt;/row&gt;&#13;    &lt;/rows&gt;&#13;  &lt;/grid&gt;&#13;  &lt;/h:form&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>一旦用户按下了submit按钮，一个如下查询字符串(query string)请求被提交到<code>my-old-servlet</code> servlet 。</para>
<programlisting>/my-old-servlet?when=2006%2F03%2F01&amp;name=Bill+Gates&amp;department=Manufactory&#13;</programlisting>
<para>因此，只要在name和value间保持适当的关联，servlet就可以如平常一样工作而无需修改。</para></sect2><sect2><title>支持<code>name</code>属性的组件</title>
<para>所有的输入型组件都支持<code>name</code>属性，如<code>textbox</code>，<code>datebox</code>，<code>decimalbox</code>，<code>intbox</code>，<code>combobox</code> 何 <code>bandbox</code>。</para>
<para>此外，listbox和tree 控件也支持<code>name</code>属性。若<code>multiple</code>属性为true，且用户选择了多项，那么多对name/value被提交。</para>
<programlisting>&lt;listbox name="who" multiple="true" width="200px"&gt;&#13;   &lt;listhead&gt;&#13;      &lt;listheader label="name"/&gt;&#13;      &lt;listheader label="gender"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem value="mary&gt;&#13;      &lt;listcell label="Mary"/&gt;&#13;      &lt;listcell label="FEMALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="john"&gt;&#13;<inlinegraphic fileref="img/7-16-2.png" align="right"/>      &lt;listcell label="John"/&gt;&#13;      &lt;listcell label="MALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="jane"&gt;&#13;      &lt;listcell label="Jane"/&gt;&#13;      &lt;listcell label="FEMALE"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="henry"&gt;&#13;      &lt;listcell label="Henry"/&gt;&#13;      &lt;listcell label="MALE"/&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>若选中了John 和 Henry ，那么查询字符串将包含：</para>
<programlisting>who=john&amp;who=henry&#13;</programlisting>
<para>注意，为了使用listbox和tree控件的<code>name</code>属性，你必须分别为<code>listitem</code>和<code>treeitem</code>指定<code>value</code>属性。它们即为被提交到 servlet的值。</para></sect2><sect2><title>丰富用户界面</title>
<para>因为<code>for</code>
<code>m</code>组件可以包含任意类型的组件，丰富的用户界面可以独立地实现，独立于已存在的servlet。例如，你可以监听<code>onOpen</code>事件， 填充(fulfill)一个tab面板，就如前一章节所示。另一个例子，你可以动态的为一个grid控件添加更多的行，每行可以控制一个含有<code>name</code>属性的输入框。一旦用户提交了表单，最新更新的内容会被提交到servlet 。</para></sect2></sect1><sect1><title>客户端行为</title>
<para>某些行为在客户端用JavaScript代码处理更为合适，例如动画和图像转滚(image rollovers)。为了在客户端执行JavaScript 代码，ZK引入了客户端行为(CSA)的概念。使用CSA，开发人员可以监听任何JavaScript事件且在客户端执行JavaScript代码。</para>
<para>CSA类似于事件监听器，除了CSA的行为是用JavaScript 编写的且在客户端执行。ZK允许开发人员为任何 JavaScript事件指定行为，例如<code>onfocus</code>, <code>onblur</code>, <code>onmouseover</code> 和 <code>onmouseout</code>，只要你的目标浏览器支持它们。</para>
<para>CSA的语法如下。</para>
<programlisting>action="[onfocus|onblur|onmouseover|onmouseout|onclick|onshow|onhide...]: javascript;"&#13;</programlisting>
<para>注意CSA是完全独立于ZK事件监听器的，尽管它们或许有相同的名字，例如<code>onFocus</code>。不同点包括：</para>
<orderedlist>
<listitem>
<para>CSA在客户端执行，且在服务器端的ZK事件将监听器被调用前发生。</para>
</listitem>
<listitem>
<para>CSA代码用JavaScript编写，而ZK事件将监听器用Java编写。 </para>
</listitem>
<listitem>
<para>CSA可以注册你的目标浏览器允许的任何事件，而ZK近仅支持在事件(Events)章节中列出的事件。 </para>
</listitem>
</orderedlist><sect2><title>引用一个组件</title>
<para>在JavaScript 代码中，你可以通过晚捆绑(late-binding)EL表达式来引用一个组件或其它对象。晚捆绑EL表达式以 <code>#{</code>开始且以}结束，如下所示。</para>
<programlisting>&lt;button action="onmouseover: action.show(#{parent.tip})"/&gt;&#13;</programlisting>
<para>晚捆绑EL表达式在响应阶段被赋值。另外，如果一个EL表达式以${开始，则它会在组件创建阶段被赋值，在为<code>action</code>属性赋值前。例如，</para>
<programlisting>&lt;button action="onfocus: action.show(${tip}); onblur: action.hide(${tip})"/&gt;&#13;&lt;div id="tip" visible="false"&gt;...&lt;/div&gt;&#13;</programlisting>
<para>将等价于</para>
<programlisting>&lt;button action="onfocus: action.show(); onblur: action.hide()"/&gt;&#13;&lt;div id="tip" visible="false"&gt;...&lt;/div&gt;&#13;</programlisting>
<para>由于<code>tip</code>组件在为<code>action</code>属性赋值时才会被创建。</para>
<para>由于ZUML加载器并不知道CSA，它调用<code>toString</code>方法将组件转换成一个字符串，所以即使在为<code>action</code>属性赋值前创建了被引用组件仍是不正确的。</para>
<para>当然，这并不防碍你在某一action内使用${}，如下所述。仅需记住它是在为<code>action</code>属性赋值前辈赋值的。</para>
<programlisting>&lt;variables myaction="onfocus: action.show(#{tip}); onblur: action.hide(#{tip});"&#13;&lt;button action="${myaction} onmouseover: action.show(#{parent.parent.tip})"/&gt;&#13;</programlisting><sect3><title>一个<code>onfocus</code>和的<code>onblur</code>例子</title>
<para>在下面的例子中，我们展示了如何使用CSA来提供在线帮助。当用户改变了任一个文本框的聚焦时，一条帮助消息就会据此显示。</para>
<programlisting>&lt;grid&gt;&#13;   &lt;columns&gt;&#13;<inlinegraphic fileref="img/7-17-1-1.png" align="right"/>      &lt;column/&gt;&#13;      &lt;column/&gt;&#13;      &lt;column/&gt;&#13;   &lt;/columns&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&#13;&lt;label value="text1: "/&gt;&#13;&lt;textbox action="onfocus: action.show(#{help1}); onblur: action.hide(#{help1})"/&gt;&#13;&lt;label id="help1" visible="false" value="This is help for text1."/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;&lt;label value="text2: "/&gt;&#13;&lt;textbox action="onfocus: action.show(#{help2}); onblur: action.hide(#{help2})"/&gt;&#13;&lt;label id="help2" visible="false" value="This is help for text2."/&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&lt;/grid&gt;&#13;</programlisting></sect3><sect3><title>强制规则</title>
<para>ZUL组件实际上是将一个EL表达式 (#{}) 转换为合适的JavaScript代码，基于结果对象的类。</para>
<orderedlist>
<listitem>
<para>若结果为<code>null</code>，则用<code>null</code>替换。</para>
</listitem>
<listitem>
<para>若结果为一个组件，则用$<code>e</code>('<code>uuid</code>')替换， $<code>e</code> 处为一个返回HTML 标签引用的JavaScript函数，<code>uuid</code>为组件的UUID。</para>
</listitem>
<listitem>
<para>若结果为一个<code>Date</code>对象，则用<code>new</code> <code>Date</code>(<code>milliseconds</code>)替换。</para>
</listitem>
<listitem>
<para>否则。结果调用<code>toString</code>方法将结果转换为一个字符串，然后用'<code>result</code> <code>in</code> <code>string</code>'替换。</para>
</listitem>
</orderedlist></sect3></sect2><sect2><title>
<code>onshow</code>和<code>onhide</code> 行为</title>
<para>
<code>onshow</code>和<code>onhide</code>行为被用于控制显示及隐藏一个组件的视觉效果。</para><sect3><title>改变window如何出现的例子</title>
<programlisting>&lt;zk&gt;&#13;   &lt;button label="Show Overlapped" onClick="win.doOverlapped();"/&gt;&#13;   &lt;window id="win" border="normal" width="200px" mode="overlapped"&#13;action="onshow:anima.appear(#{self});onhide:anima.fade(#{self})" visible="false"&gt;&#13;      &lt;caption image="/img/inet.png" label="Hi there!"/&gt;&#13;      &lt;checkbox label="Hello, Effect!"/&gt;&#13;   &lt;/window&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect3></sect2><sect2><title>CSA JavaScript工具</title>
<para>为节简化CSA编程，ZK提供了一些你可以利用的工具对象。</para><sect3><title>
<code>action</code>对象</title>
<para>可用于任何对象的基本工具。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>函数</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>action.show(cmp)</code>
</para>
</entry>
<entry>
<para>使一个组件可见。</para>
<para>
<code>cmp</code> – 组件。 使用 <code>#{</code>
<code>EL-expr</code>
<code>}</code> 标识它。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>action.hide(cmp)</code>
</para>
</entry>
<entry>
<para>使一个组件不可见。</para>
<para>
<code>cmp</code> – 组件。 Use #{<code>EL</code>-<code>expr</code>} 标识它。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>[提示]： 对于JavaScript程序员，直接操纵样式用于显示是很平常的。但是，这并不是一个好主意。而是使用<code>action.show</code> and <code>action.hide</code>代替，因为ZK客户端引擎必须处理视觉效果，bug workaround，等等。 </para></sect3><sect3><title>
<code>anima</code>对象</title>
<para>动画般的视觉效果。基于<ulink url="http://script.aculo.us/">script.aculo.us</ulink>
<ulink url="http://script.aculo.us/">
<footnote>
<para>
<ulink url="http://script.aculo.us/">http://script.aculo.us</ulink> 提供簡單好用的JavaScript libraries。</para>
</footnote>
</ulink>提供的<ulink url="http://wiki.script.aculo.us/scriptaculous/show/VisualEffects">Effect</ulink> 类。API被简化了。若你想要更多的视觉效果或空间，可以直接访问<ulink url="http://wiki.script.aculo.us/scriptaculous/show/VisualEffects">Effect</ulink>。</para>
<para>[注]：<ulink url="http://wiki.script.aculo.us/scriptaculous/show/VisualEffects">Effect</ulink>要求组件使用<code>DIV</code>标签包围。并不是所有的ZUL组件都以这种方式被实现。若你有疑问，可以与<code>div</code>组件嵌套使用，如下。</para>
<programlisting>&lt;window&gt;&#13;   &lt;div id="t" visible="false"&#13;   action="onshow: anima.slideDown(#{self}); onhide: anima.slideUp(#{self})"&gt;&#13;      &lt;div&gt;&lt;!-- the 2nd div is optional but sometimes it looks better with it --&gt;&#13;         &lt;groupbox&gt;&#13;                &lt;caption label="slide down"/&gt;&#13;                Hi &lt;textbox/&gt;&#13;         &lt;/groupbox&gt;&#13;         When? &lt;datebox/&gt;&#13;      &lt;/div&gt;&#13;   &lt;/div&gt;&#13;   &lt;button label="toggle" onClick="t.visible = !t.visible"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当然，你加载的其它库并没有这个限制。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>函数</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>ani</code>
<code>ma.appear(cmp)</code> 
<code>anima.appear(cmp, dur)</code>
</para>
</entry>
<entry>
<para>通过增加透明度(opacity)来使组件可见。</para>
<para>
<code>cmp</code> – 组件。使用 #{<code>EL</code>-<code>expr</code>} 标识它。</para>
<para>
<code>dur</code> – 以毫秒为单位的持续时间(duration)。 默认： 800。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.slideDown(cmp)</code> 
<code>anima.slideDown(cmp, dur)</code>
</para>
</entry>
<entry>
<para>以滑盖式(slide-down )效果来使组件可见。</para>
<para>
<code>cmp</code> – 组件。使用 #{EL-expr} 标识它。</para>
<para>
<code>dur</code> – 以毫秒为单位的持续时间。默认： 400。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.slideUp(cmp)</code> 
<code>anima.slideUp(cmp, dur)</code>
</para>
</entry>
<entry>
<para>以滑起来(slide-up)效果来使组件不可见。</para>
<para>
<code>cmp</code> – 组件。使用 #<code>{</code>
<code>EL-expr</code>
<code>}</code> 标识它。</para>
<para>
<code>dur</code> – 以毫秒为单位的持续时间。默认：400。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.fade(cmp) anima.fade(cmp, dur)</code>
</para>
</entry>
<entry>
<para>通过褪色组件不可见。</para>
<para>
<code>cmp</code> – 组件。使用 #<code>{</code>
<code>EL-expr</code>
<code>}</code> 标识它。</para>
<para>
<code>dur</code> – 以毫秒为单位的持续时间。默认：550。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.puff(cmp) anima.puff(cmp, dur)</code>
</para>
</entry>
<entry>
<para>通过膨胀(puff out)使组件不可见。</para>
<para>
<code>cmp</code> – 组件。使用 #<code>{</code>
<code>EL-expr</code>
<code>}</code> 标识它。</para>
<para>
<code>dur</code> – 以毫秒为单位的持续时间。默认： 700。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.dropOut(cmp) anima.dropOut(cmp, dur)</code>
</para>
</entry>
<entry>
<para>通过褪色及放下(drop)使组件不可见。</para>
<para>
<code>cmp</code> – 组件。使用 #<code>{</code>
<code>EL-expr</code>
<code>}</code> 标识它。</para>
<para>
<code>d</code>
<code>ur</code> – 以毫秒为单位的持续时间。默认： 700。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>例如，</para>
<programlisting>&lt;window title="Animation Effects"&gt;&#13;   &lt;style&gt;.ctl {   border: 1px outset #777; background:#ddeecc;&#13;   margin: 2px; margin-right: 10px; padding-left: 2px; padding-right: 2px;&#13; &#13;}&#13;   &lt;/style&gt;&#13;   &lt;label value="Slide" sclass="ctl"action="onmouseover: anima.slideDown(#{t}); onmouseout: anima.slideUp(#{t})"/&gt;&#13;   &lt;label value="Fade" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.fade(#{t})"/&gt;&#13;   &lt;label value="Puff" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.puff(#{t})"/&gt;&#13;   &lt;label value="Drop Out" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.dropOut(#{t})"/&gt;&#13;   &lt;div id="t" visible="false"&gt;&#13;      &lt;div&gt;&#13;      &lt;groupbox&gt;&#13;         &lt;caption label="Dynamic Content"/&gt;&#13;         Content to show and hide dynamically.&#13;         &lt;datebox/&gt;&#13;      &lt;/groupbox&gt;&#13;      Description &lt;textbox/&gt;      &#13;      &lt;/div&gt;&#13;   &lt;/div&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect3></sect2></sect1><sect1><title>事件</title>
<para>注意，是否支持一个事件取决于组件。此外，在组件内容更新之后会发送出事件。</para><sect2><title>鼠标事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption column div groupbox image imagemap label listcell listfooter listheader menuitem tabpanel toolbar toolbarbutton treecell treecol window</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>表示用户点击了组件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onRightClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption checkbox column div groupbox image imagemap label listcell listfooter listheader listitem radio slider tab tabbox tabpanel toolbar toolbarbutton treecell treecol treeitem window</code>
</para>
</entry>
<entry>
<para>事件：<code> org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>表示用户右击了组件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onDoubleClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption checkbox col</code>
<code>umn div groupbox image label listcell listfooter listheader listitem tab tabpanel toolbar treecell treecol treeitem window</code>
</para>
</entry>
<entry>
<para>事件：<code> org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>表示用户双击了组件。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>按键事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onOK</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>表示用户按下了ENTER键。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCancel</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>表示用户按下了ESC键。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCtrlKey</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>表示用户按下了一个特殊键，例如 PgUp，Home，以及和<code>Ctrl</code>或<code>Alt</code>组合键。参考下面的<code>ctrlKeys</code>属性(<code>ctrlKeys</code> Property)章节获取细节。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>按键事件会被送至最近的window，此window已经为指定的事件注册了事件监听器。此事件实现了submit，cancel 和shortcut功能。</para>
<para>如下所示，当<code>T1</code>获得聚焦时，若用户按下了<code>ENTER</code>键则会调用<code>doA</code>()方法。 当<code>T2</code>获得聚焦时，若用户按下了<code>ENTER</code>键则会调用<code>doB</code>()方法。</para>
<para>
<para/>
<programlisting>&lt;window id="A" onOK="doA()"&gt;&#13;   &lt;window id="B" onOK="doB()"&gt;&#13;      &lt;textbox id="T1"/&gt;&#13;   &lt;/window&gt;&#13;   &lt;textbox id="T2"/&gt;&#13;&lt;/window&#13;</programlisting>
</para>
<para>注意， window 并不接收发送至内window 的按键事件，除非你手动提交它们。在上面的例子中，若T1获得了聚焦，事件不会被送至window A，不管是否为window B声明了onOK处理器。</para><sect3><title>
<code>ctrlKeys</code>属性</title>
<para>为了接收<code>onCtrlKey</code>事件，你必须指定什么按键被<code>ctrlKeys</code>属性拦截。换言之，仅在<code>ctrlKeys</code>属性内指定的按键会被送回服务器。例如，若用户按下了<code>Alt</code>+<code>C</code>，<code>Ctrl</code>+<code>A</code>，<code>F10</code>，或 <code>Ctrl</code>+<code>F3</code>，则onCtrlKey事件会被发送出。</para>
<para>
<para/>
<programlisting>&lt;window ctrlKeys="@c a#10 #3"&gt;&#13;...&#13;</programlisting>
</para>
<para>下面为<code>ctrlKeys</code>属性的语法。</para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>键</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
<row>
<entry>
<para> <code>k</code>
</para>
</entry>
<entry>
<para>一个控制键， 即<code>Ctrl</code>+<code>k</code>， 这里 <code>k</code> 可以为a~z，0~9，#n 和 ~n。</para>
</entry>
</row>
<row>
<entry>
<para>@<code>k</code>
</para>
</entry>
<entry>
<para>alt 键，即<code>Alt</code>+<code>k</code>, 这里<code>k</code> 可以为 a~z, 0~9, #n 和 ~n。</para>
</entry>
</row>
<row>
<entry>
<para>$<code>k</code>
</para>
</entry>
<entry>
<para>shift键，即<code>Shift</code>+<code>k</code>，这里<code>k</code>可以为#n 和 ~n。</para>
</entry>
</row>
<row>
<entry>
<para>#<code>n</code>
</para>
</entry>
<entry>
<para>一个特殊键，如下。</para>
<informaltable frame="all">
<tgroup cols="6">
<colspec colnum="1" colname="c1"/>
<colspec colnum="2" colname="c2"/>
<colspec colnum="3" colname="c3"/>
<colspec colnum="4" colname="c4"/>
<colspec colnum="5" colname="c5"/>
<colspec colnum="6" colname="c6"/><tbody>
<row>
<entry>
<para>#<code>home</code>
</para>
</entry>
<entry>
<para>
<code>Home</code>
</para>
</entry>
<entry>
<para>#<code>end</code>
</para>
</entry>
<entry>
<para>
<code>End</code>
</para>
</entry>
<entry>
<para>#<code>ins</code>
</para>
</entry>
<entry>
<para>
<code>Ins</code>
<code>ert</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>del</code>
</para>
</entry>
<entry>
<para>
<code>Del</code>
<code>ete</code>
</para>
</entry>
<entry>
<para>#<code>left</code>
</para>
</entry>
<entry>
<para>
<code>←</code>
</para>
</entry>
<entry>
<para>#<code>right</code>
</para>
</entry>
<entry>
<para>
<code>→</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>up</code>
</para>
</entry>
<entry>
<para>
<code>↑</code>
</para>
</entry>
<entry>
<para>#<code>down</code>
</para>
</entry>
<entry>
<para>
<code>↓</code>
</para>
</entry>
<entry>
<para>#<code>pgup</code>
</para>
</entry>
<entry>
<para>
<code>PgUp</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>pgdn</code>
</para>
</entry>
<entry>
<para>
<code>PgDn</code>
</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>#<code>f</code>
<code>n</code>
</para>
</entry>
<entry namest="c2" nameend="c6">
<para>功能键。 #<code>f1</code>, #<code>f2</code>, ... #<code>f12</code> 对应 <code>F1</code>, <code>F2</code>,... <code>F12</code>。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>输入事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onChange</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.InputEvent</code>
</para>
<para>表示输入组件的内容已经被用户修改。</para>
<para/>
</entry>
</row>
<row>
<entry>
<para>
<code>onChanging</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox</code>
<code>doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.InputEvent</code>
</para>
<para>表示用户正在改变输入组件的内容。注意，直到接收了<code>onChange</code>事件，组件的内容(在服务器)才会改变。因此，你必须调用<code>InputEvent</code>类的<code>getValue</code>方法才能获取到临时值。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onSelection</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.SelectionEvent</code>
</para>
<para>表示用户正在选择输入组件的部分文本。你可以使用<code>getStart</code>和<code>getEnd</code>方法获取选中文本的开始及结束位置。</para>
<para/>
</entry>
</row>
<row>
<entry>
<para>
<code>onFocus</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox button toolbarbutton checkbox radio</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.Event</code>
</para>
<para>表示一个组件获得了聚焦。</para>
<para>事件监听器是在服务器端执行的，所以当<code>onFocus</code>的事件监听器执行时，客户端的聚焦或许已经改变。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onBlur</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox button toolbarbutton checkbox radio</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.Event</code>
</para>
<para>表示一个组件失去了聚焦。</para>
<para>事件监听器是在服务器端执行的，所以当<code>onBlur</code>的事件监听器执行时，客户端的聚焦或许已经改变。</para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>List和Tree 事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onSelect</code>
</para>
</entry>
<entry>
<para>
<code>listbox tabbox tabtree</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.SelectEvent</code>
</para>
<para>表示用户选择了一个或多个子组件。对于<code>listbox</code> 为一套 <code>listitem</code> 。对于<code>tree</code> 为一套<code>treeitem</code> 。对于<code>tabbox</code>为一个<code>tab</code>。</para>
<para>注： <code>onSelect</code>被发送至<code>tab</code> 和<code>tabbox</code>。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onOpen</code>
</para>
</entry>
<entry>
<para>
<code>groupbox treeitem combobox bandbox menupopup window</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.OpenEvent</code>
</para>
<para>表示用户打开或关闭了一个组件。注：不同于<code>onClose</code>， 该事件仅是一个通知。在打开或关闭一个组件后，客户端会发出此事件。</para>
<para>这对于当首次打开组件，通过监听<code>onOpen</code>事件，创建组件来实现随机存取(load-on-demand)是很有用的。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>Slider和Scroll事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onScroll</code>
</para>
</entry>
<entry>
<para>
<code>slider</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.ScrollEvent</code>
</para>
<para>表示用户已经滚动了滚动组件的内容。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onScrolling</code>
</para>
</entry>
<entry>
<para>
<code>slider</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.ScrollEvent</code>
</para>
<para>表示用户正在滚动一个滚动组件的内容。注意直到接收了<code>onScroll</code>事件，组件的内容(在服务器端)才会改变。因此，你必须调用<code>ScrollEvent</code>类的<code>getPos</code>方法才能获取临时位置。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>其它事件</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onCreate</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.ui.zk.ui.event.CreateEvent</code>
</para>
<para>表示当送出(rendering)一个ZUML页面时组件被创建。参考组件活动周期(Component Lifecycle)一章。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClose</code>
</para>
</entry>
<entry>
<para>
<code>windowtabfileupload</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.ui.zk.ui.event.Event</code>
</para>
<para>表示用户按下了close按钮，然后组件会移除其自身。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onDrop</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.ui.zk.ui.event.DropEvent</code>
</para>
<para>表示另一个组件被放入了接收此事件的组建。参考拖放)章节。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCheck</code>
</para>
</entry>
<entry>
<para>
<code>checkbox radio radiogroup</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.CheckEvent</code>
</para>
<para>表示用户已经改变了一个组件的状态。</para>
<para>注：<code>onCheck</code>被发送至<code>radio</code>和<code>radiogroup</code>。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onMove</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.MoveEvent</code>
</para>
<para>表示用户已经移动了一个组件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onSize</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.SizeEvent</code>
</para>
<para>表示用户已经改变了一个组件的大小。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onZIndex</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>Event: <code>org.zkoss.zk.ui.event.ZIndexEvent</code>
</para>
<para>表示用户已经改变了一个组件的z-index。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onTimer</code>
</para>
</entry>
<entry>
<para>
<code>timer</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zk.ui.event.Event</code>
</para>
<para>表示你指定的计时器已经触发了一个事件。要想知道是哪个计时器，可以调用Event类的<code>getTarget</code>方法。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onNotify</code>
</para>
</entry>
<entry>
<para>any</para>
</entry>
<entry>
<para>事件：<code> org.zkoss.zk.ui.event.Event</code>
</para>
<para>表示一个独立的应哟用程序事件。它的意义取决于应用程序。目前，还没有组件发送此事件。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClientInfo</code>
</para>
</entry>
<entry>
<para>root</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.ClientInfoEvent</code>
</para>
<para>通知一个根组件关于客户端的信息，例如时区和分辨率(resolutions)。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onPiggyback</code>
</para>
</entry>
<entry>
<para>root</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zku.ui.event.Event</code>
</para>
<para>通知根组件客户端已经向服务器发出了一个请求。通常用于捎带非紧急的UI更新到客户端。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onColSize</code>
</para>
</entry>
<entry>
<para>
<code>columns listhead treecols</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zul.event.ColSizeEvent</code>
</para>
<para>通知一组页眉(a group of headers)的父组件，用户改变了它的两个子组件的宽度。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onPaging</code>
</para>
</entry>
<entry>
<para>
<code>grid listbox paging</code>
</para>
</entry>
<entry>
<para>事件：<code>org.zkoss.zul.event.PagingEvent</code>
</para>
<para>通知用户选中了多页面组件的某一页面。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onUpload</code>
</para>
</entry>
<entry>
<para>
<code>fileupload</code>
</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zul.event.UploadEvent</code>
</para>
<para>通知文件已被上传，应用程序可以使用<code>getMedia</code>或<code>getMedias</code>方法获取已上传的文件。</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>Radio和radiogroup的事件流</title>
<para>为方便开发人员，<code>onCheck</code>事件首先被发送至<code>raido</code>，然后是<code>radiogroup</code>
<footnote>
<para>当一个<code>radio</code>被添加至一个<code>radiogroup</code>时，内部的实现是通过添加一个监听器处理的。 </para>
</footnote>。因此，你可以为radiogroup或每个radio 按钮添加监听器。</para>
<programlisting>&lt;radiogroup onCheck="fruit.value = self.selectedItem.label"&gt;&#13;   &lt;radio label="Apple"/&gt;&#13;   &lt;radio label="Orange"/&gt;&#13;&lt;/radiogroup&gt;&#13;You have selected : &lt;label id="fruit"/&gt;&#13;</programlisting>
<para>上面的事例和下面的有相同的效果。</para><programlisting>&#13;&lt;radiogroup&gt;&#13;   &lt;radio label="Apple" onCheck="fruit.value = self.label"/&gt;&#13;   &lt;radio label="Orange" onCheck="fruit.value = self.label"/&gt;&#13;&lt;/radiogroup&gt;&#13;You have selected : &lt;label id="fruit"/&gt;&#13;</programlisting></sect3></sect2></sect1></chapter>
<chapter>
<title>8. 在ZUML中使用XHTML组件集</title>
<para>本章描述了XHTML组件集。</para><sect1><title>目标</title>
<para>介绍XHTML组件集的目地是，使已存在的Web页面可以简单的移植(port)到ZUML。最终目标是，所有有效的XHTML页面即为有效的ZUML页面。所有的servlet就像平常一样处理提交的表单。</para>
<para>因此，已存在的XHTML页面可以享受ZUML页面拥有的最强大优点，丰富用户界面。这种丰富性可以用两种方式实现。第一种，你可以嵌入Java代码来动态操纵XHTML组件。第二种，你可以为已存在的页面添加off-of-shelf XUL 组件，就像为XUL页面添加XHTML。</para><sect2><title>有效的XHTML页面即为有效的ZUM页面</title>
<para>下面为一个简单但典型的Web页面。</para>
<programlisting>&lt;html&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;ul id="ul"&gt;&#13;      &lt;li&gt;The first item.&lt;/li&gt;&#13;      &lt;li&gt;The second item.&lt;/li&gt;&#13;   &lt;/ul&gt;&#13;   &lt;input type="button" value="Add Item""/&gt;&#13;   &lt;br/&gt;&#13;   &lt;input id="inp0" type="text"/&gt; +&#13;   &lt;input id="inp1" type="text"/&gt; =&#13;   &lt;text id="out"/&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>将其以<code>zhtml</code>为扩展名<footnote>
<para>若你想将所有的XHTML页面变为ZUML页面,可以将.<code>html</code>扩展名映射到DHtmlLayoutServlet。参考the Developer's Reference的附录A(Appendix A)获取细节。 </para>
</footnote>，则ZK加载器会将此页面作为ZUML页面解释。然后，<code>org.zkoss.zhtml.Html</code>，<code>org.zkoss.zhtml.Head</code>及其它的实例被创建。换言之，我们在服务器端创建了一个XHTML 组件树。然后ZK将它们成为(renders)规则的XHTML页面并送回浏览器，就像我们为任何ZUML页面做的那样。</para></sect2><sect2><title>以服务器为中心的交互</title>
<para>作为一个ZUML页面，它可以嵌入任何Java代码，且在服务器执行它们，如下。</para>
<programlisting>&lt;html xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;ul id="ul"&gt;&#13;      &lt;li&gt;The first item.&lt;/li&gt;&#13;      &lt;li&gt;The second item.&lt;/li&gt;&#13;   &lt;/ul&gt;&#13;   &lt;input type="button" value="Add Item" zk:onClick="addItem()"/&gt;&#13;   &lt;br/&gt;&#13;   &lt;input id="inp0" type="text" zk:onChange="add()"/&gt; +&#13;   &lt;input id="inp1" type="text" zk:onChange="add()"/&gt; =&#13;   &lt;text id="out"/&gt;&#13;   &lt;zscript&gt;&#13;   void addItem() {&#13;      Component li = new Raw("li");&#13;      li.setParent(ul);&#13;      new Text("Item "+ul.getChildren().size()).setParent(li);&#13;   }&#13;   void add() {&#13;      out.setValue(inp0.getValue() + inp1.getValue());&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>在上面的例子中，我们使用了ZK命名空间指定<code>onClick</code>属性。这是必须的，因为XHTML本身有一个相同名称的属性。</para>
<para>注意Java代码是运行在服务器的。因此，不同于嵌入HTML页面的JavaScript， 你可以直接在服务器访问任何资源。例如，你可以打开一个数据库的连接，并获取数据来填充特定的组件。</para>
<programlisting>&lt;zscript&gt;&#13;import java.sql.*;&#13;void addItem() {&#13;   Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");&#13;   String url = "jdbc:odbc:Fred";&#13;   Connection conn = DriverManager.getConnection(url,"myLogin", "myPassword");&#13;   ...&#13;   conn.close();&#13;}&#13;&lt;/zscript&gt;&#13;</programlisting></sect2><sect2><title>像平常一样使用Servlet</title>
<para>在传统的Web应用程序中，XHTML页面通常会提交一个表单到指定的servlet 进行处理。你不需要修改servlet来将页面融入ZK。</para></sect2></sect1><sect1><title>差异</title>
<para>除了作为ZK组件，XHTML组件集的实现与其它的组件集<footnote>
<para>这些差异是由于实现了特定的接口，所以你可以为你的组件应用 (apply)相同的效果，若果你喜欢的话。 </para>
</footnote>有某些不同，这样会更容易将传统的XHTML页面融入ZK。</para><sect2><title>UUID即为ID</title>
<para>传统的servlets和JavaScript 代码通常依赖于id属性，所以XHTML组件的UUID与ID是相同的。因此，开发人员不需要更改已存在的代码来适应ZK，如下所示。</para>
<programlisting>&lt;img id="which"/&gt;&#13;&lt;script type="text/javascript"&gt;&lt;![CDATA[&#13;//JavaScript and running at the browser&#13;   function change() {&#13;      var el = document.getElementById("which");&#13;      el.src = "something.gif";&#13;   }&#13;]]&gt;&lt;/script&gt;&#13;&lt;zscript&gt;&lt;!-- Java and running at the server --&gt;&#13;   void change() {&#13;      which.src = "another.gif";&#13;   }&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>注意，UUID是不可变的，并且与组件的ID没有任何关系，而不是XHTML。因此，在上面的例子中，若使用了XUL组件则会失败。若你真想在JavaScript 中使用XUL组件，则必须使用EL表达式获取正确的UUID。</para>
<programlisting>&lt;input id="which"/&gt;&#13;&lt;script type="text/javascript"&gt;//Running at the browser&#13;   var el = document.getElementById("${which.uuid}");&#13;   el = $e("${which.uuid}"); //$e() is an utility of ZK Client Engine&#13;&lt;/script&gt;&#13;</programlisting><sect3><title>副作用</title>
<para>由于UUID即为ID，所以同一桌面内的两个组件不能有相同的ID。</para></sect3></sect2><sect2><title>所有标签都有效</title>
<para>不同于XUL或其它组件集，在XHTML组件集中没有无效的XML元素。ZK使用<code>org.zkoss.zhtml.Raw</code>类用于构造任何未经认证的xml元素<footnote>
<para>[注]：这由 <code>org.zkoss</code>
<code>.zk.ui.ext.DynamicTag</code>接口处理。</para>
</footnote>。因此，开发人员可以使用目标浏览器支持的任意标签，不管ZK组件是否实现了它们。</para>
<para>类似的，你可以使用<code>Raw</code>组件来创建任何在XHTML组件集中没有定义的组件，如下。</para>
<programlisting>new Raw("object"); //object could be any tag name the target browser supports&#13;</programlisting></sect2><sect2><title>大小写</title>
<para>不同于XUL或其它组件集，XHTML的组件名是区分大小写的。下面的XML元素都被映射到 <code>org.zkoss.zhtml.Br</code>组件。</para>
<programlisting>&lt;br/&gt;&#13;&lt;BR/&gt;&#13;&lt;bR/&gt;&#13;</programlisting></sect2><sect2><title>无模型支持</title>
<para>XHTML组件直接输出其内容。它们不支持模型。换言之，<code>mold</code>属性会被忽略。</para></sect2></sect1><sect1><title>浏览器端的DOM树</title>
<para>在将XHTML移植到ZK后，你不需要使用JavaScript 操纵浏览器端的DOM树，尽管ZK并不阻止你那么做。相反，你在服务器操纵XHTML 组件，然后ZK引擎会为你更新浏览器的DOM树。</para>
<para>这很方便但是有一个catch。ZK假定浏览器端的DOM树与服务器端的组件树是一样的。在大多数情况下，这是事实。但并非总是如此。</para><sect2><title>TABLE和TBODY标签</title>
<para>浏览器总是在TABLE和TR间创建TBODY。因此，下面的两个表格拥有相同的结构。</para>
<programlisting>&lt;table&gt;&#13;   &lt;tr&gt;&lt;td&gt;Hi&lt;/td&gt;&lt;/tr&gt;&#13;&lt;/table&gt;&#13;&lt;table&gt;&#13;   &lt;tbody&gt;&#13;      &lt;tr&gt;&lt;td&gt;Hi&lt;/td&gt;&lt;/tr&gt;&#13;   &lt;/tbody&gt;&#13;&lt;/table&gt;&#13;</programlisting>
<para>不幸的是，在ZK中它们的组件树是不同的。因此，若你想动态的操纵一个表格，就必须在TABLE和TR间声明TBODY 。当然，你不需要为静态表格担心这个。</para></sect2></sect1><sect1><title>事件</title>
<para>所有的XHTML组件都支持下列组件，但是是否适用还得依赖于浏览器。例如，<code>onChange</code>对于非输入组件是没有意义的，例如<code>body</code>和<code>div</code>。你必须考虑HTML标准<footnote>
<para>http/www.w3c.org</para>
</footnote>。</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>事件名称</para>
</entry>
<entry>
<para>组件</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onChange</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event</code>.<code>InputEvent</code>
</para>
<para>表示用户修改了输入组件的内容。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClick</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>事件： <code>org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>表示用户点击了组件。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect1><sect1><title>与JSF, JSP及其它的集成</title>
<para>当与已存在的Web页面集成时，你或许会问自己几个问题。</para>
<itemizedlist>
<listitem>
<para>已存在的页面是静态的还是动态生成的？</para>
</listitem>
<listitem>
<para>若丰富已存在的页面，是轻微的增强？或是，重写页面的一部分？</para>
</listitem>
<listitem>
<para>当添加一个新页面时，使用XUL或XHTML作为默认的组件集？</para>
</listitem>
</itemizedlist>
<para>依你的请求，有几种途径可以选择。</para><sect2><title>使用已存在的Servlet</title>
<para>使用form组件，你可以将一个请求提交到已存在的servlet 。参考使用XUL组件集的ZUML(ZUML with the XUL Component Set)一章中关于使用HTML表单和Java Servlet的部分获取细节。</para>
<para>因为form组件可以包含任何组件，所以你可以设计丰富的用户界面而无需修改已存在的servlet 。</para></sect2><sect2><title>使用包含来丰富页面</title>
<para>若你想重写已存在页面的一部分，把重写的部分放入一个单独的ZUML文件或许会更好。然后，你可以在已存在的页面内包含此ZUML文件。例如，若使用了JSP技术则可以使用jsp:include。</para>
<programlisting>&lt;jsp:include page="/my/ria.zul"/&gt;&#13;</programlisting></sect2><sect2><title>丰富一个静态的HTML页面</title>
<para>若你想通过添加丰富的内容来直接修改一个静态的HTML页面，可以将文件重命名为<code>zhtml</code>扩展名。然后，ZK加载器负责加载页面，然后你可以使用ZK丰富。</para></sect2><sect2><title>使用ZK JSP标签</title>
<para>ZK为每个ZUL组件都提供了等价的JSP标签。若你喜欢在JSP页面使用ZUL组件，只需简单的指定TLD文件，如下所示。</para>
<programlisting>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"&#13; "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&#13;&#13;&lt;%@ taglib uri="/WEB-INF/tld/zul/jsp/zul2jsp.tld" prefix="z" %&gt;&#13;&#13;&lt;html&gt;&#13;   &lt;head&gt;&#13;      &lt;title&gt;Test of ZUL on JSP&lt;/title&gt;&#13;   &lt;/head&gt;&#13;   &lt;body&gt;&#13;   &lt;h1&gt;1. Header outside z:page&lt;/h1&gt;&#13;&lt;z:page&gt;&#13;   &lt;h2&gt;2. Header in z:page&lt;/h2&gt;&#13;   &lt;z:window title="Test" border="normal"&gt;&#13;      &lt;p&gt;3. Content in z:window&lt;/p&gt;&#13;   &lt;/z:window&gt;&#13;      &lt;p&gt;4. Content in z:page after z:window&lt;/h2&gt;&#13;&#13;&lt;/z:page&gt;&#13;   &lt;p&gt;5. Content after z:page&lt;/p&gt;&#13;   &lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>首先，最好按如上方式指定DOCTYPE，因为ZK客户端引擎假定为此文件。然后，可以在标准发行版的<code>dist/WEB-INF/tld/zul/jsp</code>目录找到TLD文件。最后，你必须使用页面标签包围所有的组件标签。</para>
<para>每个ZUL组件都被一个JSP标签包装，且每个属性都被一个标签属性包装。此外，混合使用JSP标签与其它标签是你的自由。因此，使用ZK JSP标签更直接。</para></sect2><sect2><title>使用ZK Filter丰富动态生成的页面</title>
<para>若你想ajax-ize一个动态生成的HTML页面(例如，输出一个JSP页面)，可以使用ZK Filter处理生成的页面。你必须使用<code>web.xml</code>启用ZK filter，如下所示。</para>
<programlisting>&lt;filter&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;filter-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutFilter&lt;/filter-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;extension&lt;/param-name&gt;&#13;      &lt;param-value&gt;html&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;&lt;/filter&gt;&#13;&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&#13;&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna/*&lt;/url-pattern&gt;&#13;&lt;/filter-mapping&gt;&#13;</programlisting>
<para>此处，<code>url-pattern</code>是独立于应用程序的。<code>extension</code>参数(<code>init-param</code>)定义了动态输出的语言。默认为<code>html</code>。若为<code>xul/html</code>，则指定<code>zul</code>作为扩展名。</para>
<para>[提示] : 在大多数情况下，ZK JSP标签更易于使用且比ZK filter消耗更少的内存。参考高级特性一章中关于性能提示的部分。</para>
<para>注意，若你想过滤来自include和/或forward的输出，要使用REQUEST和/或INCLUDE指定适配器元素。查阅Java Servlet 规范获取细节。 例如，</para>
<programlisting>&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna/*&lt;/url-pattern&gt;&#13;   &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;&#13;&lt;/filter-mapping&gt;&#13;</programlisting></sect2><sect2><title>XUL 或 XHTML</title>
<para>这里没有直接的答案。取决于你的选择。</para>
<para>但是，经验原则或许是你想得那样，编写HTML， HEAD 和 BODY标签控制整个页面的外观。若是，则使用XHTML 作为默认空间(将文件命名为<code>zhtml</code>扩展名)。若不是，则使用XUL作为默认空间(将文件命名为<code>zul</code>扩展名)。</para>
<para>通过使用XML命名空间，你可以在同一页面内混合使用不同的组件集。此外，空前缀的命名空间是独立于你选择的扩展名的。例如，下面的语句是有效的，不管你使用什么扩展名。</para>
<programlisting>&lt;window xmlns="http://www.zkoss.org/2005/zul" xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;   &lt;h:table&gt;&#13;...&#13;</programlisting>
<para>等价于，</para>
<programlisting>&lt;x:window xmlns:x="http://www.zkoss.org/2005/zul" xmlns="http://www.w3.org/1999/xhtml"&gt;&#13;   &lt;table&gt;&#13;
...
</programlisting>
<para/></sect2></sect1></chapter>
<chapter>
<title>9. 宏组件</title>
<para>有两种方式实现一个组件。一种方法是实现一个来自<code>org.zkoss.zk.ui.AbstractComponent</code>的类。另一种方法是使用其它组件实现它。</para>
<para>第一种方式更为灵活。这需要深入ZK，所以通常由组件开发人员来完成。这在Component Development Guide 中有讨论。</para>
<para>另外，使用其它组件来实现一个新组件更为直接。就像composition，macro expansion，或 inline replacement 一样工作。为了描述方便，我们将这类组件成为宏组件，而其它的组件称为本地组件。</para>
<para>[提示]：从应用程序开发人员的角度来看，宏组件与本地组件是没有区别的，除了宏组件是被实现的。</para><sect1><title>使用宏组件的三个步骤</title>
<para>使用宏组件需要以下三步。</para>
<orderedlist>
<listitem>
<para>通过ZUML页面实现一个宏组件。</para>
</listitem>
<listitem>
<para>在将要使用它的页面内声明宏组件。</para>
</listitem>
<listitem>
<para>使用宏组件，就像使用其它组件一样。</para>
</listitem>
</orderedlist>
<para>[提示]: 除了在页面内定义宏组件，你可以将其定义放入一个语言插件,这样所有的页面都可以访问此宏组件。</para><sect2><title>第一步. 实现</title>
<para>所有你要做的就是准备一个ZUML页面来描述宏组件的组成。也就是，宏模板。</para>
<para>例如，假定你想将一个label 和一个textbox包装成成一个宏组件。我们可以创建页面，例如/WEB-<code>INF/macros/username.zul</code>，如下。</para>
<programlisting>&lt;hbox&gt;&#13;   Username: &lt;textbox/&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>完成！</para>
<para>实现宏组件的页面和其它页面是一样的，所以任何页面都可以做为宏组件被使用。</para></sect2><sect2><title>第二步. 声明</title>
<para>在实例化一个宏组件之前，你必须首先声明。一个简单的方式就是使用指令声明它。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;</programlisting>
<para>如上所示，你必须声明name(name属性)和页面的URI(macro-uri 属性)。</para><sect3><title>其它属性</title>
<para>除了<code>name</code>，<code>macro-</code>uri 和<code>class</code>
<footnote>
<para>后面会讨论class 属性。</para>
</footnote>属性，你可以指定一个初始属性的列表，用于实例化时初始一个组件。</para>
<programlisting>&lt;?component name="mycomp" macro-uri="/macros/mycomp.zul"&#13;myprop="myval" another="anotherval"?&gt;&#13;</programlisting>
<para>因此，</para>
<programlisting>&lt;mycomp/&gt;&#13;</programlisting>
<para>等价于</para>
<programlisting>&lt;mycomp myprop="myval1" another="anotherval"/&gt;</programlisting></sect3></sect2><sect2><title>第三步. 使用</title>
<para>使用宏组件与使用其它组件一样。</para>
<programlisting>&lt;window&gt;&#13;   &lt;username/&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect3><title>传递属性</title>
<para>就像一个普通的组件，当使用宏组件时你可以指定属性(properties，亦=attributes) ，如下。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;window&gt;&#13;   &lt;username who="John"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>所有这些被指定的属性被存储在一个map中，然后通过arg变量被传递到模板。然后在模板中，你可以按如下方式访问这些属性。</para>
<programlisting>&lt;hbox&gt;&#13;   Username: &lt;textbox value="${arg.who}"/&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>[注]：仅当送出宏页面时arg是可用的。为了访问事件监听器，你必须使用<code>getDynamicProperty</code>代替。细节请参考增设方法章节。</para></sect3><sect3><title>arg.includer</title>
<para>除了指定的属性(properties，亦=attributes)，<code>arg.includer</code>属性也被传出用以呈现定义在宏模板中组件的父组件。</para>
<para>若一个常规的宏被创建，<code>arg.includer</code>即为宏组件本身。若创建了一个内联(inline)宏，<code>arg.includer</code>为父组件，若果有的话。更多信息请参考内联宏章节。</para>
<para>在上面的例子中，<code>arg.includer</code>表示常规的宏组件，<code>&lt;username who="John"/&gt;</code>，且为的父组件(定义在<code>username.zul</code>中)。</para></sect3></sect2></sect1><sect1><title>内联宏</title>
<para>有两种类型的宏组件：内联<footnote>
<para>自ZK 2.3 版本后添加了内联宏组件。</para>
</footnote>和常规。默认为常规宏。为了指定内联宏，你必须在component 指令内指定<code>inline="true"</code>。</para>
<para>内联宏的行为就像内联扩展(inline-expansion)。若遇见了内联宏，则ZK不会创建宏组件。相反，它会内联扩展定义在宏URI内的组件。换言之，就好象直接将内联组件的内容的嵌入到目标页面。</para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>use.zul： (目标页面)</para>
<programlisting>&lt;?component name="username" inline="true" macro-uri="username.zul"?&gt;
 &lt;grid&gt;
   &lt;rows&gt;
	 &lt;username id="ua" name="John"/&gt;
	&lt;/rows&gt;
 &lt;/grid&gt;</programlisting>
<para>username.zul：(宏定义)</para>
<programlisting>&lt;row&gt;
	Username
	&lt;textbox id="${arg.id}" value="${arg.name}"/&gt;
&lt;/row&gt;</programlisting>
</entry>
<entry>
<para>等价页面：</para>
<programlisting>&lt;grid&gt;
   &lt;rows&gt;
 &lt;row&gt;
   Username
   &lt;textbox id="ua" value="John"/&gt;
 &lt;/row&gt;
   &lt;/rows&gt;
&lt;/grid&gt;</programlisting>
<para>所有的属性，包括id，都会被传递到内联宏。</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>另外，ZK将会创建一个真实的组件(称为宏组件)来显示常规的宏。也就是说，宏组件将会作为定义在宏内组件的父组件被创建。</para>
<para>内联宏更易整合到复杂的页面。例如，由于rows仅接受row，所以在前一个例子中，你不能使用常规的组件，而不是宏组件。由于在同一ID空间内，所以更易访问定义在宏内的所有组件。这也意味着开发人员必须清楚如何实现以避免名字冲突。</para>
<para>常规宏允许开发人员提供额外的API，并且对组件用户隐藏实现。每个常规宏组件均是一个ID空间所有者，所以不会有名字冲突。通常假定常规宏的用户不知道如何实现。相反，他们使用定义好的API访问宏组件。</para><sect2><title>一个例子</title>
<para>
<code>inline.zul</code>： (宏定义)</para>
<programlisting>&lt;row&gt;&#13;   &lt;textbox value="${arg.col1}"/&gt;&#13;   &lt;textbox value="${arg.col2}"/&gt;&#13;&lt;/row&gt;&#13;</programlisting>
<para>
<code>useinline.zul</code>: (目标页面)</para>
<programlisting>&lt;?component name="myrow" macro-uri="inline.zul" inline="true"?&gt;&#13;&lt;window title="Test of inline macros" border="normal"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   import org.zkoss.util.Pair;&#13;   List infos = new LinkedList();&#13;   for (int j = 0; j &lt; 10; ++j) {&#13;      infos.add(new Pair("A" + j, "B" + j));&#13;   }&#13;   ]]&gt;&lt;/zscript&gt;&#13;   &lt;grid&gt;&#13;      &lt;rows&gt;&#13;         &lt;myrow col1="${each.x}" col2="${each.y}" forEach="${infos}"/&gt;&#13;      &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2></sect1><sect1><title>常规宏</title>
<para>ZK创建一个真实的组件(称为宏组件)来显示常规宏，即前一章节描述的。</para>
<para>为了描述方便，当在此章节中讨论的宏组件时，即意味着为常规宏组件。</para><sect2><title>宏组件和ID空间</title>
<para>就像window，宏组件为一个ID空间所有者。换言之，在实现宏组件(亦=宏组件的子组件)的页面内使用什么标识来标识组件是自由的。它们不会和定义在使用宏组件的同一页面内的组件相冲突的。</para>
<para>例如，假定我们有如下一个宏定义。</para>
<programlisting>&lt;hbox&gt;&#13;   Username: &lt;textbox id="who" value="${arg.who}"/&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>那么下面的代码将会正常工作。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;zk&gt;&#13;   &lt;username/&gt;&#13;   &lt;button id="who"/&gt; &lt;!-- no conflict because it is in a different ID space --&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>但是，下列的代码将不会工作。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;username id="who"/&gt;&#13;</programlisting>
<para>为什么呢？就像任何ID空间所有者，宏组件本身和其子组件在相同的ID空间内。有两种可选的解决方案：</para>
<orderedlist>
<listitem>
<para>为宏组件的子组件标识使用一个特殊的前缀。例如使用<code>"mc_who"</code>代替 <code>"who"</code>。</para>
</listitem>
</orderedlist>
<programlisting>&lt;hbox&gt;&#13;   Username: &lt;textbox id="mc_who" value="${arg.who}"/&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<orderedlist>
<listitem>
<para>使用window 组件创建 一个额外的ID空间。</para>
</listitem>
</orderedlist>
<programlisting>&lt;window&gt;&#13;   &lt;hbox&gt;&#13;          Username: &lt;textbox id="who" value="${arg.who}"/&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>将以使用第一种方案，简单方便。</para><sect3><title>从外部访问子组件</title>
<para>就像其它的ID空间所有者，你可以调用<code>getFellow</code>方法或使用 <code>org.zkoss.zk.ui.Path</code>来访问其子组件。</para>
<para>例如，假定你有一个ID为<code>"username"</code>的宏组件，那么可以按如下方式访问textbox。</para>
<programlisting>comp.getFellow("username").getFellow("mc_who");&#13;new Path("/username/mc_who");&#13;</programlisting></sect3><sect3><title>访问定义在Ancestor的变量</title>
<para>宏组件像内联扩展一样工作。因此，就像其它组件，(一个宏组件的)子组件可以访问任何定义在父组件ID空间内的变量。</para>
<para>例如，<code>username</code>的子组件可以直接访问<code>v</code>。</para>
<programlisting>&lt;zscript&gt;&#13;   String v = "something";&#13;&lt;/zscript&gt;&#13;&lt;username/&gt;&#13;</programlisting>
<para>但是，并不推荐这样使用，因为这或许会限制宏的使用范围。</para></sect3><sect3><title>运行时改变<code>macro-uri</code>
</title>
<para>你可以动态的改变宏的URI，如下。</para>
<programlisting>&lt;username id="ua"/&gt;&#13;&lt;button onClick="ua.setMacroURI(&amp;quot;another.zul&amp;quot;)"/&gt;&#13;</programlisting></sect3></sect2><sect2><title>增设方法</title>
<para>宏组件实现了<code>org.zkoss.zk.ui.ext.DynamicPropertie</code>接口，所以你可以按如下方式使用 <code>getDynamicProperty</code>方法访问其属性。</para>
<programlisting>&lt;username id="ua" who="John"/&gt;&#13;&lt;button label="what?" onClick="alert(ua.getDynamicProperty(&amp;quot;who&amp;quot;))"/&gt;&#13;</programlisting>
<para>显然使用<code>Dyn</code>
<code>amicPropertied</code>是很繁琐的。更糟的是，若你使用<code>setDynamicProperty</code>改变一个属性，却不会被改变宏的子组件。例如，下面的代码会显示<code>John</code>作为username，而不是<code>Mary</code>。</para>
<programlisting>&lt;username id="ua" who="John"/&gt;&#13;&lt;zscript&gt;&#13;  ua.setDynamicProperty("who", "Mary");&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>为什么呢？一个宏组件的所有子组件都是在创建宏组件时被创建的，除非你手动操作这些子组件<footnote>
<para>另外，在提交(rendering)阶段，<code>include</code>组件包含的子组件被创建。而且，每一次使<code>include</code>组件无效时，所有的子组件都会被移除并且创建。</para>
</footnote>，否则是不会改变它们的。调用<code>setDynamicProperty</code>仅会影响存储在宏组件中的属性(可以使用<code>getDynamicProperties</code>
<code>获</code>取的)。<code>textbox</code>的内容仍没有改变。</para>
<para>因此，最好增设一个方法，例如<code>setWho</code>，用以直接操作宏组建组件。为了增设你自己的方法，必须为宏组件实现一个class，然后使用component 指令的<code>class</code>属性指定此类。</para>
<para>[提示]: 可以使用<code>recreate</code>方法来再创建子组件(包括其当前的属性)。实际上此方法是移除了所有的子组件，然后再重新创建它们。有两种方式实现一个类。下面的章节描述了细节。</para><sect3><title>在Java中增设方法</title>
<para>为宏组件增设方法需要两个步骤。</para>
<orderedlist>
<listitem>
<para>继承<code>org.zkoss.zk.ui.HtmlMacroComponent</code>实现一个类。</para>
</listitem>
<programlisting>
//Username.java
package mypack;
public class Username extends HtmlMacroComponent {
  public void setWho(String name) {
      setDynamicProperty("who", name); //arg.who requires it
      final Textbox tb = (Textbox)getFellow("mc_who");
      if (tb != null) tb.setValue(name); //correct the child if available
   }
   public String getWho() {
      return (String)getDynamicaProperty("who");>
   }
}</programlisting>

<itemizedlist>
<listitem>
<para>正如上面所描述的，你必须在<code>setWho</code>内调用<code>setDynamicProperty</code>，因为在宏页面(<code>${arg.who}</code>)内引用了 <code>${arg.who}</code>，<code>${arg.who}</code>被用于宏组件创建其子组件时。 </para>
</listitem>
<listitem>
<para>由于<code>setWho</code>方法或许会在宏组件创建其子组件之前被创建，因此你必须检查<code>mc_who</code>是否存在。 </para>
</listitem>
<listitem>
<para>由于调用了<code>mc_who</code>的<code>setValue</code>，当调用<code>setWho</code>时，客户端的内容及视觉表现都会被自动更新。</para>
</listitem>
</itemizedlist>
<listitem>
<para>使用<code>class</code>属性在宏声明内声明类。 </para>
</listitem>
</orderedlist>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;
class="mypack.Username"?&gt;</programlisting></sect3><sect3><title>在<code>zscript</code>中增设方法</title>
<para>除了使用Java文件实现，你也可以在<code>zscript</code>中实现Java class(es)。优点是不需要编译，并且可以动态的修改其内容(无需重新部署Web应用程序)。缺点是降低了性能且容易出现打字错误。</para>
<para>需要几个步骤在<code>zscript</code>中实现Java class 。</para>
<orderedlist>
<listitem>
<para>你需要为要实现的类准备一个<code>zscript</code> 文件，例如<code>/zs/username.zs</code>。注意你可以在相用的<code>zscript</code> 文件内放置任意数量的类及函数。 </para>
</listitem>
</orderedlist>
<programlisting>//username.zs
package mypack;
public class Username extends HtmlMacroComponent {
  public void setWho(String name) {
     setDynamicProperty("who", name);
      Textbox tb = getFellow("mc_who");
      if (tb != null) tb.setValue(name);
   }
   public String getWho() {
      return getDynamicProperty("who");
   }
}</programlisting>
<orderedlist>
<listitem>
<para>使用<code>init</code>指令加载<code>zscript</code>文件，然后声明组件。</para>
</listitem>
</orderedlist>
<programlisting>
&lt;?init zscript="/zs/username.zs"?&gt;
&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"
   class="mypack.Username"?&gt;</programlisting>
<para>实现类(前一个例子中的<code>mypack.Username</code>)直到宏组件被使用时才会被决定，所以使用<code>zscript</code>元素为<code>zscript</code>文件赋值是没有问题的。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;   class="mypack.Username"?&gt;&#13;&lt;zk&gt;&#13;
   &lt;zscript src="/zs/username.zs"/&gt;
  &lt;username/&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>尽管主观，<code>init</code>指令仍更具有可读性。</para></sect3><sect3><title>当实例化时重写实现类</title>
<para>就像其它的任何组件，你可以为任何特定的实例使用<code>use</code>属性重写用于实现宏组件的类。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;   class="mypack.Username?&gt;&#13;&#13;&lt;username use="another.MyAnotherUsername/&gt;&#13;</programlisting>
<para>当然在上面的例子中，你必须要提供一个<code>another.MyAnohterUsername</code>的实现。然后再一次，可以使用单独的Java文件或<code>zscript</code>来实现此类。</para></sect3><sect3><title>手动创建一个宏组件</title>
<para>为了手动创建一个宏组件，你必须在所有的初始化完成后调用<code>afterCompose</code>方法，如下。</para>
<programlisting>HtmlMacroComponent ua = (HtmlMacroComponent)&#13;   page.getComponentDefinition("username", false).newInstance(page);&#13;ua.setParent(wnd);&#13;ua.applyProperties(); //apply properties defined in the component definition&#13;ua.setDynamicProperty("who", "Joe");&#13;ua.afterCompose(); //then the ZUML page is loaded and child components are created&#13;</programlisting>
<para>[注]: <code>getComponentDefinition</code>方法被用于在一个页面内查到组件定义。 </para>
<para>若你为宏实现了一个类，例如Username，那么可按如下方式处理。</para>
<programlisting>Username ua = new Username();&#13;ua.setWho("Joe");&#13;ua.setParent(wnd);&#13;ua.afterCompose();&#13;</programlisting></sect3></sect2></sect1></chapter>
<chapter>
<title>10. 高级特性</title>
<para>这一章将会描述关于组件和页面的高级主题。</para><sect1><title>标识页面</title>
<para>所有同一desktop内的页面都可以在一个事件监听器内被访问到。你可以使用<code>org.zkoss.zk.ui.Component</code>接口内的<code>getPage</code>方法获取组件的当page。</para>
<para>为了获取另一page 的引用，你必须为page指定一个标识，用以查找。</para>
<programlisting>&lt;?page id="another"?&gt;&#13;...&#13;</programlisting>
<para>然后可以使用<code>org.zkoss.zk.ui.Desktop </code>接口内的<code>getPage </code>方法，如下。</para>
<programlisting>&lt;zscript&gt;&#13;   Page another = self.getDesktop().getPage("another");&#13;&lt;/zscript&gt;</programlisting></sect1><sect1><title>表示组件</title>
<para>组件通过ID空间被分组。page本身即为一个ID空间。window组件是另外一个ID空间。假定你有一个名为的P的page，此page有一个名为A的窗口，A窗口有一个子窗口B。那么，若你想获取窗口B的一个子组件，例如C，可以按如下方式处理。</para>
<programlisting>comp.getDesktop().getPage("P").getFellow("A").getFellow("B").getFellow("C");&#13;</programlisting>
<para>
<code>getFellow</code>方法用于获取如同一空间内的任何伙伴。ID空间的概念请参考基础一章中关于ID空间的部分。</para><sect2><title>组件路径</title>
<para>就像文件系统中的路径，组件路径为沿着ID空间排列的组件ID。在上面的例子中，路径为"/A/B/C"。换言之，组件路径的根为当前page。若你想标识另一个page，必须使用"//"。在上面的例子中，路径也可以被表示为 "//P/A/B/C"。</para>
<para>
<code>org.zkoss.zk.ui.Path</code>类，就像<code>java.io.File</code>，被用来简化操纵组件路径。因此，下列的语句的等价于上面的例子。</para>
<programlisting>Path.getComponent("/A/B/C"); //assume the current page is P&#13;Path.getComponent("//P/A/B/C");&#13;</programlisting>
<para>除了静态方法，你可以初始化一个Path实例。</para>
<programlisting>Path parent = new Path("//P/A");&#13;new Path(parent, "B/C").getComponent();&#13;</programlisting></sect2></sect1><sect1><title>排序</title>
<para>
<code>org.zkoss.zk.ui.Component</code>接口中的<code>getChildren</code>方法返回的列表是实况的(live)。<code>org.zkoss.zul.Listbox</code>中的<code>getItems</code>方法<code>及其它</code>接口中的对应方法也是如此。换言之，你可以动态操纵其内容。例如，下面的语句是等价的：</para>
<programlisting>comp.getChildren().remove(0);&#13;
((Component)comp.getChildren().get(0)).setParent(null);</programlisting>
<para>但是，你不能够使用<code>java.util.Collections</code>类的<code>sort</code>方法为它们排序。原因是很微妙的：当你将列表添加到另一位置时，children列表会自动从原始的位置移除一个child。例如，下面的代码实际上移动了第一个child前的第二个child。</para>
<programlisting>comp.getChildren().add(0, comp.getChildren().get(1));&#13;</programlisting>
<para>这和平常的列表(例如LinkedList )有些不用，所以<code>Collections</code>的<code>sort</code>方法是不会工作的。</para>
<para>为了简化组件的排序，我们提供了<code>org.zkoss.zk.ui.Components</code>类的<code>sort</code>方法来处理children列表。</para>
<para>在下面的例子中，我们使用<code>sort</code>方法和<code>org.zkoss.zul.ListitemComparator</code>来为一个listbox排序。</para>
<para>注意，这仅是用来说明listbox直接支持listitem的排序。详情请参考一种ZUML页面的XUL组件集一章中关于列表框的部分。</para>
<programlisting>&lt;window title="Sort Listbox" border="normal" width="200px"&gt;&#13;   &lt;vbox&gt;&#13;      &lt;listbox id="l"&gt;&#13;         &lt;listhead&gt;&#13;<inlinegraphic fileref="img/10-3.png" align="right"/>            &lt;listheader label="name"/&gt;&#13;            &lt;listheader label="gender"/&gt;&#13;         &lt;/listhead&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Mary"/&gt;&#13;            &lt;listcell label="FEMALE"/&gt;&#13;            &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="John"/&gt;&#13;            &lt;listcell label="MALE"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Jane"/&gt;&#13;            &lt;listcell label="FEMALE"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Henry"/&gt;&#13;            &lt;listcell label="MALE"/&gt;&#13;         &lt;/listitem&gt;&#13;      &lt;/listbox&gt;&#13;      &lt;hbox&gt;&#13;         &lt;button label="Sort 1" onClick="sort(l, 0)"/&gt;&#13;         &lt;button label="Sort 2" onClick="sort(l, 1)"/&gt;&#13;      &lt;/hbox&gt;&#13;   &lt;/vbox&gt;&#13;   &lt;zscript&gt;&#13;   void sort(Listbox l, int j) {&#13;      Components.sort(l.getItems(), new ListitemComparator(j));&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>浏览器的信息及控制</title>
<para>若要获取客户端的信息,你可以在根组件为onClientInfo事件注册一个事件监听器。为了控制客户端的行为，你可以使用<code>org.zkoss.zk.ui.util.Clients</code>类的功能。</para><sect2><title>
<code>onClientInfo</code>事件</title>
<para>有时，一个应用程序需要知道客户端的信息，例如时区。那么，你可以为<code>onClientInfo</code>事件提添加一个事件监听器。一旦添加了事件，客户端将会寄回一个org.zkoss.zk.ui.event.ClientInfoEvent 类的实例，从此类你可以获取客户端的信息。</para>
<programlisting>&lt;grid onClientInfo="onClientInfo(event)"&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;Time Zone &lt;label id="tm"/&gt;&lt;/row&gt;&#13;      &lt;row&gt;Screen &lt;label id="scrn"/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&#13;   &lt;zscript&gt;&#13;   void onClientInfo(ClientInfoEvent evt) {&#13;      tm.setValue(evt.getTimeZone().toString());&#13;      scrn.setValue(&#13;         evt.getScreenWidth()+"x"+evt.getScreenHeight()+"x"+evt.getColorDepth());&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/grid&gt;&#13;</programlisting>
<para>[注]: <code>onClientInfo</code>事件仅对于根组件(亦=没有任何父组件的组件)是有意义 的。</para>
<para>ZK不会存储客户端的信息，所以若有需要的话你需要手动存储。由于会话是与相同的客户端相关联的，所以你可以将客户端信息存储在会话属性中。</para>
<programlisting>session.setAttribute("px_preferred_time_zone", event.getTimeZone());&#13;</programlisting>
<para>注意，若你将时区信息存储在名为<code>px_preferred_time_zone</code>的会话变量中，那么此后此值将会成为默认的时区。详情请参考国际化一章中关于时区的部分。</para>
<para>注意，在页面被提交(且送至客户端)后，<code>onClientInfo</code>事件会从客户端被发出。因此，若你的部分组件数据依赖于客户端的信息，例如时区，你可以要求客户端重新发送请求，如下。</para>
<programlisting>import org.zkoss.util.TimeZones;&#13;...&#13;if (!TimeZones.getCurrent().equals(event.getTimeZone())&#13;   Executions.sendRedirect(null);&#13;</programlisting></sect2><sect2><title>
<code>org.zkoss.ui.util.Clients</code> 类</title>
<para>用于控制客户端视觉表现(更确切的说，为浏览器窗口)的功能被集中放置于org.zkoss.ui.util.Clients。例如，你可以滚动浏览器窗口(亦=桌面)，如下。</para>
<programlisting>Clients.scrollBy(100, 0);&#13;</programlisting></sect2><sect2><title>防止(Prevent)用户关闭窗口</title>
<para>某些情况下，你或许想防止，或至少，警告用户，当他试图关闭窗口或浏览另一个网页时。例如，当用户正在编写一封未保存的邮件时。</para>
<programlisting>if (mail.isDirty()) {&#13;   Clients.confirmClose("Your message has not been sent.\nDiscard your message?");&#13;} else {&#13;   Clients.confirmClose(null);&#13;}&#13;</programlisting>
<para>一旦调用了<code>confirmClose</code>方法且参数为非空字符串，当用户试图关闭浏览器窗口，重载，或浏览另一个URL时时就会显示一个确认对话框。<graphic fileref="img/10-4-3.png" align="center"/></para>
<para/></sect2></sect1><sect1><title>浏览器的历史管理</title>
<para>
在传统的多页面Web应用程序中，用户通常会使用BACK 或FORWARD 按钮来在多页面间切换，并将他们制作为标签以备日后使用。使用ZK，你仍然可以使用多页面来呈现一套不同的特性及信息，就像在传统的Web应用程序中那样。</para>
<para>但是，对于ZK应用程序来说，在一个桌面内显示很多特性是很平常的，而在传统Web应用程序中则通常需要多个Web页面。为使用户冲浪更简单，ZK支持浏览器的历史管理，ZK应用程序可以简单的在服务器端管理浏览器的历史。</para>
<para>概念很简单。将合适的桌面状态项目添加到浏览器的历史中，那么用户可以在同一桌面的不同状态间使用BACK 和FORWARD 按钮冲浪。当用户在这些状态间冲浪时，<code>onBookmarkChanged</code> 事件会被发出以通知应用程序。</para>
<para>从应用程序的角度来看，管理浏览器的历史需要两步：</para>
<orderedlist>
<listitem>
<para>为桌面每个合适的状态添加一个项目到浏览器的历史。 </para>
</listitem>
<listitem>
<para>监听<code>onBookmarkChanged</code>事件并据此操作朱面。</para>
</listitem>
</orderedlist><sect2><title>添加合适的状态到浏览器历史</title>
<para>你的应用程序必须决定把什么合适的状态添加到浏览器历史。例如，在一个多步操作中，每个状态都是一个很好的候选，用以添加到浏览器历史，这样用户可以在这些状态间跳转或将他们制作为标签以备日后使用。</para>
<para>一旦决定了将一个状态添加到浏览器历史，当合适时你可以简单的调用<code>org.zkoss.zk.ui.Desktop</code>接口的<code>setBookmark</code>方法。将一个状态添加到浏览器历史称为bookmarking。注意并不是用户添加到浏览器的标签(亦=IE中我的最爱)。</para>
<para>[提示]: 你可以将在服务器端添加标签成为服务器标签，以区别于浏览器标签。 </para>
<para>例如，假定你想当点击Next 按钮时将状态制为标签，可以按如下方式处理。</para>
<programlisting>&lt;button label="Next" onClick="desktop.setBookmark(&amp;quot;Step-2&amp;quot;)"/&gt;&#13;</programlisting>
<para>若你关注URL，会发现ZK为URL添加了<code>#Step-2</code>。<graphic fileref="img/10-5-1a.png"/></para>
<para>若你按下按钮，则会看到，
<graphic fileref="img/10-5-1b.png"/></para></sect2><sect2><title>监听<code>onBookmarkChanged</code>事件并据此操作桌面</title>
<para>添加一个状态到浏览器历史后，用户可以在这些状态间冲浪，例如按下BACK按钮返回前一状态。当状态改变时，ZK会通过广播<code>onBookmarkChanged</code>事件(<code>org.zkoss.zk.ui.event.BookmarkEvent</code>类的一个实例)到桌面内所有的根组件来通知应用程序。</para>
<para>不同于传统的多页面应用程序，当状态改变时，你必须手动操作ZK桌面。反映展示标签的状态是应用程序开发人员的工作。</para>
<para>为监听<code>onBookmarkChanged</code>事件，你可以为桌面内的任何页面添加事件监听器，或任一根组件。</para>
<programlisting>&lt;window onBookmarkChanged="goto(event.bookmark)"&gt;&#13;   &lt;zscript&gt;&#13;   void goto(String bookmark) {&#13;      if ("Step-2".equals(bookmark)) {&#13;         ...//create components for Step 2&#13;      } else { //empty bookmark&#13;         ...//create components for Step 1&#13;      }&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>就像处理其它的事件，当接收<code>onBookmarkChanged</code>事件后，你可以按你想的方式操纵桌面。典型的方法是使用<code>org.zkoss.zk.ui.Executions</code>类的createComponents方法。换言之，你可以使用ZUML页面呈现每个状态，然后当接收<code>onBookmarkChanged</code>时， 使用<code>createComponents</code>
<code>在其中</code>创建所有的组件。</para>
<programlisting>if ("Step-2".equals(bookmark)) {&#13;   //1. Remove components, if any, representing the previous state&#13;   try {&#13;      self.getFellow("replacable").detach();&#13;   } catch (ComponentNotFoundException ex) {&#13;      //not created yet&#13;   }&#13;&#13;   //2. Creates components belonging to Step 2&#13;   Executions.createComponents("/bk/step2.zul", self, null);&#13;}&#13;</programlisting></sect2><sect2><title>一个简单的事例</title>
<para>在这个例子中，我们为没一个tab选项制作一个标签。</para>
<programlisting>&lt;window id="wnd" title="Bookmark Demo" width="400px" border="normal"&gt;&#13;   &lt;zscript&gt;&#13;   page.addEventListener("onBookmarkChanged",&#13;      new EventListener() {&#13;         public void onEvent(Event event) throws UiException {&#13;            try {&#13;               wnd.getFellow(wnd.desktop.bookmark).setSelected(true);&#13;            } catch (ComponentNotFoundException ex) {&#13;               tab1.setSelected(true);&#13;            }&#13;         }&#13;      });&#13;   &lt;/zscript&gt;&#13;&#13;   &lt;tabbox id="tbox" width="100%" onSelect="desktop.bookmark = self.selectedTab.id"&gt;&#13;      &lt;tabs&gt;&#13;         &lt;tab id="tab1" label="Tab 1"/&gt;&#13;         &lt;tab id="tab2" label="Tab 2"/&gt;&#13;         &lt;tab id="tab3" label="Tab 3"/&gt;&#13;      &lt;/tabs&gt;&#13;      &lt;tabpanels&gt;&#13;         &lt;tabpanel&gt;This is panel 1&lt;/tabpanel&gt;&#13;         &lt;tabpanel&gt;This is panel 2&lt;/tabpanel&gt;&#13;         &lt;tabpanel&gt;This is panel 3&lt;/tabpanel&gt;&#13;      &lt;/tabpanels&gt;&#13;   &lt;/tabbox&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2></sect1><sect1><title>组件克隆</title>
<para>所有的组件都是可克隆的。换言之，它们都实现了<code>java.lang.Cloneable</code>接口。因此，复制组件是很简单的，如下。</para>
<programlisting>&lt;vbox id="vb"&gt;&#13;   &lt;listbox id="src" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem value="A"&gt;&#13;         &lt;listcell label="A. Graduate"/&gt;&#13;         &lt;listcell label="20%"/&gt;&#13;     &lt;/listitem&gt;&#13;      &lt;listitem value="B"&gt;&#13;         &lt;listcell label="B. College"/&gt;&#13;         &lt;listcell label="23%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem value="C"&gt;&#13;         &lt;listcell label="C. High School"/&gt;&#13;         &lt;listcell label="40%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;&#13;   &lt;zscript&gt;&#13;   int cnt = 0;&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Clone"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;     Listbox l = src.clone();&#13;      l.setId("dst" + ++cnt);&#13;      vb.insertBefore(l, self);&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/vbox&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>一旦组件被克隆了，所有它的子组件也都会被克隆。</para>
</listitem>
<listitem>
<para>被克隆的组件并不属于任何页面和父组件。换言之，<code>src.clone().getParent()</code>会返回null。</para>
</listitem>
<listitem>
<para>ID并未改变，若你想将被克隆的组件添加回相同的ID空间，要记住更改ID。</para>
</listitem>
</itemizedlist></sect1><sect1><title>组件序列化</title>
<para>所有组件都是可序列化的，所以你可以为内存或其它存储器序列化组件，之后再拆解它们。就像克隆，被拆解的组件不属于另一个页面(和桌面)。它们也独立于被序列化的组件。如下所述，序列化可以被用于实现相似的克隆功能。</para>
<programlisting>&lt;vbox id="vb"&gt;&#13;   &lt;listbox id="src" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem value="A"&gt;&#13;         &lt;listcell label="A. Graduate"/&gt;&#13;         &lt;listcell label="20%"/&gt;&#13;         &lt;/listitem&gt;&#13;      &lt;listitem value="B"&gt;&#13;         &lt;listcell label="B. College"/&gt;&#13;         &lt;listcell label="23%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem value="C"&gt;&#13;         &lt;listcell label="C. High School"/&gt;&#13;         &lt;listcell label="40%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;&#13;   &lt;zscript&gt;&#13;   int cnt = 0;&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Clone"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;      import java.io.*;&#13;      ByteArrayOutputStream boa = new ByteArrayOutputStream();&#13;      new ObjectOutputStream(boa).writeObject(src);&#13;      Listbox l = new ObjectInputStream(&#13;         new ByteArrayInputStream(boa.toByteArray())).readObject();&#13;      l.setId("dst" + ++cnt);&#13;      vb.insertBefore(l, self);&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/vbox&gt;&#13;</programlisting>
<para>当然，使用<code>clone</code>方法克隆会有更好的性能，而序列化组件可以被用于不同的机器之间。</para><sect2><title>序列化会话</title>
<para>默认情况下，一个非序列化的实现会被用于表示一个会话(<code>org.zkoss.zk.ui.Session</code>)。使用非序列化实现的好处是不需要担心存储在一个组件内的值，例如<code>Listitem's setValue</code>，是否为可序列化的。</para>
<para>但是，若你想确认存储在组件内的所有值都是可序列化的，可以使用一个序列化的实现表示一个会话。</para>
<para>为了配置ZK使用序列化实现，你需要在<code>WEB-INF/zk.xml</code>
<code>内</code>配置<code>factory-class</code>元素，细节请参考the Developer's Reference 的附录B(Appendix B)。</para></sect2><sect2><title>序列化监听器</title>
<para>存储在一个组件，页面，桌面或会话内的属性，变量和监听器也会被序列化，如果它们是可序列化的(且相应的组件，页面，桌面或会话会被序列化)。</para>
<para>为简化可序列化对象的实现，ZK会在序列化前和拆解之后调用序列化监听器，若实现了特定的接口。例如，你可以按如下方式为一个组件实现事件监听器。</para>
<programlisting>public MyListener&#13;implements EventListener, java.io.Serializable, ComponentSerializationListener {&#13;
 private transient Component _target; //no need to serialize it
  //ComponentSerializationListener//
   public willSerialize(Component comp) {
   }
   public didDeserialize(Component comp) {
      _target = comp; //restore it back
   }
}</programlisting>
<para>
<code>org.zkoss.zk.ui.util.ComponentSerializationListener</code>接口被用于序列化一个组件时。类似的，<code>PageSerializationListener</code>，<code>DesktopSerializationListen</code> 和<code>SessionSerializationListener</code> 被分别用于序列化一个页面，桌面和会话时。</para></sect2></sect1><sect1><title>跨页面通信</title>
<para>在同一桌面内不同页面间通信是很直接的。首先，可以使用事件来互相通知。其次，可以使用属性共享数据。</para><sect2><title>提交和发送事件</title>
<para>你可以在同一桌面的不同页面间通信。通信方式是使用<code>postEvent</code>或<code>sendEvent</code>通知目标页面的组件。</para>
<programlisting>Events.postEvent(new Event("SomethingHappens",&#13;   comp.getDesktop().getPage("another").getFellow("main"));&#13;</programlisting></sect2><sect2><title>属性</title>
<para>每个组件，页面，桌面，会话和Web应用程序都一个独立的属性映射。这是一个在组件，页面，桌面，甚至会话间共享数据的好地方。</para>
<para>在<code>zscript</code>和EL表达式中，你可以使用隐含对象 ：<code>componentScope</code>
<code>，</code>
<code>pageScope</code>
<code>，</code>
<code>desktopScope</code>
<code>，</code>
<code> sessionScope</code>
<code>，</code>
<code>requestScope </code>
<code>和</code>
<code> applicationoScope</code>。</para>
<para>在一个Java文件中，你可以使用相应类中的属性相关方法来访问它们。你也可以使用作用域(scope)参数来标识你想访问的作用域。下面的两条语句是等价的，假定comp 为一个组件。</para>
<programlisting>comp.getAttribute("some", comp.DESKTOP_SCOPE);&#13;
comp.getDesktop().getAttribute("some");</programlisting></sect2></sect1><sect1><title>跨Web应用程序通信</title>
<para>一个EAR文件可以包含多个WAR文件。每个WAR都为一个Web应用程序。在两个Web应用程序间通信没有标准的方法。</para>
<para>但是，ZK支持从另一个Web应用程序引用文件。例如，假定你想从另一个Web应用程序，例如<code>app2</code>，包含一个资源，例如<code>/foreign.zul</code>。那么，你可以按如下方式处理。</para>
<programlisting>&lt;include src="~app2/foreign.zul"/&gt;&#13;</programlisting>
<para>类似的，你可以从另一个Web应用程序引用一个样式表。 </para>
<programlisting>&lt;style src="~app2/foreign.css"/&gt;&#13;</programlisting>
<para>[注]： 是否能够访问到另一个Web应用程序指定位置的资源依赖于Web服务器的配置。例如，若使用Tomcat，你必须在 conf/context.xml 内指定<code>crossContext="true"</code>
<code>。</code> </para><sect2><title>来自路径的Web资源</title>
<para>使用ZK，你可以引用由classpath定位的资源。这样做的好处是可以将Web资源嵌入JAR文件，简化了部署。</para>
<programlisting>&lt;img src="~./my/jar.gif"/&gt;&#13;</programlisting>
<para>然后，它会通过从classpath寻找资源在/web 目录定位资源，<code>/my/jar.gif</code>。</para></sect2></sect1><sect1><title>注释</title>
<para>注释提供了关于一个组件的数据，这些数据并不属于组件本身。它们在所注释组件的操作上并没有直接的影响。而是，它们在运行时被检测，主要由工具或管理者使用。注释的内容和意义完全取决于开发人员使用的工具或管理者。例如，一个数据绑定管理者可以检测注释，以知道组件值要被存储的数据源。</para><sect2><title>注释ZUML页面</title>
<para>注释可被用于ZUML页面中组件和属性的声明。有两种注释方式：标准的方式和简单的方式。选择娜种看你的喜好。若喜欢的话可以在同一页面内混合使用它们。</para><sect3><title>注释组件声明的标准方式</title>
<para>注释要放在你想注释的元素声明之前：</para>
<programlisting>&lt;window xmlns:a="http://www.zkoss.org/2005/zk/annotation"&gt;&#13;   &lt;vbox&gt;&#13;      &lt;a:author name="John Magic" date="3/17/2006"/&gt;&#13;      &lt;listbox&gt;&#13;      &lt;/listbox&gt;&#13;...&#13;</programlisting>
<para>annotation为<ulink url="http://www.zkoss.org/2005/zk/annotation">http://www.zkoss.org/2005/zk/annotation</ulink>空间内的一个元素。元素的名字和属性可以是依赖于你所使用工具的一切。你可以使用几个注释为相同的组件声明注释：</para>
<programlisting>&lt;a:author name="John Magic"/&gt;&#13;&lt;a:editor name="Mary White" date="4/11/2006"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>author和editor为注释的名称，而name和date为属性名称。换言之，注释由名称和属性映射组成。</para>
<para>若两个注释有相同的名称，则它们会被合并为一个注释。例如，</para>
<programlisting>&lt;a:define var1="auto"/&gt;&#13;&lt;a:define var2="123"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>等价于</para>
<programlisting>&lt;a:define var1="auto" var2="123"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>[注]： 注释不支持EL表达式。</para></sect3><sect3><title>注释属性声明的标准方式</title>
<para>为注释一个属性声明，你可以将注释放置于属性声明之前，如下所示。</para>
<programlisting>&lt;listitem a:bind="datasource='author',name='name'" value="${author.name}"/&gt;&#13;</programlisting>
<para>或者，你可以使用<code>attribute</code>元素，然后简单的注释属性声明，类似于为组件声明注释。换言之，上面的注释等价于下面的注释：</para>
<programlisting>&lt;listitem&gt;&#13;   &lt;a:bind datasource="author" name="name"/&gt;&#13;   &lt;attribute name="value"&gt;${author.name}&lt;/attribute&gt;&#13;&lt;/listitem&gt;&#13;</programlisting>
<para>注：若忽略了属性名称，则名称为<code>value</code>。例如，</para>
<programlisting>&lt;listitem a:bind="value='selected'" value=""/&gt;&#13;</programlisting>
<para>等价于</para>
<programlisting>&lt;listitem a:bind="selected" value=""/&gt;&#13;</programlisting></sect3><sect3><title>注释属性声明的简单方式</title>
<para>除了如上描述的使用特定XMl命名空间进行注释，有一种简单的注释属性的方法：为要注释的属性使用注释表达式指定一个值，如下所示。</para>
<programlisting>&lt;listitem label="@{bind(datasource='author',selected)}"/&gt;&#13;</programlisting>
<para>注释表达式的格式为<code>@{</code>
<code>annot-name</code>
<code>(</code>
<code>attr-name1</code>
<code>=</code>
<code>attr-value1，attr-name2=attr-value2</code>
<code>)}</code>。换言之，若属性值为一个注释表达式，则会被认为是为相应属性的注释，而不是其值。在上面的例子中，名为<code>bind</code>的注释为<code>label</code>属性注释。因此，其等价于</para>
<programlisting>&lt;listitem a:bind=" datasource='author',selected" label=""/&gt;&#13;</programlisting>
<para>若没有指定注释名称，则假定名称为<code>default</code>。例如，下面的代码片断使用了<code>default</code>作为注释名称为<code>label</code>属性注释，且注释有一个属性，名称和值分别为<code>value</code>和<code>selected.name</code>。</para>
<programlisting>&lt;listitem label="@{selected.name}"/&gt;&#13;</programlisting>
<para>换言之，等价于下面的代码片断：</para>
<programlisting>&lt;listitem label="@{default(value='selected.name')}"/&gt;&#13;</programlisting>
<para>注：你可以使用多个注释为相同的属性注释，如下所示。</para>
<programlisting>&lt;listitem label="@{ann1(selected.name) ann2(attr2a='attr2a',attr2b)}"/&gt;&#13;</programlisting></sect3><sect3><title>注释组件声明的简单方式</title>
<para>类似的，你可以通过为一个名为<code>self</code>的特定属性指定注释表达来注释一个组件。</para>
<programlisting>&lt;listitem self="@{bind(each=person)}"/&gt;&#13;</programlisting>
<para>
<code>self</code>为一个关键字，表示注释被用于注释组件声明，而不是任何属性。换言之，等价于</para>
<programlisting>&lt;a:bind each="person"/&gt;&#13;&lt;listitem/&gt;&#13;</programlisting></sect3></sect2><sect2><title>手动注释组件</title>
<para>通过使用<code>org.zkoss.zk.ui.sys.ComponentCtrl</code>接口的<code>addAnnotation</code> 方法，你可以在运行时注释一个组件。</para>
<programlisting>Listbox listbox = new Listbox();&#13;listbox.addAnnotation("some", null);&#13;</programlisting></sect2><sect2><title>获取注释</title>
<para>可以在运行时取回注释。通常由工具获取，例如数据绑定管理者，而不是应用程序。换言之，为某一特定目的，应用程序注释ZUML页面以告诉工具如何处理组件。</para>
<para>下面为转储一个组件所有注释的例子：</para>
<programlisting>void dump(StringBuffer sb, Component comp) {&#13;   ComponentCtrl compCtrl = (ComponentCtrl)comp;&#13;   sb.append(comp.getId()).append(": ")&#13;     .append(compCtrl .getAnnotations()).append('\n');&#13;&#13;   for (Iterator it = compCtrl.getAnnotatedProperties().iterator(); it.hasNext();) {&#13;      String prop = it.next();&#13;      sb.append(" with ").append(prop).append(": ")&#13;         .append(compCtrl .getAnnotations(prop)).append('\n');&#13;   }&#13;}&#13;</programlisting></sect2></sect1><sect1><title>Richlets</title>
<para>richlet 为一个小型的Java程序，可以创建所有必须的组件以响应用户的请求。</para>
<para>当用户请求一个URL内容时，ZK加载器会检查指定的URL资源是一个ZUML页面，还是一个richlet。若为ZUML页面， ZK加载器会基于ZUML页面的内容自动创建组件，就像在前面章节描述的那样。</para>
<para>若资源为一个richlet， ZK加载器会将处理交给richlet。创建什么组件与如何创建组件都由richlet 处理。换言之，编程创建所有需要的组件以响应用户请求是开发人员的工作。</para>
<para>选择ZUML页面还是richlet取决于你的偏好。对于大多数开发人员，ZUML页面更具有可读性和简洁性。</para>
<para>实现一个richlet是很直接的。首先，实现<code>org.zkoss.zk.ui.Richlet</code>接口，然后声明richlet 的注释及一个URL。</para><sect2><title>实现<code>org.zkoss.zk.ui.Richlet</code>接口</title>
<para>所有的richlet都必须实现<code>org.zkoss.zk.ui.Richlet</code>接口。为将实现所有方法的影响降至最低，可以继承<code>org.zkoss.zk.ui.GenericRichlet</code>类代替。然后，当请求指定的URL时，<code>service</code>方法会被调用，然后你可创建用户界面。</para>
<programlisting>package org.zkoss.zkdemo;

import org.zkoss.zk.ui.Page;
import org.zkoss.zk.ui.GenericRichlet;
import org.zkoss.zk.ui.event.*;
import org.zkoss.zul.*;

public class TestRichlet extends GenericRichlet {
   //Richlet//   public void service(Page page) {
   page.setTitle("Richlet Test");
   
   final Window w = new Window("Richlet Test", "normal", false);
   new Label("Hello World!").setParent(w);
   final Label l = new Label();
   l.setParent(w);

   final Button b = new Button("Change");
	b.addEventListener(Events.ON_CLICK,
		new EventListener() {
            int count;
            public void onEvent(Event evt) {
				l.setValue("" + ++count);
            }
		});
	b.setParent(w);

	w.setPage(page);
  }
}&#13;</programlisting>
<para>就像servlet，你可以实现<code>init</code>和<code>destroy</code>方法以在加载时初始化和销毁richlet。就像servlet，richlet被加载一次，且为关联URL的所有请求服务。</para><sect3><title>每个URL一个Richlet</title>
<para>就像servlet，一个richlet被创建且为相同的URL所共享。换言之，richlet必须为线程安全的。另外，组件是不共享的。每个桌面都一套独立的组件。因此，将组件作为一个richlet 的数据成员来存储通常并不是一个好主意。</para>
<para>有许多方式来来解决这个问题。一个典型的方法是使用另一个类来处理每个桌面的组件，如下所述。</para>
<programlisting>class MyApp { //one per desktop&#13;   Window _main;&#13;   MyApp(Page page) {&#13;      _main = new Window();&#13;      _main.setPage(page);&#13;   }&#13;}&#13;&#13;class MyRichlet extends GenericRichlet {&#13;   public void service(Page page) {&#13;      new MyApp(page); //create and forget&#13;   }&#13;}&#13;</programlisting></sect3></sect2><sect2><title>配置<code>web.xml </code>和<code>zk.xml</code>
</title>
<para>在实现richlet 之后，你可以在<code>zk.xml</code>中使用下列语句定义richlet。</para>
<programlisting>&lt;richlet&gt;&#13;   &lt;richlet-name&gt;Test&lt;/richlet-name&gt;&#13;   &lt;richlet-class&gt;org.zkoss.zkdemo.TestRichlet&lt;/richlet-class&gt;&#13;&lt;/richlet&gt;&#13;</programlisting>
<para>一旦声明了一个richlet，你可以使用<code>richlet-mapping</code>将其映射到任意数量的URL，如下所示。 </para>
<programlisting>&lt;richlet-mapping&gt;&#13;   &lt;richlet-name&gt;Test&lt;/richlet-name&gt;&#13;   &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&#13;&lt;/richlet-mapping&gt;&#13;&lt;richlet-mapping&gt;&#13;   &lt;richlet-name&gt;Test&lt;/richlet-name&gt;&#13;   &lt;url-pattern&gt;/some/more/*&lt;/url-pattern&gt;&#13;&lt;/richlet-mapping&gt;&#13;</programlisting>
<para>默认情况下，richlet是不可用的。为启用richlet，你必须在<code>web.xml</code>中添加下列声明。一旦启用了richlet，你可以添加任意多的richlet而无需再修改<code>web.xml</code>。</para>
<programlisting>&lt;servlet-mapping&gt;&#13;   &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;   &lt;url-pattern&gt;/zk/*&lt;/url-pattern&gt;&#13;&lt;/servlet-mapping&gt;&#13;</programlisting>
<para>然后，你可以访问<ulink url="http://localhost/zk/test">http://localhost/zk/test</ulink>来请求richlet。</para>
<para>在<code>url-pattern</code>元素内指定的URL必须以<code>/</code>开始。若URL以<code>/*</code>开始，那么它会匹配所有相同前缀的请求。为获取真实的请求，你可以检查由当前页面的<code>getRequestPath</code>方法返回的值。</para>
<programlisting>public void service(Page page) {&#13;   if ("/some/more/hi".equals(page.getRequestPath()) {&#13;          ...&#13;   }&#13;}&#13;</programlisting>
<para>[提示]: 通过为<code>url-pattern</code>指定<code>/*</code>，你可以将所有不匹配的URL映射到被映射的 richlet 。</para></sect2></sect1><sect1><title>会话超时管理</title>
<para>当会话超时之后，所有它属于的桌面都会被移除。若用户继续访问已经不存在的桌面，浏览器端会显示一条错误信息来提醒用户。</para>
<para>有时最好转到另一个页面，这样可以给用户更易理解的描述，引导他们转向其它资源，或要求他们重新登录。你可以在<code>WEB-INF</code>目录下的<code>zk.xml</code>文件内指定目标URI，即超时的时候重定向的路径。例如，目标URI为 /timeout.zul，那么你可以将下列几行添加到<code>zk.xml</code>。</para>
<programlisting>&lt;device-config&gt;&#13;   &lt;device-type&gt;ajax&lt;/device-type&gt;&#13;   &lt;timeout-uri&gt;/timeout.zul&lt;/timeout-uri&gt;&#13;&lt;/device-config&gt;&#13;</programlisting>
<para>[提示]： 每个设备都有一个确切的超时URI。更多关于<code>zk.xml</code>信息请参考the Developer's Reference 的附录B(Appendix B)。</para>
<para>除了配置<code>zk.xml</code>，你可以手动更改重定向的URI，如下。</para>
<programlisting>Devices.setTimeoutURI("ajax", "/timeout.zul");&#13;</programlisting>
<para>[关于Device]： device代表客户端device。每个桌面都关联一个device ，反之亦然。</para>
<para>若你更喜欢重载页面，而不是重定向到其它的URI，可以指定一个空的URI，如下。</para>
<programlisting>&lt;device-config&gt;&#13;   &lt;device-type&gt;ajax&lt;/device-type&gt;&#13;   &lt;timeout-uri&gt;&lt;/timeout-uri&gt;&#13;&lt;/device-config&gt;&#13;</programlisting></sect1><sect1><title>错误处理</title>
<para>ZK Web应用程序可以指定错误发生时该做什么。错误是由异常引起的，而应用程序没有捕获到这个异常。</para>
<para>在两种情况下可能会抛出异常：加载页面和更新页面<footnote>
<para>细节请参考组件活动周期(the Component Lifecycle)一章。</para>
</footnote>。</para><sect2><title>加载页面时的错误处理</title>
<para>若加载ZUML页面时抛出了一个未捕获的异常，此异常会直接由Web服务器处理。换言之，这和其它页面的处理没有区别，例如JSP。</para>
<para>默认情况下，Web服务器会使用一个错误页面来显示错误信息及栈跟踪。</para>
<para/>
<para>
<graphic fileref="img/10-13-1.png" align="center"/>
</para>
<para>通过在<code>WEB-INF/web.xml</code>文件内指定错误页面，你可以定制错误处理，如下。细节请参考Java Servlet Specification。</para>
<programlisting>&lt;!-- web.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>那么，当加载页面时发生一个错误，Web服务器会转向你指定的错误页面，<code>/error/error.zul</code>。转发之后，Web 服务器会立即将一套请求属性传递到错误页面以描述发生了什么。这些属性如下。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>请求属性</para>
</entry>
<entry>
<para>类型</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>javax.servlet.error.status_code</para>
</entry>
<entry>
<para>java.lang.Integer</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.exception_type</para>
</entry>
<entry>
<para>java.lang.Class</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.message</para>
</entry>
<entry>
<para>java.lang.String</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.exception</para>
</entry>
<entry>
<para>java.lang.Throwable</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.request_uri</para>
</entry>
<entry>
<para>java.lang.String</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.servlet_name</para>
</entry>
<entry>
<para>java.lang.String</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>然后，在错误页面内，通过使用这些属性，你可以显示你的定制信息。例如，</para>
<programlisting>&lt;window title="Error ${requestScope['javax.servlet.error.status_code']}"&gt;&#13;   Cause: ${requestScope['javax.servlet.error.message']}&#13;&lt;/window&gt;&#13;</programlisting>
<para>[提示]：错误页面可以为任何类型的 servlet。除了ZUL，可以使用JSP或任何你喜欢的页面。 </para>
<para>[提示]：转发之后， 错误页面会被作为主页面展示，所以你不需要指定主窗口指定模态(modal)或 overlapped 模式。 </para><sect3><title>ZK Mobile错误处理</title>
<para>Servlet 2.x (<code>web.xml</code>)没有device类型的概念。因此，若想在相同的服务器端同时支持Ajax浏览器和移动设备，你必须转向正确的页面。这里有一个例子：</para>
<programlisting>//error.zul&#13;&lt;zk&gt;&#13;   &lt;zscript&gt;&#13;   if (Executions.getCurrent().isMilDevice())&#13;      Executions.forward("error.mil");&#13;   &lt;/zscript&gt;&#13;   &lt;window&gt;&#13;   ....error message in ZUL&#13;   &lt;/window&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect3></sect2><sect2><title>更新页面时的错误处理</title>
<para>若当更新ZUML页面(亦=一个事件监听器正在执行时)时抛出了一个未被捕获的异常，此异常会由ZK更新引擎处理。默认情况下，它只会要求浏览器端显示一个警告对话框来告诉用户。</para>
<para>
<graphic fileref="img/10-13-2a.png" align="center"/>
</para>
<para>你可以在<code>WEB-INF/zk.xml</code>文件内指定错误页面以定制错误处理，如下。参考the Developer's Reference 的附录B(Appendix B)。</para>
<programlisting>&lt;!-- zk.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>那么，当在事件监听器内发生一个错误时，ZK更新引擎会使用你指定的错误页面，<code>/error/error.zul</code>，创建一个对话框。</para>
<para>就像加载一个页面时的错误处理，你可以指定多个<code>&lt;error-page&gt;</code>元素。其中的每个元素都与一个不同的异常类型(<code>&lt;exception-type&gt;</code>元素的值)相关联。当发生一个错误时，ZK将会逐个寻找错误页面，直到异常类型匹配。</para>
<para>另外，ZK将一套请求属性传递到错误页面来描述发生了什么。这些属性如下。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>请求属性</para>
</entry>
<entry>
<para>类型</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>javax.servlet.error.exception_type</para>
</entry>
<entry>
<para>java.lang.Class</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.message</para>
</entry>
<entry>
<para>java.lang.String</para>
</entry>
</row>
<row>
<entry>
<para>javax.servlet.error.exception</para>
</entry>
<entry>
<para>java.lang.Throwable</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>例如，你可以指定下列的内容作为错误页面。</para>
<programlisting>&lt;window title="Error ${requestScope['javax.servlet.error.status_code']}"&#13;width="400px" border="normal" mode="modal"&gt;&#13;   &lt;vbox&gt;&#13;   KillerApp encounters a fatal error, ${requestScope['javax.servlet.error.message']}.&#13;The error is recorded and we will look at it and fix it soon.&#13;          &lt;hbox style="margin-left:auto; margin-right:auto"&gt;&#13;         &lt;button label="Continue" onClick="spaceOwner.detach()"/&gt;&#13;         &lt;button label="Reload" onClick="Executions.sendRedirect(null)"/&gt;&#13;      &lt;/hbox&gt;&#13;   &lt;/vbox&gt;&#13;   &lt;zscript&gt;&#13;   org.zkoss.util.logging.Log.lookup("Fatal").log(&#13;      requestScope.get("javax.servlet.error.exception"));&#13;   &lt;/zscript&gt;&#13;
&lt;/window&gt;</programlisting>
<para>
<graphic fileref="img/10-13-2b.png" align="center"/>
</para>
<para>[提示]： 错误页面是在引起错误的相同卓面内被创建的，所以你可以从其中获取相关的信息。</para>
<para>[提示]：从2.3.1开始，ZK不会自动将根窗口作为模态(modal)，因为一些应用程序或许并不倾向于使用modal窗口。若你倾向于使用模态窗口，可以指定为模态 模式，就像前面所示的例子那样。 </para><sect3><title>更新页面时ZK Mobile的错误</title>
<para>每个device类型都有其自己的一套错误页面。为了为ZK mobile设备指定一个错误页面(支持MIL 的移动设备)，你必须使用<code>mil</code>指定<code>device-type</code>元素，如下所示。</para>
<programlisting>&lt;!-- zk.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;device-type&gt;mil&lt;/device-type&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>[提示]: 若忽略了<code>device-type</code>元素,则假定为ajax。换言之，为Ajax浏览器指定了一个错误页面。
<code>&lt;device-type&gt;ajax&lt;/device-type&gt; &lt;!-- ajax is the default --&gt;</code>
</para></sect3></sect2></sect1><sect1><title>其它</title><sect2><title>配置ZK加载器不压缩输出</title>
<para>默认情况下，若浏览器支持内容压缩<footnote>
<para>参考http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html中的14.3，Accept-Encoding。</para>
</footnote>(且输出不被servlets其它所包含)，ZK加载器和过滤器的输出是被压缩的。通过压缩输出，在慢速网络上的传输时间被大幅降低。</para>
<para>但是，若你想使用过滤器来后处理输出，压缩未必适用。在这种情况下，你可以将<code>compress</code>参数(<code>init-param</code>)指定为true以禁用压缩，<code>WEB-INF/web.xml</code>文件中的ZK加载器配置如下。</para>
<programlisting>&lt;servlet&gt;&#13;   &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;   &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;update-uri&lt;/param-name&gt;&#13;      &lt;param-value&gt;/zkau&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;compress&lt;/param-name&gt;&#13;      &lt;param-value&gt;false&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;&lt;/servlet&gt;&#13;</programlisting>
<para>注意：你可以在一个应用程序中配置多个ZK加载器。每个拥有不同的选项。</para>
<programlisting>&lt;servlet&gt;&#13;   &lt;servlet-name&gt;zkLoader1&lt;/servlet-name&gt;&#13;   &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;&#13;...&#13;&lt;/servlet&gt;&#13;&lt;servlet&gt;&#13;   &lt;servlet-name&gt;zkLoader2&lt;/servlet-name&gt;&#13;   &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;&#13;...&#13;&lt;/servlet&gt;&#13;</programlisting>
<para>类似的，你也可以配置ZK过滤器(<code>org.zkoss.zk.ui.http.DHtmlLayoutFilter</code>)来禁止压缩。</para>
<programlisting>&lt;filter&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;filter-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutFilter&lt;/filter-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;extension&lt;/param-name&gt;&#13;      &lt;param-value&gt;html&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;compress&lt;/param-name&gt;&#13;      &lt;param-value&gt;false&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;&lt;/filter&gt;&#13;</programlisting></sect2></sect1></chapter>
<chapter>
<title>11. 性能提示</title>
<para>本章将要讲述使你的ZK应用程序运行的更快的提示。</para><sect1><title>使用编译过的Java代码</title>
<para>在ZUML中使用zscript很方便，但是这需要付出代价：性能较低。降级随应用程序不同而不同。对于大型的网站，建议尽可能的不使用zscript。</para><sect2><title>使用<code>deferred</code> 属性</title>
<para>若你仍然需要编写zscript 代码，可以指定<code>deferred</code> 属性来延迟zscript 代码的赋值，如下。</para>
<programlisting>&lt;zscript deferred="true"&gt;&#13;...&#13;</programlisting>
<para>通过指定<code>deferred</code>属性，它包含的zscript 代码在ZK提交一个页面时不会被赋值。这意味着当ZK提交一个页面时，解释其不会被加载。这节省了内存且加速了页面的提交。</para>
<para>在下面的例子中，仅当按钮被点击时解释器才会被加载：</para>
<programlisting>&lt;window id="w"&gt;&#13;   &lt;zscript deferred="true"&gt;&#13;   void addMore() {&#13;      new Label("More").setParent(w);&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Add" onClick="addMore()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>
<code>deferred</code>属性和<code>onCreate</code>事件</title>
<para>这值得注意，若<code>onCreate</code>事件监听器由zscript 编写，在前面提到的deferred 选项会变得无效。这是因为<code>onCreate</code>事件是在加载页面时被送出的。换言之，若<code>onCreate</code>事件监听器由zscript 编写，所有被延迟的zscript会在加载页面时被赋值，如下所示。</para>
<programlisting>&lt;window onCreate="init()"&gt;&#13;...&#13;</programlisting>
<para>最好重写为</para>
<programlisting>&lt;window use="my.MyWindow"&gt;&#13;...&#13;</programlisting>
<para>然后准备<code>MyWindow.java</code>，如下。</para>
<programlisting>package my;&#13;public class MyWindow extends Window {&#13;   public void onCreate() { //to process the onCreate event&#13;...&#13;</programlisting>
<para>若你喜欢在创建了组件(及该组件所有的子组件)之后马上进行初始化，可以是实现<code>org.zkoss.zk.ui.ext.AfterCompose</code>接口，如下。注：<code>AfterCompose</code>接口的<code>afterCompose</code>方法是在组件创建阶段被赋值的，而onCreate事件是在事件处理阶段被赋值的。</para>
<programlisting>package my;&#13;public class MyWindow extends Window implements org.zkoss.zk.ui.ext.AfterCompose {&#13;   public void afterCompose() { //to initialize the window&#13;...&#13;</programlisting></sect2><sect2><title>使用<code>forward</code>属性</title>
<para>为简化事件流，ZK经常会将事件送至组件本身，而不是父组件或其它目标。例如，当用户点击一个按钮时，<code>onClick</code>事件会被送至button。开发人员通常使用<code>onClick</code>事件监听器将事件转发至window，如下。</para>
<programlisting>&lt;window id="w"&gt;&#13;   &lt;button label="OK" onClick="w.onOK"/&gt;&#13;</programlisting>
<para>正如在前面章节建议的那样，不使用zscript可以提高性能。因此，你可以使用<code>EventListener</code>或按如下方式指定<code>forward</code>属性来重写代码片断。</para>
<programlisting>&lt;window&gt;&#13;   &lt;button label="OK" forward="onOK"/&gt;&#13;</programlisting></sect2></sect1><sect1><title>使用Servlet 线程处理事件</title>
<para>默认情况下，ZK在一个被称为事件处理线程的独立线程中处理事件。因此，开发人员可以在任何时间挂起和恢复执行，而无需阻塞将响应送回服务器的servlet线程。</para>
<para>但是，这消耗了更多的内存，尤其是有许多被挂起的线程的时，且可能会在整合其它系统时引起一些挑战，这些系统将信息存储在Servlet的本地存储器中。</para>
<para>ZK提供了一个选择，用来禁用事件处理线程。换言之，你可以强制ZK在Servlet线程中处理所有的事件，就像其它的传统框架。当然，若Servlet 线程已被使用，你可以挂起执行。</para>
<para>为禁用事件处理线程，你必须在<code>WEB-INF/zk.xml</code>文件中指定下面的代码。</para>
<programlisting>&lt;system-config&gt;&#13;   &lt;disable-event-thread/&gt;&#13;&lt;/system-config&gt;&#13;</programlisting>
<para>这里是使用Servlet线程处理事件的优点和局限。在下面的章节中，我们将会更多的讨论关于使用Servlet线程时的限制和workaround。</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para/>
</entry>
<entry>
<para>使用Servlet线程</para>
</entry>
<entry>
<para>使用事件处理线程</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>整合</para>
</entry>
<entry>
<para>很少的整合问题。</para>
<para>很多容器假定HTTP请求在servlet内被处理。</para>
<para/>
</entry>
<entry>
<para>你或许必须实现EventThreadInit和/或EventThreadCleanup来解决整合问题。</para>
<para>ZK和社会(community)会不断提供更多的实现来解决整合问题。</para>
</entry>
</row>
<row>
<entry>
<para>挂起</para>
<para>恢复</para>
</entry>
<entry>
<para>没有办法挂起事件监听器的执行。</para>
<para>例如，你可以创建一个模态窗口。</para>
</entry>
<entry>
<para>根本没有限制。</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect2><title>模态窗口(Modal Windows)</title>
<para>你可以不再使用模态窗口。你可以使用highlighted 模式创建相同的视觉效果。但是，在服务器端，它就像overlapped模式一样工作-立即返回而无需等待用户的响应。</para>
<programlisting>win.doHighlighted(); //returns once the mode is changed; not suspended&#13;</programlisting></sect2><sect2><title>消息框</title>
<para>消息框会立即返回，所以总是返回<code>Messagebox.OK</code>。因此，对于显示OK按钮以外的按钮，它是没有意义的。例如，下面例子中的<code>if</code>
<code>子</code>句就不会为true。</para>
<programlisting>if (Messagebox.show("Delete?", "Prompt", Messagebox.YES|Messagebox.NO, Messagebox.QUESTION) == Messagebox.YES) {&#13;   this_never_executes();&#13;}&#13;</programlisting></sect2><sect2><title>文件上传</title>
<para>文件上传对话框不再适用。而你需要使用<code>fileupload</code>组件代替。<code>fileupload</code>组件并不是一个模态对话框。它和其它组件一起被内联置于页面内。更多信息请参考<code>fileupload</code>组件章节。</para>
<programlisting>&lt;fileupload onUpload="handle(event)"/&gt;&#13;</programlisting></sect2></sect1><sect1><title>使用本地命名空间代替XHTML命名空间</title>
<para>就像在ZUML及XUL组件集一章中使用HTML标签一节描述的那样，ZK使用XHTML命名空间为每个指定的XML元素创建一个ZK组件。换言之，ZK 必须维护它们在服务器端的状态。由于HTML标签的数量通常很大，所以若你使用本地命名空间代替可以显著提高性能。</para>
<para>例如，下面的代码片断会创建五个组件(一个<code>table</code>，<code>tr</code>，<code>textbox</code>和两个<code>td</code>)。</para>
<programlisting>&lt;h:table xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;   &lt;h:tr&gt;&#13;      &lt;h:td&gt;Name&lt;/h:td&gt;&#13;      &lt;h:td&gt;&#13;      &lt;textbox/&gt;&#13;      &lt;/h:td&gt;&#13;   &lt;/h:tr&gt;&#13;&lt;/h:table&gt;&#13;</programlisting>
<para>另外，下面的代码片断会创建两个组件(一个特殊的组件，为客户端产生<code>table</code>，<code>tr</code>和<code>td</code>，和一个<code>textbox</code> )。</para>
<programlisting>&lt;n:table xmlns:n="http://www.zkoss.org/2005/zk/native"&gt;&#13;   &lt;n:tr&gt;&#13;      &lt;n:td&gt;Name&lt;/n:td&gt;&#13;      &lt;n:td&gt;&#13;      &lt;textbox/&gt;&#13;      &lt;/n:td&gt;&#13;   &lt;/n:tr&gt;&#13;&lt;/n:table&gt;&#13;</programlisting>
<para>注意，<code>table</code>，<code>tr</code> 和<code>td</code>会直接为客户端产生，所以它们在客户端没有副本。因此，你不能够动态改变它。例如，下面的代码片断是错误的。</para>
<programlisting>&lt;n:ul id="x" xmlns:n="http://www.zkoss.org/2005/zk/native"/&gt;&#13;&lt;button label="add" onClick="new Li().setParent(x)"/&gt;&#13;</programlisting>
<para>而是，你若想动态改变它们，你必须使用<code>html</code>组件或XHTML命名空间。</para></sect1><sect1><title>延长时期检查文件是否被修改</title>
<para>Zk缓存ZUML页面解析的结果，且仅当页面被修改时才重新编译。在一个生产系统中，ZUML页面很少被修改，所以通过在<code>WEB-INF/zk.xml</code>文件内指定<code>file-check-period</code>，你可以延长时期以检查页面是否被修改，如下所示。默认为5秒。</para>
<programlisting>&lt;desktop-config&gt;&#13;   &lt;file-check-period&gt;600&lt;/file-check-period&gt;&lt;!-- unit: seconds --&gt;&#13;&lt;/desktop-config&gt;&#13;</programlisting></sect1><sect1><title>延迟子组件的创建</title>
<para>对于更复杂的页面，若我们将子组件延迟到它们变得可见时才创建它们，会显著提高性能。最简单的方式为使用<code>fulfill</code>属性。在下面的例子中，第二个tabpanel 的子组件仅当它变得可见时才会被创建。参考ZK用户界面标记语言一章中关于随机存取的部分。</para>
<programlisting>&lt;tabbox&gt;&#13;   &lt;tabs&gt;&#13;      &lt;tab label="Preload" selected="true"/&gt;&#13;      &lt;tab id="tab2" label="OnDemand"/&gt;&#13;   &lt;/tabs&gt;&#13;   &lt;tabpanels&gt;&#13;      &lt;tabpanel&gt;&#13;      This panel is pre-loaded since no fulfill specified&#13;      &lt;/tabpanel&gt;&#13;      &lt;tabpanel fulfill="tab2.onSelect"&gt;&#13;      This panel is loaded only tab2 receives the onSelect event&#13;      &lt;/tabpanel&gt;&#13;   &lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect1><sect1><title>为大型Listbox使用实况数据和分页</title>
<para>将一个拥有大量项的listbox发送至客户端的代价是很昂贵的。此外，浏览器的JavaScript引擎并不擅于使用大量项初始化一个listbox。更好的解决方法是使用实况数据，也就是说，为它指派一个list model。然后，列表项仅在可见时才会被送至客户端。</para>
<para>若使用分页模式，性能会进一步提升。</para>
<para>细节请参考ZUML及XUL组件集一章中关于列表框的部分。</para></sect1><sect1><title>如果花费太长的时间打开模态(Modal)窗口</title>
<para>当打开一个模态窗口时，所有不属于模态窗口的组件都会失效。但是，若页面太大，性能或许会不可接受(取决于浏览器的JavaScript解释器及客户端电脑的速度)。若打开一个模态窗口对你来说速度太慢，可以使用如下方法关闭此特性。</para>
<programlisting>&lt;client-config&gt;&#13;   &lt;disable-behind-modal&gt;false&lt;/disable-behind-modal&gt;&lt;!-- default: true --&gt;&#13;&lt;/client-config&gt;&#13;</programlisting>
<para>副作用是，用户或许会使用TAB 或shift-TAB 键移动要失效组件的聚焦。注意，不管此特性被打开或关闭，用户总是被阻止点击不属于模态窗口的任何组件。</para></sect1><sect1><title>使用ZK JSP标签或ZK JSF 组件代替ZK Filter</title>
<para>ZK filter实际上将每个HTML 标签映射到相应的XHTML组件。就像在前一章节描述的那样，由于ZK必须维护所有ZK组件的状态(包括XUL和XHTML 组件)，这比实际需求消耗了更多的内存。</para>
<para>引入ZK JSP标签是为了消除JSP 页面对于ZK filter的需要。使用ZK JSP标签，会为每个ZK JSP标签创建一个ZUL组件。所有的其它HTML标签都会被作为一个特殊组件被封装。</para>
<programlisting>&lt;!-- a JSP page --&gt;&#13;&lt;z:page&gt;&#13;   &lt;table&gt;&#13;      &lt;tr&gt;&#13;         &lt;td&gt;Name&lt;/td&gt;&#13;         &lt;td&gt;&lt;z:textbox/&gt;&lt;/td&gt;&#13;      &lt;/tr&gt;&#13;   &lt;/table&gt;&#13;&lt;/z:page&gt;&#13;</programlisting>
<para>若使用了ZUL页面，则等价于下面的代码片断，</para>
<programlisting>&lt;!-- a ZUL page --&gt;&#13;&lt;n:table xmlns:n="http://www.zkoss.org/2005/zk/native"&gt;&#13;   &lt;n:tr&gt;&#13;      &lt;n:td&gt;Name&lt;/n:td&gt;&#13;      &lt;n:td&gt;&lt;textbox/&gt;&lt;/n:td&gt;&#13;   &lt;/n:tr&gt;&#13;&lt;/n:table&gt;&#13;</programlisting></sect1></chapter>
<chapter>
<title>12. 其它设备和输出格式</title>
<para>除了Ajax浏览器，ZK也支持移动设备和XML输出。本章简要描述它们。对于细节信息，你可以参考相应文档。</para><sect1><title>ZK Mobile</title>
<para>ZK Mobile Computing 是ZK的扩展，可以使ZK应用程序扩展到移动设备，而只需少量的编程。</para>
<para>ZK Mobile Computing由两部分组成。在移动设备方面为ZK Mobile，一个JavaMe Midlet 瘦客户端，与ZK服务器互动，且作为客户端方面的用户界面工作。在服务器端方面为一套MIL (移动交互式语言，Mobile Interactive Language)组件，使用它们你可以控制操作何时结束来自于移动设备的用户触发行为。</para>
<para>开发ZK Mobile应用程序是很直接的。只需下载ZK Mobile发行版(release)，且跟随the ZK Mobile Quick Start Guide，你就可以准备开始了。</para><sect2><title>Mobile组件集， <ulink url="http://www.zkoss.org/2007/mil">http://www.zkoss.org/2007/mil</ulink>
</title>
<para>
<graphic fileref="img/12-1.png" align="center"/>你可以像处理ZUL和ZHTML组件那样编写你的ZK应用程序。这次不同的仅是你需要使用MIL组件。如下面这个标准的Hello World程序(hello.mil)。</para>
<programlisting>&lt;frame title="My First Window" visible="true"&gt;&#13;   Hello World!&#13;&lt;/frame&gt;&#13;</programlisting>
<para>这几乎和ZUL的"Hello World"例子一样。<code>&lt;frame&gt;</code>标签表示mobile展示的框架，且"Hello World!"为框架内的文本。</para>
<para>你可以将在ZUL组件方面的编程经验应用到MIL组件，不会有问题。仅有的不同是前者(ZUL组件)是为在web Ajax浏览器上显示而设计的，而后者(MIL组件)是为在ZK Mobile客户端显示设计的。你仍然可以使用ZK的模版属性，例如<code>if， unless，orEach，each</code>，等等。你可以在<code>&lt;zscript&gt;</code>标签内使用多种脚本语言。你可以使用EL表达式和注释的数据绑定。你也可以选择使用ZUML页面编写代码或纯的Java Richlet方法编写代码。</para>
<para>总之，你可能不仅是编写一个"纯的"ZK Mobile应用程序。而是，你或许要使用桌面web浏览器视图和移动设备视图。为不同的客户端编写不同的视图是很平常的，而所有的视图仍然共享相同的后台业务逻辑和数据库模型。</para></sect2></sect1><sect1><title>XML输出</title>
<para>如今XML 已经成为许多设备和协议的标准格式，如RSS和SVG。使用ZK输出XML 是很直接的。</para><sect2><title>使用ZUML页面输出产生XML 输出的三步</title>
<orderedlist>
<listitem>
<para>使用XML组件集(<ulink url="http://www.zkoss.org/2007/xml">
<code>http://www.zkoss.org/2007/xml</code>
</ulink>)。</para>
</listitem>
<listitem>
<para>将文件扩展映射到ZK加载器。</para>
</listitem>
<listitem>
<para>将文件扩展映射到XML组件集。</para>
</listitem>
</orderedlist><sect3><title>使用XML组件集， <code>http://www.zkoss.org/2007/xml</code>
</title>
<para>XML组件集(亦=XML语言，在ZK术语中)被用于产生XML输出。不同于XUL或XHTML组件集，所有在ZUML页面内未知的<footnote>
<para>说到未知标签，我们指未与命名空间相关联，或命名空间未知。</para>
</footnote> 标签都被假定属于本地命名空间(<code>http://www.zkoss.org/2005/native</code>)，而不是抛出一个异常。ZK会直接产生它们并输出，而不会为它们创建ZK组件。</para>
<para>下面为一个产生SVG输出的例子。这看起来和你想产生的XML输出非常相似，除了你可以使用EL表达式，宏组件和其它ZK特性。</para>
<programlisting>&lt;?page contentType="image/svg+xml;charset=UTF-8"?&gt;&#13;&#13;&lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&#13;   xmlns:z="http://www.zkoss.org/2005/zk"&gt;&#13;   &lt;z:zscript&gt;&lt;![CDATA[&#13;   String[] bgnds = {"purple", "blue", "yellow"};&#13;   int[] rads = {30, 25, 20};&#13;   ]]&gt;&lt;/z:zscript&gt;&#13;   &lt;circle style="fill:${each}" z:forEach="${bgnds}"&#13;<inlinegraphic fileref="img/12-2.png" align="right"/>      cx="${50+rads[forEachStatus.index]}"&#13;      cy="${20+rads[forEachStatus.index]}"&#13;      r="${rads[forEachStatus.index]}"/&gt;&#13;&lt;/svg&gt; &#13;</programlisting>

<para>产生的输出将会为</para>
<programlisting>&lt;svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" version="1.1"&gt;&#13;&lt;circle style="fill:purple" cx="80" cy="50" r="30"&gt;&#13;&lt;/circle&gt;&#13;&lt;circle style="fill:blue" cx="75" cy="45" r="25"&gt;&#13;&lt;/circle&gt;&#13;&lt;circle style="fill:yellow" cx="70" cy="40" r="20"&gt;&#13;&lt;/circle&gt;&#13;&lt;/svg&gt;&#13;</programlisting>
<para>此处</para>
<itemizedlist>
<listitem>
<para>内容类型(content type)由<code>page</code>指令指定。对于 SVG，为<code>image/svg+xml</code>。输出的<code>xml</code>处理指令(&lt;?xml?&gt;)和<code>DOCTYPE</code>也是由<code>page</code>指令指定的。更多关于<code>page</code>指令的信息请参考Developer's Reference。　</para>
</listitem>
<listitem>
<para>此例中所有的标签，例如<code>svg</code>和<code>circle</code>，都与命名空间(<ulink url="http://www.w3.org/2000/svg)关联">
<code>http://www.w3.org/2000/svg</code>
</ulink>
<ulink url="http://www.w3.org/2000/svg)关联">)关联</ulink>，而ZK加载器并不知道此命名空间。因此，它们被假定属于本地命名空间。它们会被直接输出，而不会为它们创建ZK组件。关于更多关于本地命名空间的信息请参考ZUML及XUL组件集一章中关于本地命名空间的部分。　</para>
</listitem>
<listitem>
<para>为使用<code>zscript</code>，<code>forEach</code>和其它ZK特性，你必须要指定ZK命名空间(<ulink url="http://www.zkoss.org/2005/zk">
<code>http://www.zkoss.org/2005/zk</code>
</ulink>)。</para>
</listitem>
</itemizedlist></sect3><sect3><title>将文件扩展映射到ZK加载器</title>
<para>为让ZK加载器处理文件，你需要在<code>WEB-INF/web.xml</code>内将其与ZK加载器相关联。在此例中，我们将所有的<code>.svg</code>扩展文件映射到ZK加载器<footnote>
<para>我们假定ZK加载器(zkLoader) 被映射到org.zkoss.zk.ui.http.DHtmlLayoutServlet。</para>
</footnote>：　</para>
<programlisting>&lt;servlet-mapping&gt;&#13;  &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;  &lt;url-pattern&gt;*.svg&lt;/url-pattern&gt;&#13;&lt;/servlet-mapping&gt;&#13;</programlisting></sect3><sect3><title>将文件扩展映射到XML组件集</title>
<para>除非文件扩展名为<code>.xml</code>，否则你必须在<code>WEB-INF/zk.xml</code>内明确的将其与XML组件集(亦＝XML语言)相关联。在这个例子中，我们将<code>.svg</code>映射到XML组件集：</para>
<programlisting>&lt;language-mapping&gt;&#13;   &lt;language-name&gt;xml&lt;/language-name&gt;&#13;   &lt;extension&gt;svg&lt;/extension&gt;&#13;&lt;/language-mapping&gt;&#13;</programlisting>
<para>此处，<code>xml</code>为XML组件集(<ulink url="http://www.zkoss.org/2007/xml">
<code>http://www.zkoss.org/2007/xml</code>
</ulink>)的名称。因此，当ZK加载器解析一个<code>.svg</code>文件时，它就知道了默认的语言为XML组件集。</para></sect3></sect2><sect2><title>XML组件集</title>
<para>除了直接产生XML标签并输出，XML组件集提供了几个组件用以简化复杂的任务，如XSLT。</para><sect3><title>The XML Transformer</title>
<para>为将一个XML 文件翻译为另外一个，你可以使用<code>transformer</code>组件，如下。</para>
<programlisting>&lt;?page contentType="text/html;charset=UTF-8"?&gt;&#13;&lt;x:transformer xsl="book.xsl" xmlns:x="http://www.zkoss.org/2007/xml"&gt;&#13;   &lt;book&gt;&#13;      &lt;title&gt;ZK - Ajax without the JavaScript Framework&lt;/title&gt;&#13;      &lt;for-who&gt;Web application designers and programmers who wish to implement&#13; rich Ajax web applications in the simplest way.&lt;/for-who&gt;&#13;      &lt;author&gt;Henri Chen and Robbie Cheng&lt;/author&gt;&#13;   &lt;/book&gt;&#13;&lt;/x:transformer&gt;&#13;</programlisting>
<para>此处， transformer 为XML组件集的一个组件，所以我们必须要指定命名空间。否则假定为本地命名空间。</para>
<para>那么，让我们假定<code>book.xsl</code>的内容如下。</para>
<programlisting>&lt;xsl:stylesheet version="1.0"&#13;xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;&#13;   &lt;xsl:template match="/"&gt;&#13;      &lt;html&gt;&#13;         &lt;head&gt;&#13;            &lt;title&gt;Book Info&lt;/title&gt;&#13;         &lt;/head&gt;&#13;         &lt;body&gt;&#13;            &lt;h1&gt;Book Info&lt;/h1&gt;&#13;            &lt;xsl:apply-templates select="book"/&gt;&#13;         &lt;/body&gt;&#13;      &lt;/html&gt;&#13;   &lt;/xsl:template&gt;&#13;   &lt;xsl:template match="book"&gt;&#13;      &lt;dl&gt;&#13;         &lt;dt&gt;Title:&lt;/dt&gt;&#13;         &lt;dd&gt;&lt;xsl:value-of select="title"/&gt;&lt;/dd&gt;&#13;         &lt;dt&gt;Who is this book for:&lt;/dt&gt;&#13;         &lt;dd&gt;&lt;xsl:value-of select="for-who"/&gt;&lt;/dd&gt;&#13;         &lt;dt&gt;Authors&lt;/dt&gt;&#13;         &lt;dd&gt;&lt;xsl:value-of select="author"/&gt;&lt;/dd&gt;&#13;      &lt;/dl&gt;&#13;   &lt;/xsl:template&gt;&#13;&lt;/xsl:stylesheet&gt;&#13;</programlisting>
<para>那么，产生的XML 输出将会为XHTML ，如下。</para>
<programlisting>&lt;html&gt;&#13;&lt;head&gt;&#13;&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&#13;&lt;title&gt;Book Info&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;&lt;h1&gt;Book Info&lt;/h1&gt;&#13;&lt;dl&gt;&#13;&#13;&lt;dt&gt;Title:&lt;/dt&gt;&#13;&lt;dd&gt;&#13;ZK - Ajax without the JavaScript Framework&lt;/dd&gt;&#13;&lt;dt&gt;Who is this book for:&lt;/dt&gt;&#13;&lt;dd&gt;&#13;Web application designers and programmers who wish to implement rich Ajax web applications in the simplest way.&lt;/dd&gt;&#13;&lt;dt&gt;Authors&lt;/dt&gt;&#13;&lt;dd&gt;&#13;Henri Chen and Robbie Cheng&lt;/dd&gt;&#13;&lt;/dl&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para/></sect3></sect2></sect1></chapter>
<chapter>
<title>13. 国际化</title>
<para>本章描述了如何使ZK应用程序足够简单的运行在任何地域。</para>
<para>首先，ZK允许开发人员以任何喜欢的方式嵌入Java代码或EL表达式。你可以使用国际化方法，例如<code>java.util.ResourceBundle</code>。</para>
<para>但是，ZK对于国际化有一些内置的支持，你或许会发现它们很有用。</para><sect1><title>地域</title>
<para>地域用于处理请求和事件，默认情况下，由浏览器的首选项(通过使用<code>javax.servlet.ServletRequest</code>的<code>getLocale</code>方法)决定。</para>
<para>但是，这是可以配置的。例如，你或许想为所有的用户使用相同的地域，而不管浏览器是如何配置的。另一个例子，若在服务器端维护用户的profiles，你或许想使用用户在他或她的profile内指定的首选地域。</para><sect2><title>
<code>px_preferred_locale</code>会话属性</title>
<para>在检查浏览器的首选项之前，ZK会首先检查是否定义了一个名为<code>px_preferred_locale</code>的会话属性。若定义了，ZK会使用它作为会话默认的地域，同时代替浏览器的首选项。因此，通过为此属性中的首选 locale排序，你可以控制一个会话的地域。</para>
<para>例如，当用户登录时你可以这样做。</para>
<programlisting>void login(String username, String password) {&#13;   //check password&#13;   ...&#13;   Locale preferredLocale = ...; //decide the locale (from, say, database)&#13;   session.setAttribute("px_preferred_locale", preferredLocale);&#13;   ...&#13;}&#13;</programlisting>
<para>[提示]：为避免typo，你饿可以使用定义在<code>org.zkoss.web.Attributes</code>类内的<code>PREFERRED_LOCALE</code>常量。 </para></sect2><sect2><title>请求拦截器</title>
<para>在用户登录之后才决定地域，对于一些应用程序已经有些晚了。例如，在用户登录之前，你或许想使用与前一个会话相同的地域。对于一个Web应用程序，这通常由cookies处理。使用ZK，你可以注册一个请求拦截器，并且当拦截器被调用时维护cookies。</para>
<para>请求拦截器被用于拦截由ZK加载器和ZK更新引擎处理的每个请求。它必须实现<code>org.zkoss.zk.ui.util.RequestInterceptor</code>接口。例如，</para>
<programlisting>public class MyLocaleProvider implements org.zkoss.zk.ui.util.RequestInterceptor {&#13;   public void request(org.zkoss.zk.ui.Session sess,&#13;   Object request, Object response) {&#13;      final Cookie[] cookies = ((HttpServletRequest)request).getCookies();&#13;      if (cookies != null) {&#13;         for (int j = cookies.length; --j &gt;= 0;) {&#13;            if (cookies[j].getName().equals("my.locale")) {&#13;               //determine the locale&#13;               String val = cookies[j].getValue();&#13;               Locale locale = org.zkoss.util.Locales.getLocale(val);&#13;               sess.setAttribute(Attributes.PREFERRED_LOCALE, locale);&#13;               return;&#13;            }&#13;         }&#13;      }&#13;   }&#13;}&#13;</programlisting>
<para>为使其生效，你必须按如下方式在<code>WEB-INF/zk.xml</code>内进行注册。一旦注册，每次ZK加载器或ZK更新引擎接收一个请求时都会调用<code>request</code>方法。关于配置的详细信息，请参考the Developer's Reference的附录B(Appendix B)。</para>
<programlisting>&lt;listener&gt;&#13;   &lt;listener-class&gt;MyLocaleProvider&lt;/listener-class&gt;&#13;&lt;/listener&gt;&#13;</programlisting>
<para>[注]：当注册时，一个拦截器的实例会被初始化。然后，相同应用程序内的所有请求会共享此拦截器。因此，你必须确保拦截器可以被同时访问(也就是说，线程安全)。 </para>
<para>[注]：<code>request</code>方法会在很早的阶段被调用，在请求参数被解析之前。因此，推荐在此方法中访问它们，除非你为请求合适的配置了地域和字符编码。</para></sect2></sect1><sect1><title>时区</title>
<para>用于处理请求和事件，默认情况下，由Java 虚拟机(JVM)的首选项(<code>java.util.TimeZone</code>的<code>getDefault</code>方法)决定。</para>
<para>[注]： 不同于地域 ，没有标准的方法为每种浏览器决定时区。</para>
<para>就像地域，一个给定会话的时区是可以配置的。例如，若在服务器端维护用户的profiles，你或许想使用用户在他或她的profile内指定的首选时区。</para><sect2><title>
<code>px_preferred_time_zone</code> 会话属性</title>
<para>ZK会检查是否定义了一个名为<code>px_preferred_time_zone</code>的会话属性。若定义了，ZK会使用它作为会话默认的时区，同时代替系统默认选项。因此，通过为此属性中的首选地域排序，你可以控制一个会话的时区，之后，例如，在前一章节中描述的用户登录。</para>
<para>[提示]： 为避免typo，你可以使用<code>org.zkoss.web.Attributes</code>类内定义的<code>PREFERRED_TIME_ZONE</code>常量。</para></sect2><sect2><title>请求拦截器</title>
<para>就像地域，你可以使用请求拦截器的<code>px_preferred_time_zone</code>属性为给定的会话准备时区。</para></sect2></sect1><sect1><title>标签</title>
<para>开发人员可以将本地数据从ZUML页面(和JSP页面)分离出来，只需将它们在<code>WEB-INF</code>目录下的i3-label_lang_CNTY.properties内排序。此处lang为一种语言，如en和fr ，CNTY 为国家，如 US 和 FR 。</para>
<para>为获得本地属性，你可以在Java中使用<code>org.zkoss.util.resource.Labels</code>，或在EL表达式中使用<code>${c:l('key')}</code>。为了在EL中使用它，你可以按如下方式包含TLD文件。</para>
<programlisting>&lt;%@ taglib uri="http://www.zkoss.org/dsp/web/core" prefix="c" %&gt;&#13;&#13;&lt;window title="${c:l('app.title')}"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>[文件位置]: <code>cor</code>
<code>e.dsp.tld </code>文件位于 <code>dist/WEB-INF</code> 目录。 你不需要将它复制到你的Web应用程序中。 </para>
<para>当将要获得一个本地标签时， i3-label_lang_CNTY.properties中的一个文件会被加载。例如，若地域 为<code>de_DE</code>，那么<code>WEB-INF/i3-label_de_DE.properties</code>将会被加载。若没用这个文件，ZK将会尝试加载<code>WEB-INF/i3-label_de.properties</code> 和<code>WEB-INF/i3-label.properties</code>并返回。</para>
<para>为了在Java代码(包括zscript )中访问到标签，可以使用<code>org.zkoss.util.resource.Labels</code>类的<code>getLabel</code>方法。</para>
<para>此外，你可以继承标签加载器，以从别的位置，例如数据库，加载标签，需要注册一个实现了<code>org.zkoss.util.resource.LabelLocator</code>接口的 locator。</para></sect1><sect1><title>本地文件</title><sect2><title>浏览器和本地URI</title>
<para>许多资源依赖于地域，有时依赖于用户用于访问Web页面的浏览器。例如，你需要为汉字显示大字体，以获得更好的可读性。</para>
<para>若你使用"*"指定了样式表的URL，ZK可以为你自动处理这些。算法如下。</para>
<orderedlist>
<listitem>
<para>若在一个URI内指定了"*"，例如<code>/my*.css</code>，那么"*"将会被一个合适的地域代替，在浏览器的首选项内指定。 </para>
<para>例如，用户的首选项为<code>de_DE</code>，那么ZK将会从你的Web站点依次查找<code>/my_de_DE.css</code>， <code>/my_de.css</code>，和<code> /my.css</code>，直到任一个被找到。若没有找到，则仍然使用<code>/my.css</code>。</para>
</listitem>
<listitem>
<para>若在一个URI 内指定了两个或更多的"*"，例如<code>"/my*/lang*.css"</code>，那么首个"*"，对于IE会被"<code>ie</code>"代替，Safari为"<code>saf</code>"，而其它浏览器<footnote>
<para>在未来的版本中，除了Internet Explorer， Firefox 和 Safari，我们将为浏览器使用不同的代码。 </para>
</footnote>为"<code>moz</code>" 。此外，最后一个星号(asterisk)会被一个合适的地域 代替，就像上一布描述的那样。综上所述，最后一个星号表示地域，而第一个星号表示浏览器类型。</para>
</listitem>
<listitem>
<para>所有其它的 "*" 会被忽略。</para>
</listitem>
</orderedlist>
<para>[注]： 表示地域的最后那个星号必须被放置于首个点(".")之前且中间无任何字符，或若没有点则置于最后。另外，下列的斜杠是不允许的(no following slash (/) is allowed)，也就是说，它必须为文件名，而不是目录。若最后一个星号不满足此约束，它就会被除去而不是忽略。例如，"/my/lang.css*"等价于"/my/lang.css"。换言之，你可以认为它是中立于地域的(you can consider it as neutral to the Locale)。</para>
<para>[提示]： 我们可以将此规则应用于指定一个依赖于浏览器类型的 URI，而不是依赖于地域。例如，若用户使用的为IE，则"/my/langie.css"会代替"/my/lang*.css*"。</para>
<para/>
<para>在下面的例子中，我们假定选中的地域为<code>de_DE</code>，且浏览器为IE。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>URI</para>
</entry>
<entry>
<para>被搜索的资源</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>/css/norm*.css</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/norm_de_DE.css</para>
</listitem>
<listitem>
<para>/norm_de.css</para>
</listitem>
<listitem>
<para>/norm.css</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>/css-*/norm*.css</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/css-ie/norm_de_DE.css</para>
</listitem>
<listitem>
<para>/css-ie/norm_de.css</para>
</listitem>
<listitem>
<para>/css-ie/norm.css</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>/img*/pic*/lang*.png</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/imgie/pic*/lang_de_DE.png</para>
</listitem>
<listitem>
<para>/imgie/pic*/lang_de.png</para>
</listitem>
<listitem>
<para>/imgie/pic*/lang.png</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>/img*/lang.gif</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/img/lang.gif</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>/img/lang*.gif*</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/img/langie.gif</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>/img*/lang*.gif*</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>/imgie/lang*.gif</para>
</listitem>
</orderedlist>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>在Java中定位浏览器与本地资源</title>
<para>除了组件属性和ZUML属性，你可以使用Java编程来处理浏览器和本地资源。这里为你可以使用的方法列表。</para>
<itemizedlist>
<listitem>
<para>
<code>org.zkoss.zk.ui.Exection</code> 中的<code>enc</code>
<code>odeURL</code>
<code>，</code>
<code>forward</code>和<code>include</code>方法，分别用于编码URL，转向另一个页面，及包含一个页面。在大多数情况下，这些方法可以满足你的需求。</para>
</listitem>
<listitem>
<para>
<code>org.zkoss.web.servlet.Servlets</code> 中的<code>locate</code>
<code>，</code>
<code>forward</code>,和<code>include</code>方法，用于定位Web资源。当开发ZK应用程序时，你很少需要它们，但是对于编写servlet，portlet 或 filter 是很有用的。</para>
</listitem>
<listitem>
<para>
<code>org.zkoss.web.servlet.http.Encodes</code> 中 <code>encodeURL</code> 的方法，用于编码URL。当开发ZK应用程序时，你很少需要它们，但是对于编写servlet，portlet 或 filter 是很有用的 。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>org.zkoss.util.resource.Locators</code> 中的<code>locate</code>方法，用于定位类资源。</para>
</listitem>
</itemizedlist></sect2></sect1><sect1><title>消息</title>
<para>消息被存储于properties 文件，位于类路径的<code>/metainfo/mesg</code>目录。每一个单元对应一个唯一的名字。地域也被添加到了property 文件。例如，<code>zk.jar</code>
<code>中</code>
<code>Germany</code>
<code>的</code>消息文件为<code>msgzk_de_DN.properties</code>或<code>msgzk_de.properties</code>。目前，<code>zk.jar</code>仅能使用English 和Chinese 版本。你可以为不同的地添加你自己的property 文件，并将它们置于类路径的<code>/metainfo/mesg</code>目录。</para></sect1><sect1><title>汉字和大号字体</title>
<para>XUL组件集为每种浏览器类型提供了两套样式表。一种为小字体，而另一种为大字体。例如，<code>normie.css.dsp</code>和<code>normie_zh.css.dsp</code>是为IE浏览器准备的两套的样式表，分别对应小字体和大字体。</para>
<para>默认情况下，仅会使用小字体文件，如<code>normie.css.dsp</code>
<footnote>
<para>2.3以前的发行版，ZK为汉字使用大字体，而对于剩下的地区使用小字体。</para>
</footnote>。但是，你可以在<code>WEB-INF/zk.xml</code>内进行配置，以指定大字体，如下：</para>
<programlisting>&lt;zk&gt;&#13;   &lt;desktop-config&gt;&#13;      &lt;disable-default-theme&gt;xul/html&lt;/disable-default-theme&gt;&#13;      &lt;theme-uri&gt;~./zul/css/norm*_zh.css.dsp*&lt;/theme-uri&gt;&#13;   &lt;/desktop-config&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>若你想为汉字显示大字体，而剩下的使用小字体，你可以按如下方式指定：</para>
<programlisting>&lt;zk&gt;&#13;   &lt;desktop-config&gt;&#13;      &lt;disable-default-theme&gt;xul/html&lt;/disable-default-theme&gt;&#13;      &lt;theme-uri&gt;~./zul/css/norm**.css.dsp&lt;/theme-uri&gt;&#13;   &lt;/desktop-config&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>关于更多如何配置<code>WEB-INF/zk.xml</code>的信息，请参考Developer's Reference。</para></sect1></chapter>
<chapter>
<title>14. 数据库连接</title>
<para>本章将要讲述如何连接数据库。</para><sect1><title>ZK仅为表现层</title>
<para>ZK的目的是像表现层一样瘦。此外，使用中心服务器(server-centric)技术，ZK在服务器端运行所有代码，所以，连接数据库和任何桌面应用程序没有区别。换言之，ZK并不改变你访问数据库的方式，不管你使用JDBC或其它持久层框架，例如Hibernate<footnote>
<para>
<ulink url="http://www.hibernate.org/">http://www.hibernate.org</ulink>
</para>
</footnote>。</para></sect1><sect1><title>使用JDBC的简单方式 (但不推荐)</title>
<para>最简单的方式是使用JDBC，就像任何JDBC教程描述的那样，使用<code>java.sql.DriverManager</code>。这里有一个例子，将姓名和电子邮件存入MySQL<footnote>
<para>
<ulink url="http://www.mysql.com/">http://www.mysql.com</ulink>
</para>
</footnote>数据库。</para>
<programlisting>&lt;window title="JDBC demo" border="normal"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   import java.sql.*;&#13;   void submit() {&#13;      //load driver and get a database connetion&#13;      Class.forName("com.mysql.jdbc.Driver");&#13;      Connection conn = DriverManager.getConnection(&#13;         "jdbc:mysql://localhost/test?user=root&amp;password=my-password");&#13;      PreparedStatement stmt = null;&#13;      try {&#13;         stmt = conn.prepareStatement("INSERT INTO user values(?, ?)");&#13;&#13;         //insert what end user entered into database table&#13;         stmt.set(1, name.value);&#13;         stmt.set(2, email.value);&#13;&#13;         //execute the statement&#13;         stmt.executeUpdate();&#13;      } finally { //cleanup&#13;         if (stmt != null) {&#13;            try {&#13;               stmt.close();&#13;            } catch (SQLException ex) {&#13;               log.error(ex); //log and ignore&#13;            }&#13;         }&#13;         if (conn != null) {&#13;            try {&#13;               conn.close();&#13;            } catch (SQLException ex) {&#13;               log.error(ex); //log and ignore&#13;            }&#13;         }&#13;      }&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;vbox&gt;&#13;      &lt;hbox&gt;Name : &lt;textbox id="name"/&gt;&lt;/hbox&gt;&#13;      &lt;hbox&gt;Email: &lt;textbox id="email"/&gt;&lt;/hbox&gt;&#13;      &lt;button label="submit" onClick="submit()"/&gt;&#13;      &lt;/vbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>尽管简单，但并不推荐这样做。毕竟ZK应用程序是基于Web的，加载是难以预测且宝贵的资源，例如数据库连接，必须要有效的管理。</para>
<para>很幸运，所有的J2EE框架和Web服务器都支持一种称为连接池的功能。很容易使用连接池，且用于管理数据库连接更好。在下一章节我们会讨论更多。</para>
<para>[提示]： 不同与其它Web应程序，可以和ZK使用<code>DriverManager</code>，尽管不推荐这样做。 首先，你需要在桌面缓存连接，为每一个事件重复使用此连接，当桌面失效时关闭连接。就像传统的客户端/服务器应用程序一样工作。 就像客户端/服务器应用程序，这样会有效的运作，仅当最多有数十个并发用户时。为了得知桌面何时失效，你需要通过<code>org.zkoss.zk.ui.util.DesktopCleanup </code>实现一个监听器。</para></sect1><sect1><title>使用连接池</title>
<para>连接池是一种创建和管理多个连接的技术，这些连接是为任何需要它们的线程准备的。连接池不会马上关闭连接，而是将连接保存在一个pool中，这样可以很高效地服务下一个连接。除此之外，连接池还有很多好处，例如，控制资源的使用。</para>
<para>当开发基于Web的应用程序时，没有理由不使用连接池，包括ZK应用程序。</para>
<para>连接池的概念很简单：配置，连接及关闭。打开和关闭一个连接与点对点(ad-hoc )方法很相似，而配置依赖于使用的Web服务器和数据库。</para><sect2><title>打开及关闭一个连接</title>
<para>配置好连接池(将会在下面的章节讨论)之后，你可以使用JNDI 获取一个连接，如下。</para>
<programlisting>import java.sql.Connection;&#13;import java.sql.SQLException;&#13;import java.sql.Statement;&#13;&#13;import javax.naming.InitialContext;&#13;import javax.sql.DataSource;&#13;&#13;import org.zkoss.zul.Window;&#13;&#13;public class MyWindows extends Window {&#13;   private Textbox name, email;&#13;   public void onCreate() {&#13;      //initial name and email&#13;      name = getFellow("name");&#13;      email = getFellow("email");&#13;   }&#13;   public void onOK() throws Exception {&#13;      DataSource ds = (DataSource)new InitialContext()&#13;            .lookup("java:comp/env/jdbc/MyDB");&#13;         //Assumes your database is configured and&#13;         //named as "java:comp/env/jdbc/MyDB"&#13;&#13;      Connection conn = null;&#13;      Statement stmt = null;&#13;      try {&#13;         conn = ds.getConnection();&#13;         stmt = conn.prepareStatement("INSERT INTO user values(?, ?)");&#13;&#13;         //insert what end user entered into database table&#13;         stmt.set(1, name.value);&#13;         stmt.set(2, email.value);&#13;&#13;         //execute the statement&#13;         stmt.executeUpdate();&#13;         stmt.close(); stmt = null;&#13;            //optional because the finally clause will close it&#13;            //However, it is a good habit to close it as soon as done, especially &#13;            //you might have to create a lot of statement to complete a job&#13;      } finally { //cleanup&#13;         if (stmt != null) {&#13;            try {&#13;               stmt.close();&#13;            } catch (SQLException ex) {&#13;               //(optional log and) ignore&#13;            }&#13;         }&#13;         if (conn != null) {&#13;            try {&#13;               conn.close();&#13;            } catch (SQLException ex) {&#13;               //(optional log and) ignore&#13;            }&#13;         }&#13;      }&#13;   }&#13;}&#13;</programlisting>
<para>[注]:</para>
<orderedlist>
<listitem>
<para>使用之后关闭语句和连接是很重要的。</para>
</listitem>
<listitem>
<para>使用多个连接，你可以同时访问多个数据库。依赖于配置和J2EE/Web服务器，这些连接甚至可以形成一个分布式事务处理。 </para>
</listitem>
</orderedlist></sect2><sect2><title>配置连接池</title>
<para>连接池的配置随J2EE/Web/数据库服务器的不同而不同。这里我们说明其中一些的配置。你需要参考你使用的服务器的文档。</para><sect3><title>Tomcat 5.5 + MySQL</title>
<para>为配置Tomcat 5.5配置连接池，你必须编辑<code>$TOMCAT_DIR/conf/context.xml</code>
<footnote>
<para>多谢 Thomas Muller (<ulink url="http://asconet.org:8000/antville/oberinspector">http://asconet.org:8000/antville/oberinspector</ulink>) 更正。</para>
<para>
细节见
<ulink url="http://tomcat.apache.org/tomcat-5.5-doc/jndi-resources-howto.html">http://tomcat.apache.org/tomcat-5.5-doc/jndi-resources-howto.html</ulink> 和 <ulink url="http://en.wikibooks.org/wiki/ZK/How-Tos/HowToHandleHibernateSessions#Working_with_the_Hibernate_session">http://en.wikibooks.org/wiki/ZK/How-Tos/HowToHandleHibernateSessions#Working_with_the_Hibernate_session</ulink>
。
</para>
</footnote>,，在<code>&lt;Context&gt;</code>元素的下添加下面的内容。标记为蓝色的的信息依赖于你的安装，且通常需要修改。</para>
<programlisting>&lt;!-- The name you used above, must match _exactly_ here!&#13;   The connection pool will be bound into JNDI with the name&#13;   "java:/comp/env/jdbc/MyDB"&#13;--&gt;&#13;&lt;Resource name="jdbc/MyDB" username="someuser" password="somepass" &#13;   url="jdbc:mysql://localhost:3306/test" &#13;   auth="Container" defaultAutoCommit="false" &#13;   driverClassName="com.mysql.jdbc.Driver" maxActive="20" &#13;   timeBetweenEvictionRunsMillis="60000" &#13;   type="javax.sql.DataSource" /&gt;&#13;&lt;/ResourceParams&gt;&#13;</programlisting>
<para>然后在<code>web.xml</code>内，你需要在<code>&lt;web-app&gt;</code>元素下添加下面的内容。</para>
<programlisting>&lt;resource-ref&gt;&#13;  &lt;res-ref-name&gt;jdbc/MyDB&lt;/res-ref-name&gt;&#13;  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;&#13;  &lt;res-auth&gt;Container&lt;/res-auth&gt;&#13;&lt;/resource-ref&gt;&#13;</programlisting></sect3><sect3><title>JBoss + MySQL</title>
<para>下列的指令基于MySQL 5.0 参考手册的23.3.4.3 章节。</para>
<para>为JBoss配置连接池，你必须在deploy (<code>$JBOSS_DIR/server/default/deploy</code>)目录下添加一个新文件。文件名要以"<code>-ds.xml</code>"结尾，即告诉JBoss将此文件部署为JDBC数据源。文件必须包含下列内容。标记为蓝色的的信息依赖于你的安装，且通常需要修改。</para>
<programlisting>&lt;datasources&gt;&#13;    &lt;local-tx-datasource&gt;&#13;        &lt;!-- This connection pool will be bound into JNDI with the name&#13;             "java:/MyDB" --&gt;&#13;        &lt;jndi-name&gt;MyDB&lt;/jndi-name&gt;&#13;        &lt;connection-url&gt;jdbc:mysql://localhost:3306/test&lt;/connection-url&gt;&#13;        &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;&#13;        &lt;user-name&gt;someser&lt;/user-name&gt;&#13;        &lt;password&gt;somepass&lt;/password&gt;&#13;&#13;        &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;&#13;&#13;        &lt;!-- Don't set this any higher than max_connections on your&#13;         MySQL server, usually this should be a 10 or a few 10's&#13;         of connections, not hundreds or thousands --&gt;&#13;&#13;        &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;&#13;&#13;        &lt;!-- Don't allow connections to hang out idle too long,&#13;         never longer than what wait_timeout is set to on the&#13;         server...A few minutes is usually okay here,&#13;         it depends on your application&#13;         and how much spikey load it will see --&gt;&#13;&#13;        &lt;idle-timeout-minutes&gt;5&lt;/idle-timeout-minutes&gt;&#13;&#13;        &lt;!-- If you're using Connector/J 3.1.8 or newer, you can use&#13;             our implementation of these to increase the robustness&#13;             of the connection pool. --&gt;&#13;&#13;        &lt;exception-sorter-class-name&gt;com.mysql.jdbc.integration.jboss.&#13; ExtendedMysqlExceptionSorter&lt;/exception-sorter-class-name&gt;&#13;        &lt;valid-connection-checker-class-name&gt;com.mysql.jdbc.integration.jboss.&#13; MysqlValidConnectionChecker&lt;/valid-connection-checker-class-name&gt;&#13;&#13;    &lt;/local-tx-datasource&gt;&#13;&lt;/datasources&gt;&#13;</programlisting></sect3><sect3><title>JBoss + PostgreSQL</title>
<programlisting>&lt;datasources&gt;&#13;   &lt;local-tx-datasource&gt;&#13;   &lt;!-- This connection pool will be bound into JNDI with the name&#13;        "java:/MyDB" --&gt;&#13;   &lt;jndi-name&gt;MyDB&lt;/jndi-name&gt;&#13;    &#13;   &lt;!-- jdbc:postgresql://[servername]:[port]/[database name] --&gt;&#13;   &lt;connection-url&gt;jdbc:postgresql://localhost/test&lt;/connection-url&gt;&#13;&#13;   &lt;driver-class&gt;org.postgresql.Driver&lt;/driver-class&gt;&#13;   &lt;user-name&gt;someuser&lt;/user-name&gt;&#13;   &lt;password&gt;somepass&lt;/password&gt;&#13;   &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;&#13;   &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;&#13;   &lt;track-statements&gt;false&lt;/track-statements&gt;&#13;   &lt;/local-tx-datasource&gt;&#13;&lt;/datasources&gt;&#13;</programlisting></sect3></sect2></sect1><sect1><title>易于使用数据库的ZK特性</title><sect2><title>
<code>org.zkoss</code>
<code>.zk.ui.event.EventThreadCleanup</code> 接口</title>
<para>就像以前强调过的，在<code>finally</code>子句中关闭连接是很重要的，这样每个连接都会被正确的返回连接池。</para>
<para>为使你的应用程序更有弹性，你可以实现<code>org.zkoss.zk.ui.event.EventThreadCleanup</code> 接口来关闭任何处在等待之际的连接和语句，以防你的一些应用程序代码忘记了在<code>finally</code>子句中关闭它们。</para>
<para>但是，关闭处在等待之际的连接和语句实际上依赖于你使用的服务器。你需要参考服务器的文档来得知如何编写关闭代码。</para>
<para>[提示]：在许多情况下，并不需要(且并不容易)提供这样的方法，因为多数连接池的实现可以循环一个连接若调用了连接池的<code>finalized</code>方法。 </para></sect2><sect2><title>在EL表达式中使用数据库</title>
<para>除了在事件监听器中访问数据库，用EL表达式使用数据库填充一个属性也是很常见的。在下面的例子中，我们从数据库取出数据，并使用EL表达式将它们用<code>listbox</code>展示出来。</para>
<programlisting>&lt;zscript&gt;&#13;   import my.CustomerManager;&#13;   customers = new CustomerManager().findAll(); //load from database&#13;&lt;/zscript&gt;&#13;&lt;listbox id="personList" width="800px" rows="5"&gt;&#13;   &lt;listhead&gt;&#13;      &lt;listheader label="Name"/&gt;&#13;      &lt;listheader label="Surname"/&gt;&#13;      &lt;listheader label="Due Amount"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem value="${each.id}" forEach="${customers}"&gt;&#13;      &lt;listcell label="${each.name}"/&gt;&#13;      &lt;listcell label="${each.surname}"/&gt;&#13;      &lt;listcell label="${each.due}"/&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>有几种方式来实现<code>findAll</code>方法。</para><sect3><title>读取所有数据并将其拷贝到链表(LinkedList)</title>
<para>最简单的方式是在<code>findAll</code>方法内获取所有的数据，将它们拷贝到一个列表，然后关闭连接。</para>
<programlisting>public class CustomerManager {&#13;   public List findAll() throws Exception {&#13;      DataSource ds = (DataSource)new InitialContext()&#13;            .lookup("java:comp/env/jdbc/MyDB");&#13;&#13;      Connection conn = null;&#13;      Statement stmt = null;&#13;      ResultSet rs = null;&#13;      List results = new LinkedList();&#13;      try {&#13;         conn = ds.getConnection();&#13;         stmt = conn.createStatement();&#13;         rs = stmt.executeQuery("SELECT id, name, surname FROM customers");&#13;         while (rs.next()) {&#13;            long id = rs.getInt("id");&#13;            String name = rs.getString("name");&#13;            String surname = rs.getString("surname");&#13;            results.add(new Customer(id, name, surname));&#13;         }&#13;         return results;&#13;      } finally {&#13;         if (rs != null) try { rs.close(); } catch (SQLException ex) [}&#13;         if (stmt != null) try { stmt.close(); } catch (SQLException ex) [}&#13;         if (conn != null) try { conn.close(); } catch (SQLException ex) [}&#13;      }&#13;   }&#13;}&#13;</programlisting></sect3><sect3><title>实现<code>org.zkoss.zk.ui.util.Initiator</code>接口</title>
<para>你可以使用<code>init</code>指令来加载数据，以代替在试图中混合使用Java代码。</para>
<programlisting>&lt;?init class="my.AllCustomerFinder" arg0="customers"?&gt;&#13;&#13;&lt;listbox id="personList" width="800px" rows="5"&gt;&#13;   &lt;listhead&gt;&#13;      &lt;listheader label="Name"/&gt;&#13;      &lt;listheader label="Surname"/&gt;&#13;      &lt;listheader label="Due Amount"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem value="${each.id}" forEach="${customers}"&gt;&#13;      &lt;listcell label="${each.name}"/&gt;&#13;      &lt;listcell label="${each.surname}"/&gt;&#13;      &lt;listcell label="${each.due}"/&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>然后，使用<code>org.zkoss.zk.ui.util.Initiator</code>接口实现<code>my.CustomerFindAll</code>类。</para>
<programlisting>import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class AllCustomerFinder implements Initiator {&#13;   public void doInit(Page page, Object[] args) {&#13;      try {&#13;         page.setVariable((String)args[0], new CustomerManager().findAll());&#13;            //Use setVariable to pass the result back to the page&#13;      } catch (Exception ex) {&#13;         throw UiException.Aide.wrap(ex);&#13;      }&#13;   }&#13;   public void doCatch(Throwable ex) { //ignore&#13;   }&#13;   public void doFinally() { //ignore&#13;   }&#13;}&#13;</programlisting></sect3></sect2><sect2><title>事务处理和<code>org.zkoss.zk.util.Initiator</code>
</title>
<para>度与复杂的应用程序(例如分布式事务处理)，你或许需要明确的控制一个事务处理的活动周期。若所有的数据库访问均是在事件监听器中被处理的，那么在ZK中为使其工作并不需要改变什么。你开始，提交或回滚(start， commit or rollback)一个事务处理，与你的J2EE/Web服务器文档建议的一样。</para>
<para>但是，若你想将整个ZUML页面(组件创建阶段)的赋值在相同的事务处理里被执行，如上一章节描述的那样，你可以实现<code>org.zkoss.zk.util.Initiator</code>接口控制给定页面的事务处理活动周期。</para>
<para>实现的框架如下所示。</para>
<programlisting>import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class TransInitiator implements Initiator {&#13;   private boolean _err;   public void doInit(Page page, Object[] args) {&#13;      startTrans(); //depending the container, see below&#13;   }&#13;   public void doCatch(Throwable ex) {&#13;      _err = true;&#13;      rollbackTrans(); //depending the container, see below&#13;   }   public void doFinally() {&#13;      if (!_err)&#13;         commitTrans(); //depending the container, see below&#13;   }&#13;}&#13;</programlisting>
<para>如上所示，事务处理在<code>doInit</code>方法内开始，且在<code>org.zkoss.zk.util.Initiator</code> 接口的<code>doFinally</code>方法内结束。</para>
<para>如何开始，提交和回滚一个事务处理取决于你使用的容器。</para><sect3><title>J2EE事务处理及<code>Initiator</code>
</title>
<para>若你使用的为一个J2EE容器，你可以找到事务管理器(<code>javax.transaction.TransactionManager</code>)，然后调用它的 <code>begin</code> 方法开始一个事务处理。调用<code>rollback</code>方法回滚。调用<code>commit</code> 方法提交。</para></sect3><sect3><title>Web 容器和<code>Initiator</code>
</title>
<para>若你使用的为一个没有事务管理器的Web容器，可以通过构造一个数据库连接来开始事务处理。然后，据此调用<code>commit</code>和<code>rollback</code>方法。</para>
<programlisting>import java.sql.*;&#13;import javax.sql.DataSource;&#13;import javax.naming.InitContext;&#13;import org.zkoss.util.logging.Log;&#13;import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class TransInitiator implements Initiator {&#13;   private static final Log log = Log.lookup(TransInitiator.class);&#13;   private Connection _conn;&#13;   private boolean _err;&#13;&#13;   public void doInit(Page page, Object[] args) {&#13;      try {&#13;         DataSource ds = (DataSource)new InitialContext()&#13;            .lookup("java:comp/env/jdbc/MyDB");&#13;         _conn = ds.getConnection();&#13;      } catch (Throwable ex) {&#13;         throw UiException.Aide.wrap(ex);&#13;      }&#13;   }&#13;   public void doCatch(Throwable t) {&#13;      if (_conn != null) {&#13;         try {&#13;            _err = true;&#13;            _conn.rollback();&#13;         } catch (SQLException ex) {&#13;            log.warning("Unable to roll back", ex);&#13;         }&#13;      }&#13;   }&#13;   public void doFinally() {&#13;      if (_conn != null) {&#13;         try {&#13;            if (!_err)&#13;               _conn.commit();&#13;         } catch (SQLException ex) {&#13;            log.warning("Failed to commit", ex);&#13;         } finally {&#13;            try {&#13;               _conn.close();&#13;            } catch (SQLException ex) {&#13;               log.warning("Unable to close transaction", ex);&#13;            }&#13;         }&#13;      }&#13;   }&#13;}&#13;</programlisting></sect3></sect2></sect1></chapter>
<chapter>
<title>15. Portal 整合</title>
<para>ZK提供了一个portlet来为JSR 168 compliant portal加载ZUML页面。这个portlet被称为ZK portlet 加载器，它就像<code>org.zkoss.zk.ui.http.DHtmlLayoutPortlet</code>一样被实现。</para><sect1><title>配置</title><sect2><title>WEB-INF/portlet.xml</title>
<para>为使用ZK portlet 加载器，首先你需要将下列定义添加至<code>WEB-INF/portlet.xml</code>。注意，<code>exp</code>
<code>iration-cache</code>必须被设置为0，以阻止portal缓存结果。</para>
<programlisting>&lt;portlet&gt;&#13;   &lt;description&gt;ZK loader for ZUML pages&lt;/description&gt;&#13;   &lt;portlet-name&gt;zkPortletLoader&lt;/portlet-name&gt;&#13;   &lt;display-name&gt;ZK Portlet Loader&lt;/display-name&gt;&#13;&#13;   &lt;portlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutPortlet&lt;/portlet-class&gt;&#13;&#13;   &lt;expiration-cache&gt;0&lt;/expiration-cache&gt;&#13;   &lt;supports&gt;&#13;      &lt;mime-type&gt;text/html&lt;/mime-type&gt;&#13;      &lt;portlet-mode&gt;VIEW&lt;/portlet-mode&gt;&#13;   &lt;/supports&gt;&#13;&#13;   &lt;supported-locale&gt;en&lt;/supported-locale&gt;&#13;   &lt;portlet-info&gt;&#13;      &lt;title&gt;ZK&lt;/title&gt;&#13;      &lt;short-title&gt;ZK&lt;/short-title&gt;&#13;      &lt;keywords&gt;ZK,ZUML&lt;/keywords&gt;&#13;   &lt;/portlet-info&gt;&#13;&lt;/portlet&gt;&#13;</programlisting></sect2><sect2><title>WEB-INF/web.xml</title>
<para>ZK portlet加载器实际上将ZUML 页面的加载委派给ZK加载器(<code>org.zkoss.zk.ui.http.DHtmlLayoutServlet</code>)。因此，你必须配置<code>WEB-INF/web.xml</code>，将像在 the Developer's Reference 的附录A(Appendix A)中指定的那样，即使你仅想使用portlet。</para></sect2></sect1><sect1><title>使用方法</title><sect2><title>
<code>zk_page </code>及 <code>zk_richlet</code>参数和属性</title>
<para>ZK portlet加载器是一个通用的加载器。为加载一个特定的ZUML页面，你需要指定一个请求参数，一个portlet 属性或一个被称为<code>zk_page</code>的首选项，若你想加载一个ZUML页面，或 <code>zk_richlet，若</code>
<code>你想加载一个richlet</code>。</para>
<para>更确切地说，ZK portlet加载器为ZUML 页面或richlet 的路径检查下列的位置。号码越小，优先级越高。</para>
<orderedlist>
<listitem>
<para>被称为<code>zk_page</code>的请求参数(RenderRequest's <code>getParameter</code>)。若找到了，则它为ZUML页面的路径。</para>
</listitem>
<listitem>
<para>被称为<code>zk_page</code>的请求属性(RenderRequest's <code>getAttribute</code>)。</para>
</listitem>
<listitem>
<para>被称为<code>zk_page</code>的请求首选项(RenderRequest's getPortletPreferences's <code>getValue</code>)。 若找到了，则它为ZUML页面的路径。</para>
</listitem>
<listitem>
<para>被称为<code>zk_richlet</code>的请求参数(RenderRequest's <code>getParameter</code>)。若找到了，则它为 richlet 的路径。</para>
</listitem>
<listitem>
<para>被称为<code>zk_richlet</code>的请求属性(RenderRequest's <code>getAttribute</code>)。若找到了，则它为 richlet 的路径。</para>
</listitem>
<listitem>
<para>被称为<code>zk_richlet</code>的请求首选项(RenderRequest's getPortletPreferences's <code>getValue</code>) 。若找到了，则它为 richlet 的路径。</para>
</listitem>
<listitem>
<para>被称为<code>zk_page</code>的初始参数(PortletConfig's <code>getInitParameter</code>)。若找到了，则它为ZUML页面的路径。</para>
</listitem>
</orderedlist></sect2><sect2><title>事例</title>
<para>如何将一个请求参数或属性传递到一个portlet取决于portal。你需要参考你最喜欢portal的用户指南获取细节。下面为使用 Potix Portal 的一个例子。</para>
<programlisting>&lt;layout contentType="text/html"&gt;&#13;   &lt;title&gt;ZK Porlet Demo&lt;/title&gt;&#13;   &lt;header name="Cache-Control" value="no-cache"/&gt;&#13;   &lt;header name="Pragma" value="no-cache"/&gt;&#13;&#13;   &lt;vbox&gt;&#13;      &lt;hbox&gt;&#13;         &lt;servlet page="sample1.zul"/&gt;&#13;         &lt;portlet name="zkdemo.zkLoader"&gt;&#13;            &lt;attribute name="zk_page" value="/test/sample2.zul"/&gt;&#13;         &lt;/portlet&gt;&#13;      &lt;/hbox&gt;&#13;   &lt;/vbox&gt;&#13;&#13;   &lt;molds uri="~./pxp/html/molds.xml"/&gt;&#13;&lt;/layout&gt;&#13;</programlisting>
<para>
<graphic fileref="img/13-2-2.png" align="center"/>
</para></sect2></sect1></chapter>
<chapter>
<title>16. ZK之外</title>
<para>除了处理ZUML页面，ZK发行版包括了许多技术和工具。本章提供了一些关于它们的基本信息。感兴趣的读者可以参考Javadoc 获取详细的 API。</para><sect1><title>Logger</title>
<para>Package： <code>org.zkoss</code>
<code>.util.logging.Log</code>
</para>
<para>ZK使用的logger基于标准的logger，<code>java.util.Logger</code>。但是，我们将其包装成 <code>org.zkoss.util.logging.Log</code> ，以使其更高效。典型的使用方法如下。</para>
<programlisting>import org.zkoss.util.logging.Log;&#13;class MyClass {&#13;   private static final Log log = Log.lookup(MyClass.class);&#13;   public void f(Object v) {&#13;      if (log.debugable()) log.debug("Value is "+v);&#13;   }&#13;}&#13;</programlisting>
<para>由于ZK使用了标准的 logger记录消息，通过配置你使用Web 服务器的logging，可以控制记录什么。如何配置Web 服务器的logging依服务器的不同而不同。请参考手册。或者，你可以使用ZK提供的logging配置机制，如下所述。</para>
<para>[注]： 默认情况下，所有的ZK log实例都会被映射到同一个名为<code>org.zkoss</code> 的 Java logger，主要为了获得更好的性能。若你想控制日志级别以适于个别类，则必须要调用下面的语句来打开对于等级(hierarchy)的支持。<code>Log.setHierarchy(true);</code></para>
<para>[注]: 若你使用<code>WEB-INF/zk.xml</code>配置了日志级别，就像在下面章节描述的那样，等级支持会被自动禁用。</para><sect2><title>如何使用ZK配置日志等级</title>
<para>除了配置Web服务器的logging，你可以使用ZK提供的logging 配置机制。默认是禁用的。为启用它，你必须在<code>WEB-INF/zk.xml</code>内指定下列内容。更多细节请参考the Developer's Reference 的附录B(Appendix B)。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;log&gt;&#13;      &lt;log-base&gt;org.zkoss&lt;/log-base&gt;&#13;   &lt;/log&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>另外，通过调用<code>LogService</code>的<code>init</code>方法，你可以手动启用logging 配置机制，如下。</para>
<programlisting>org.zkoss.util.logging.LogService.init("org.zkoss");&#13;</programlisting>
<para>若你不仅想记录<code>org.zkoss</code>而是所有，可以为<code>log-base</code>指定空。</para>
<para>一旦启用了此机制，通过在启动时搜索类路径，ZK会搜寻<code>i3-log.conf</code>。若找到了，ZK会加载它的内容并初始化日志级别。然后，ZK会一直监视次此文件，若文件被修改则会重新加载此文件内容。</para></sect2><sect2><title>
<code>i3-log.conf</code>的内容</title>
<para>
<code>i3-log.conf </code>的一个事例如下。</para>
<programlisting>org.zkoss.zk.ui.impl.UiEngineImpl=FINER&#13;   #Make the log level of the specified class to FINERorg.zkoss.zk.ui.http=DEBUG&#13;   #Make the log level of the specified package to DEBUG&#13;org.zkoss.zk.au.http.DHtmlUpdateServlet=INHERIT&#13;  #Clear the log level of a specified class such that it inherits what&#13;   #has been defined above (Default: INFO)&#13;org.zkoss.zk.ui=OFF&#13;   #Turn off the log for the specified package&#13;org.zkoss=WARNING&#13;   #Make all log levels of ZK classes to WARNING except those specified here&#13;</programlisting><sect3><title>被允许的级别</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>级别</para>
</entry>
<entry>
<para>描述</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>OFF</para>
</entry>
<entry>
<para>表示没有消息。</para>
</entry>
</row>
<row>
<entry>
<para>ERROR</para>
</entry>
<entry>
<para>表示提供错误信息。</para>
</entry>
</row>
<row>
<entry>
<para>WARNING</para>
</entry>
<entry>
<para>表示提供警告信息。也隐含着ERROR。</para>
</entry>
</row>
<row>
<entry>
<para>INFO</para>
</entry>
<entry>
<para>表示提供信息性的消息。也隐含着ERROR和WARNING。</para>
</entry>
</row>
<row>
<entry>
<para>DEBUG</para>
</entry>
<entry>
<para>表示提供用于调试目的的跟踪信息。也隐含着ERROR，WARNING 和 INFO。</para>
</entry>
</row>
<row>
<entry>
<para>FINER</para>
</entry>
<entry>
<para>表示提供用于调试目的的相当详细的跟踪信息。也隐含着ERROR，WARNING， INFO 和 DEBUG。</para>
</entry>
</row>
<row>
<entry>
<para>INHERIT</para>
</entry>
<entry>
<para>表示明确任何为指定包或类设置的等级。换言之，日志等级与其父结点相同。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>i3-log.conf</code>的位置</title>
<para>首先，ZK会在类路径(classpath)查找此文件。若未找到，则会在<code>conf</code>目录查找。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>应用程序服务器</para>
</entry>
<entry>
<para>位置</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Tomcat</para>
</entry>
<entry>
<para>将<code>i3-log.conf</code>置于<code>$TOMCAT_HOME/conf</code> 目录。</para>
</entry>
</row>
<row>
<entry>
<para>其它</para>
</entry>
<entry>
<para>首先试试conf目录。若不工作，你可以设置被称为<code>org.zkoss.io.conf.dir</code>
<code>的</code>系统属性目录作为放置<code>i3-log.conf</code>的目录。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>禁用所有日志</title>
<para>一些日志会在加载<code>i3-log.conf</code>之前产生。若你想完全禁用所有日志，则必须配置Web服务器<footnote>
<para>记住ZK使用标准的logging功能。除非你在 <code>i3-log.conf</code>内指定了一些内容 ，默认的logging级别取决于Web服务器(通常为INFO)。 </para>
</footnote>的 logging，或当配置<code>WEB-INF/web.xml</code>内的<code>DHtmlLayoutServlet</code>时指定<code>log-level</code>。细节请参考the Developer's Reference。</para>
<programlisting>&lt;servlet&gt;&#13;   &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;   &lt;servlet-class&gt;&#13;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;log-level&lt;/param-name&gt;&#13;      &lt;param-value&gt;OFF&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;...&#13;</programlisting></sect2></sect1>
<sect1><title>DSP</title>
<para>Package：<code>org.zkoss.web.servlet.dsp</code>
</para>
<para>一种类似于JSP模板的技术。它的语法和JSP相同。不同于JSP， DSP在运行时被解释，所以很容易部署DSP页面。在运行环境中并不需要Java编译器。此外，你可以将DSP 页面发布为jar文件。这就是ZK发布的方式。</para>
<para>但是，你不能在DSP 页面内嵌入Java代码。DSP的行为，尽管可以通过TLD文件扩展，与JSP标签还是不同的。</para>
<para>若你想在你的Web应用程序中使用DSP，需要在<code>WEB-INF/web.xml</code>内添加下列几行。</para>
<programlisting>   &lt;!-- ///////////// --&gt;&#13;   &lt;!-- DSP (optional) --&gt;&#13;   &lt;servlet&gt;&#13;      &lt;description&gt;&lt;![CDATA[&#13;The servlet loads the DSP pages.&#13;      ]]&gt;&lt;/description&gt;&#13;      &lt;servlet-name&gt;dspLoader&lt;/servlet-name&gt;&#13;      &lt;servlet-class&gt;org.zkoss.web.servlet.dsp.InterpreterServlet&lt;/servlet-class&gt;&#13;&#13;      &lt;!-- Specify class-resource, if you want to access TLD defined in jar files --&gt;&#13;     &lt;init-param&gt;&#13;         &lt;param-name&gt;class-resource&lt;/param-name&gt;&#13;         &lt;param-value&gt;true&lt;/param-value&gt;&#13;      &lt;/init-param&gt;&#13;   &lt;/servlet&gt;&#13;   &lt;servlet-mapping&gt;&#13;      &lt;servlet-name&gt;dspLoader&lt;/servlet-name&gt;&#13;      &lt;url-pattern&gt;*.dsp&lt;/url-pattern&gt;&#13;   &lt;/servlet-mapping&gt;&#13;</programlisting>
<para>[注]： DSP加载器的映射是可选的。仅当你想使用DSP 语法编写Web页面时再指定它。尽管标准的ZK组件使用DSP做为模板技术，但是它们直接由ZK加载器处理。</para>
<para>详细信息请参考Developer's Reference 。</para></sect1><sect1><title>iDOM</title>
<para>Package：<code>org.zkoss.idom</code>
</para>
<para>一个W3C DOM 的实现。它由JDOM<footnote>
<para>http://www.jdom.org</para>
</footnote>驱使(inspired)，对于所有的XML对象都有具体的类，例如元素和属性。但是，iDOM 实现了W3C API，例如<code>org.w3c.dom.Element</code>。因此，你可以无缝使用iDOM与仅接受W3C DOM的XML功能。</para>
<para>典型的例子为XSLT 和XPath。你可以与iDOM 使用任何喜欢的XSL处理器和XPath功能。</para>
<para/></sect1></chapter>
</book>

