<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="zh-CN">
<bookinfo>
    <title>ZK开发手册</title>
	 <copyright>
      <year>2007</year>
      <holder>Potix Corporation. All rights reserved.</holder>
	</copyright>
</bookinfo>
<para/>
<chapter><title>简介</title>
<para>欢迎使用ZK---- 一种丰富Web应用程序的最简单方式。</para>
<para>此开发手册买描述了ZK的概念和功能。关于如何安装配置ZK的环境，请参阅Quick Start Guide。如果想得到的各个组件(components)的属性和方法的详细描述，请参阅Developer's Guide。</para>
<para>这章描述了Web程序，AJAX技术和ZK项目的历史背景。如果你想马上了解ZK的功能，可以跳过这一章。 </para><sect1><title>传统的Web应用程序</title>
<para>以交换文档简单高效为目标，Web技术，超文本传输协议(HTTP)和超文本标记语言(HTML)，都来源于单页性(page-based )和无状态(stateless-communication)的模式。在这种模式中，一个页面是自给自足(self-contained)的，并且是沟通客户端与服务器端的最小单位。</para>

<graphic align="center"  fileref="img/1.png" />

<para>随着网络俨然成为应用开发的默认平台，这种模式面临着巨大的挑战：对于表现当今应用程序中复杂性的无能为力。举个例子，为了给客户报价，你或许必须打开另一个页面来查询此客户的交易记录，再打开一个页面来显示当前的价格，还得开一个页面来存储当前信息。用户被迫离开他正在工作的页面，并且在几个页面间来回浏览。这很容易迷失，混淆，结果是把客户弄得不愉快，销售机会的损失和低生产力。</para>
<para>在这种单页性(page-based )的模式上开发一个现代的应用程序也是一个极大的挑战。在这种模式中，运行在服务器上的应用程序必须处理来自从语法上分析请求，送出回应 ，连接用户从一个页面到另一个页面路由的一切，并且处理用户的各种错误。 数十种框架，例如Struct，Tapestry和JSF，随即出现用来简化开发过程。由于单页性(page-based)模式与现代模式之间的巨大差别，学习和使用这些框架并不是一个愉快的过程，更不要提直觉感知(intuition)和简化了。</para></sect1><sect1><title>点对点(Ad-hoc)AJAX应用</title>
<para>经过数十年的演变，Web应用已经从静态HTML发展到动态HTML，applets，Flash，最后发展到了AJAX<footnote>
<para>Ajax是由Jesse James Garrett於Ajax: A New Approach to Web Applications中所提出的。</para>
</footnote> (Asynchronous JavaScript and XML ，非同步的JavaScript和XML )。通过谷歌地图及推荐(Google Maps and Suggest)的说明，AJAX技术通过提供与桌面应用程序同等水平的互动性和反应能力给Web应用带来了新生命。不同于applets或Flash，AJAX基于标准的浏览器和JavaScript，并且不需要专门的插件。</para>

<graphic align="center"  fileref="img/1-2.png"/>

<para>AJAX是新一代的DHTML，就像DHTML，它在很大程度上依赖于JavaScript监听用户活动产生的事件,然后动态的操纵浏览器中一个页面(aka. DOM)的视觉表现。此外，它更近一步，能够使与服务器的沟通异步进行，即不需要离开或提交整个页面。它通过引入客户与服务器间轻量级的通信(light-weight communication )打破了基于页面的模式。妥善设计，AJAX可以给Web应用带来丰富的桌面通用组件，而且这些组件的内容可以在应用程序的控制下动态更新。</para>
<para>当提供给用户需要的交互性的同时，AJAX给已经很昂贵的Web应用程序开发增加了复杂性和技术先决条件。开发者不得不在浏览器中操纵DOM，并且使用不兼容甚至是错误的JavaScript与服务器通信，为了更好的交互性，开发者必须重复复制应用数据和业务逻辑以便于浏览。这样就增加了维护成本及同步数据的挑战。</para>
<para>底线是在关于处理请求方面，点对点(Ad-hoc)的AJAX应用与传统的Web应用没有区别。开发者仍然必须解决由单页性(page-based)和无状态(stateless-communication)模式造成的隔阂。</para></sect1><sect1><title>ZK: 它是什么 </title><para>ZK是一个事件驱动(event-driven)的，基于组件(component-based)的，用以丰富网络程序中用户界面的框架。ZK包括一个基于AJAX事件驱动的引擎(engine)，一套丰富的XUL和XHTML，以及一种被称为ZUML(ZK User Interface Markup Language，ZK用户界面标记语言)的标记语言。</para>
<para>有了ZK，您可以利用XUL和XHTML的丰富特性来呈现您的Web应用，操纵它们来处理因用户活动而引发的事件，就像您使用多年的桌面应用程序那样。不同于大多数其它框架，ZK是一种幕后(behind-the-scene)技术，组件内容的同步和流水线事件(pipelining of events)都由ZK引擎自动完成。</para>
<para>您的用户获得了如同桌面程序的互动性和反应能力，而您的开发仍然像开发桌面应用程序那样简单。</para>
<para>除了简单的模型和丰富的组件，ZK也支持一种文本标记语言，称为ZUML。ZUML，如同HTML，可以让开发人员设计界面而无需编程。通过XML的命名空间，ZUML无缝的集成了一套不同的标签<footnote>
<para>标签是XML元素。组件是在当ZUML网页被翻译时所产生出来的。</para>
</footnote>到同一页面。目前，ZUML支持两套标签，即XUL和HTML。</para>
<para>为了方便快速模型开发(prototyping)和定制，ZK允许开发人员嵌入EL表达式，以及您喜欢的脚本语言，包括但不限于 Java<footnote>
<para>使用BeanShell(http://www.beanshell.org)的Java interpreter。</para>
</footnote>, JavaScript<footnote>
<para>使用Rhino (http://www.mozilla.org/rhino)的JavaScript interpreter。</para>
</footnote>, Ruby<footnote>
<para>使用JRuby (http://jruby.codehaus.org/)的Ruby interpreter。</para>
</footnote> and Groovy<footnote>
<para>使用Groovy (http://groovy.codehaus.org/)的Groovy interpreter。</para>
</footnote>. 开发人员可以选择不嵌入任何脚本语言，如果他们喜欢更严格的要求(discipline)。不同于JavaScript嵌入在HTML，ZK在服务器端执行所有的嵌入脚本。</para>
<para>注意我们所说的一切运行在服务器端是从应用程序开发者的角度出发的。对于组件开发人员来说，他们必须平衡互动性与简单性来决定什么任务由浏览器来完成，而什么任务由服务器来完成。</para></sect1><sect1><title>ZK: 它不是什么</title><para>ZK并没有关注持久化(persistence)或伺服务器之间的沟通(inter-server communication)。ZK被设计的尽可能的简单，它只针对表示层(presentation tier)。他并不要求和暗示任何后端技术，所有你喜欢的中间件就像以前一样工作，如JDBC， Hibernate， Java Mail，EJB 或 JMS。</para>
<para>Zk并没有为开发人员提供(tunnel)，RMI或其他的API用来在客户端与服务器端通信，因为所有的代码都运行在同一服务器的同一Java虚拟机(JVM)上。</para>
<para>ZK并没有强迫开发人员使用MVC或其他设计模式。是否使用它们由开发人员选择。</para>
<para>ZK并不是旨在把XUL带入Web应用的框架。它的目标是把桌面编程模式引入Web应用。目前，它只支持XUL和XHTML。将来它或许会支持XAML, Xquery及其它。</para>
<para>ZK将AJAX嵌入到了现今的应用中(implementation)，但它并没有止步于AJAX结束的地方。在即将来临的ZK Mobile中，您的应用程序可以到达支持J2ME的任何设备，例如PDA，手机和游戏平台。此外，您根本不用修改您的应用程序<footnote>
<para>根据萤幕大小有时需要做调整。</para>
</footnote>。</para></sect1><sect1><title>ZK: 局限</title><para>ZK不适合在客户端运行多任务的应用程序，例如3D动作游戏，除非你写编写一个特殊的组件。ZK也不适合需要大量使用客户端计算能力的应用程序。</para></sect1></chapter><chapter><title>让我们开始吧</title>
<para>这一章的内容描述了如何写出你的第一个ZUML页面，如果你没时间的话建议你至少阅读这一章。</para>
<para>此章使用ZUL来说明ZK的功能，但是也适合于其他ZK支持的语言。</para><sect1><title>Hello World!</title>
<para>当ZK安装到你最喜爱的Web服务器<footnote>
<para>参考Quick Start Guide。</para>
</footnote>后, 你就可以直接编写应用程序。仅需在合适的目录新建一个名为hello.zul的文件<footnote>
<para>你也可以试试这些例子的在线示范。</para>
</footnote> 。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;Hello World!&#13;&lt;/window&gt;&#13;</programlisting>
<para>然后输入正确的URL，例如：<ulink url="http://localhost/myapp/hello.zul">http://localhost/myapp/hello.zul</ulink>，得到如下页面 ：</para>
<para/>

<graphic align="center"  fileref="img/2-1.png"/>

<para>在ZUML页面中，一个XML元素描述了应该创建。在这个例子中，被创建的是window(<code>org.zkoss.zul.Window)，</code>XML属性(<code>attributes</code>)用来指定window组件属性(properties)的值。在这个例子中，创建了window，<code>并指定了title和border属性的值分别为 '</code>Hello'和'normal'。XML元素内的文本(即Hello World)也可以通过一个称为Label (<code>org.zkoss.zul.Label</code>)的标签来展示。所以上面的例子和下面的例子是等价的：</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;label value="Hello World!"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>互动性</title>
<para>让我们来添加一些互动元素：</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>点击按钮，可以看到如下效果：</para>

<graphic align="center"  fileref="img/2-2c.png"/>
<para><code>onClick</code>是为组件添加事件监听器的一个特殊属性。这个属性的值可以是任何合法的Java代码。注意我们使用 &amp;<code>quot;</code>来匹配双引号(“)以使其成为合法的XML文档。如果你不熟悉XML，可以在 ZK 用户接口标记语言(ZK User Interface Markup Language )一章中查看有关 XML的部分。</para>
<para>
<code>alert</code>是一个显示消息对话框的全局函数。<code>它是调用org.zkoss.zul.Messagebox</code>类的一个捷径。 </para>
<programlisting>&lt;button label="Say Hello" onClick="Messagebox.show(&amp;quot;Hello World!&amp;quot;)"/&gt;&#13;</programlisting>
<para>[注]: </para>
<orderedlist>
<listitem>
<para>嵌入到ZUML页面的脚本可以用不同的语言编写，包括但不限于Java, JavaScript, Ruby  and Groovy。此外，它们是运行在服务器上的。</para>
</listitem>
<listitem>
<para>在运行时刻，ZK使用BeanShell解释Java，所以你可以声明全局函数，<code>例如alert。</code>同样 它为大部分的脚本语言提供了一个简单的方式来定义全局函数，有时甚至是类。</para>
</listitem>
<listitem>
<para>在ZUML页面嵌入脚本语言前，<code>所有java.lang, java.util, org.zkoss.zk.ui， org.zkoss.zk.ui.event和org.zkoss.zul包中的类都已经被引入。</code>
</para>
</listitem>
</orderedlist></sect1><sect1><title>
<code>zscript</code>元素</title>
<para>
<code>zscript</code>是一个用来定义代码的元素，当ZUML页面被提交时被赋值(evaluated)。典型的应用包括初始化和申明全局变量与方法。</para>
<para>[注]: <code>你不可以在zscript代码中使用EL表达式。</code>
</para>
<para>例如，下面的例子展示了每次按钮被按下时显示的不同信息。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="sayHello()"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;int count = 0;&#13;&nbsp;&nbsp;&nbsp;void sayHello() { //declare a global function&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert("Hello World! "+ ++count);&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>[注]: <code>zscript</code>仅当页面被加载时赋值(evaluated)一次，通常被用于定义函数和初始变量。</para><sect2><title>脚本语言</title>
<para>Java是ZK默认的脚本语言，<code>但是你可以通过指定language属性来选择不同的语言，</code>就像下面的例子一样。<code>language属性区分大小写。</code>
</para>
<programlisting>&lt;zscript language="javascript"&gt;&#13;&nbsp;&nbsp;&nbsp;alert('Say Hi in JavaScript');&#13;&nbsp;&nbsp;&nbsp;new Label("Hi, JavaScript!").setParent(win);&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>你可以像下面的例子一样使用前缀 <code>javascript:</code>来为事件处理器指定脚本语言。注意：不要在自己指定语言的前面或后面添加空格。</para>
<programlisting>&lt;button onClick="javascript: do_something_in_js();"/&gt;&#13;</programlisting>
<para>你可以在同一页面中使用不同的脚本语言。</para></sect2><sect2><title>将脚本代码放在一个单独的文件中</title>
<para>为了分离代码和视图(views)，开发人员可以将将脚本代码放在单独的文件中，<code>例如sayHello.zs，</code>然后使用<code>src</code>属性指向此文件。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="sayHello()"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript src="sayHello.zs"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>假设<code>sayHello.zs</code>文件的内容如下:</para>
<programlisting>int count = 0;&#13;void sayHello() { //declare a global function&#13;&nbsp;&nbsp;&nbsp;alert("Hello World! "+ ++count);&#13;}&#13;</programlisting></sect2></sect1><sect1><title>
<code>attribute</code>元素</title>
<para>
<code>attribute</code>元素是用来定义XML元素属性的元素。妥善使用，它可以使页面更具可读性。<code>下面的例子和前面所述的hello.zul是等价的。</code>
</para>
<programlisting>&lt;button label="Say Hello"&gt;&#13; &nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;alert("Hello World!");&lt;/attribute&gt;&#13;&lt;/button&gt;&#13;</programlisting>
<para>
<code>你可以决定是否使用trim属性来省略属性值开头和末位的值，</code>使用方法如下：</para>
<programlisting>&lt;button&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;attribute name="label" trim="true"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The leading and trailing whitespaces will be omitted.&#13;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;&#13;&lt;/button&gt;&#13;</programlisting></sect1><sect1><title>EL表达式</title>
<para>就像JSP一样，你可以在ZUML页面的任何部分使用EL表达式，但除了属性的名字(names of attributes)，元素(elements)和处理指令(processing instruction)。</para>
<para>EL表达式的语法格式为<code>${expr}</code>，例如：</para>
<programlisting>&lt;element attr1=”${bean.property}”.../&gt;&#13;${map[entry]}&#13;&lt;another-element&gt;${3+counter} is ${empty map}&lt;/another-element&gt;&#13;</programlisting>
<para>[提示]: <code>emp</code>
<code>ty</code>是用来测试一个map, collection, array 或者string 是否为null或空的。</para>
<para>[提示]: <code>map[entry]</code>是读取map元素的一种方法，换句话说，就像Java中的 <code>map.get(entry)</code>。</para>
<para>当一个EL表达式作为一个属性值时，它可以返回任何类型的对象，对象的长度限制在组件可以接受的范围内。在下面的例子中，表达式被赋予一个Boolean对象的值：</para>
<programlisting>&lt;window if="${some &gt; 10}"&gt;&#13;</programlisting>
<para>[提示]: + 在EL表达坏中是算数操作，并不能用于string类型。对于string可以使用 "<code>${expr1} is added with ${expr2}"。</code>
</para>
<para>标准的隐含对象(implicit objects)，<code>如param</code>和<code>requestScope，</code>还有ZK的隐含对象，<code>如self</code>和<code>page，</code>可以很简单的使用。</para>
<programlisting>&lt;textbox value="${param.who} does ${param.what}"/&gt;&#13;</programlisting>
<para>通过从TLD引入EL函数，<code>你可以使用被称为tablib的指令，</code>就像下面：</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.tld" prefix="p" ?&gt;&#13;</programlisting>
<para>Developer's Reference 提供了更多关于EL表达式的细节。或者，你可以参考JSP 2.0的指南或手册来来获得更多关于EL表达式的信息。</para></sect1><sect1><title>
<code>id</code>属性</title>
<para>为了读取Java代码或EL表达式中的组件，你可以使用<code>id</code>属性来标识它。在下面的例子中，<code>我们为</code>label<code>设置了一个标识，</code>这样当一个按钮被按下时，<code>我们就可以操纵</code>label<code>的值了。</code>
</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;Do you like ZK? &lt;label id="label"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;separator/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Yes" onClick="label.value = self.label"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="No" onClick="label.value = self.label"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当按下Yes按钮时，可以看到如下效果：</para>

<graphic align="center"  fileref="img/2-6a.png" />

<para>下面是一个EL表达式为组件赋值的例子：</para>
<programlisting>&lt;textbox id="source" value="ABC"/&gt;&#13;&lt;label value="${source.value}"/&gt;&#13;</programlisting></sect1><sect1><title>
<code>if</code>
<code>和</code>
<code>unless</code>属性</title>
<para>
<code>if和unless属性被用于控制是否创建一个组件，</code>在下面的例子中，<code>两个</code>label<code>只有在请求中含有一个为vote的属性时才被创建：</code>
</para>
<programlisting>&lt;label value="Vote 1" if="${param.vote}"/&gt;&#13;&lt;label value="Vote 2" unless="${!param.vote}"/&gt;&#13;</programlisting>
<para>如果两个属性都被指定，将不会创建组件除非它们的值都被赋值为true。</para></sect1><sect1><title>
<code>forEach</code>属性</title>
<para>forEach 属性用来控制要创建多少组件，如果你为这个对象指定一个对象集合，ZK 装载机(ZK loader)将为每个被指定的集合项目创建一个组件。在下面的ZUML页面中，<code>listitem元素将被赋值三次(</code>分别为"Monday", "Tuesday" 和"Wednesday")然后产生三个list项目。</para>
<programlisting>&lt;zscript&gt;contacts = new String[] {"Monday", "Tuesday", "Wednesday"};&lt;/zscript&gt;&#13;<inlinegraphic align="right"  fileref="img/2-8.png" />&lt;listbox width="100px"&gt;&#13;&nbsp;&nbsp;&lt;listitem label="${each}" forEach="${contacts}"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>当使用forEach属性赋值时，</code>每个变量被一个接一个的赋予来自集合的对象，即像先前接触的例子一样。因上面的ZUML页面和下面的是等价的：</para>
<programlisting>&lt;listbox&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listitem label="Monday"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listitem label="Tuesday"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listitem label="Wednesday"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>除了使用forEach，还可以通过forEachBegin和forEachEnd来控制迭代(</code>iteration)，可以参考 ZK User Interface Markup Language一章中有关ZK属性的一节来获得详细信息。</para></sect1><sect1><title>
<code>use</code>属性</title>
<para>在页面中嵌入代码不当会增加维护的难度，有两种途径可以从视图中分离出代码。</para>
<para>一种途径是你可以监听所关心的事件，然后调用合适的方法进行处理。例如，可以调用<code>onCreate</code>
<footnote>
<para>当ZUML中window产生时onCreate事件会被送出。</para>
</footnote>, <code>onOK</code>
<footnote>
<para>使用者按下ENTER key时onOK事件被送出。</para>
</footnote>, <code>onCancel</code>
<footnote>
<para>使用者按下ESC key时onCancel事件被送出。</para>
</footnote> 事件来完成初始化(initialize)，处理(process)和取消(cancel)等工作。</para>
<programlisting>&lt;window id="main" onCreate="MyClass.init(main)"
&nbsp;&nbsp;&nbsp;onOK="MyClass.process(main)" onCancel="MyClass.cancel(main)"/&gt;&#13;</programlisting>
<para>另外，必须有一个名称为MyClass的Java类，内容像下面一样：</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyClass {&#13;&nbsp;&nbsp;&nbsp;public static void init(Window main) { //does initialization&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;public static void save(Window main) { //saves the result&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;public static void cancel(Window main) { //cancel any changes&#13;&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting>
<para>另一种途径，你可以使用<code>use</code>属性来指定一个类，用来替换默认的组件类。</para>
<programlisting>&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>然后必须创建一个名为MyWindow的Java类，内容如下：</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyWindow extends Window {&#13;&nbsp;&nbsp;&nbsp;public void onCreate() { //does initialization&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;public void onOK() { //save the result&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;public void onCancel() { //cancel any changes&#13;&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting>
<para>这两种方法有着不同的优点，它们都扮演者MVC模式中控制者(controller)的角色。使用哪种分方法是您的选择。</para><sect2><title>以 <code>zscript</code>实现Java类</title><para>在<code>zscript</code>中继承Java类，多亏了BeanShell<footnote>
<para>http://www.beanshell.org</para>
</footnote>的强大功能，Java类的继承可以按如下的方式完成：</para>
<para/>
<programlisting>&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;public class MyWindow extends Window {&#13;
&nbsp;&nbsp;&nbsp;}
&lt;/zscript&gt;
&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>[提示]:很多脚本语言，例如JRuby，也允许开发人员定义可以被Java虚拟机(JVM)存取的类，请参考相应的手册来了解详情。</para>
<para>为了从视图中分离代码，你可以把所有的<code>zscript</code>代码放到单独的文件中，称为<code>mywnd.zs</code>，然后：</para>
<programlisting>&lt;zscript src="/zs/mywnd.zs"/&gt;&#13;&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>[提示]:你也可以使用初始化指令(<code>init</code>directive)来指定<code>zscript</code>文件的位置。不同的是初始化指令在所有组件被创建前被赋指(页面初始阶段)。如需更多信息请参考ZK User Interface Markup Language 一章中有关初始化指令( <code>init</code>Directive section)的部分。</para></sect2></sect1><sect1><title>手动创建组件</title>
<para>除了讲述什么组件可以在ZUML页面被创建外，开发人员可以手动创建组件。所有的组件都是具体的(concrete)，你可以直接<footnote>
<para>为了简化，这里不用factory design pattern。</para>
</footnote>通过它们的构造函数(constructors)来创建它们。</para>
<programlisting>&lt;window id="main"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Add Item"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;&#13;&nbsp;&nbsp;&nbsp;new Label("Added at "+new Date()).setParent(main);&#13;&nbsp;&nbsp;&nbsp;new Separator().setParent(main);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/button&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;separator bar="true"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>当一个组件被手动创建时，它并没有自动被加到页面。换句话说，它并不在用户的浏览器中出现。为了将它加到页面，你可以调用<code>setParent</code>，<code>appendChild</code>或 <code>insertBefore</code>方法来为其指定一个父类(parent)，如果父类组件是页面的一部分，那么它也变成了页面的一部分。</para>
<para>组件类并没有destroy 或close方法<footnote>
<para>与W3C DOM的观念相近。而另一方面，Windows API需要程序员管理生命周期。</para>
</footnote>，当一个组件从页面中被拆卸的时候就会从浏览器中内移除。它表现的就像附着在页面上一样。</para>
<programlisting>&lt;window id="main"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;Component detached = null;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button id="btn" label="Detach"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;&#13;&nbsp;&nbsp;&nbsp;if(detached != null) {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detached.setParent(main);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detached = null;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btn.label = "Detach";&#13;&nbsp;&nbsp;&nbsp;} else {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(detached = target).setParent(null);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btn.label = "Attach";&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/button&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;separator bar="true"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;label id="target" value="You see this if it is attached."/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>在上面的例子中，你可以用<code>setVisible</code>方法来产生类似的效果。但是<code>setVisible(false)</code>方法并没有把组件从浏览器中移除，它只是使一个组件(及其所有的子组件(children))变得不可见。</para>
<para>当一个组件从页面被卸载后，如果应用程序没有涉及到该组件，它所占用的内存会被Java虚拟机的垃圾回收机制(JVM's garbage collector)所释放。</para><sect2><title>不使用ZUML来开发ZK应用程序</title>
<para>对于根本不习惯使用ZUML的开发人员来说，他们可以使用被称为richlet的方法来手动创建所有的组件。</para>
<programlisting>import org.zkoss.zul.*;&#13;public class TestRichlet extends org.zkoss.zk.ui.GenericRichlet {&#13;&nbsp;&nbsp;&nbsp;public void service(Page page) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page.setTitle("Richlet Test");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Window w = new Window("Richlet Test", "normal", false);&#13;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Label("Hello World!").setParent(w);&#13;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Label l = new Label();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.setParent(w);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.setPage(page);
&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting>
<para>请参考增强型功能(Advanced Features)一章中有关Richlets 的部分。 </para></sect2></sect1><sect1><title>为某一页面定义新的组件</title>
<para>就像所展示的那样，通过使用XML属性为组件指定一个属性是很容易的事情。</para>
<programlisting>&lt;button label="OK" style="border:1px solid blue"/&gt;&#13;</programlisting>
<para>ZK提供了一种强大但很简单的方式来让开发人员为某一页面定义新的组件，如果同一类型的大多数组件共享一套属性，这就非常有用。</para>
<para>首先使用组件指令来定义一个新的组件。</para>
<programlisting>&lt;?component name="bluebutton" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;bluebutton/&gt;
&lt;bluebutton label="Cancel"/&gt;</programlisting>
<para>等价于：</para>
<programlisting>&lt;bluebutton style="border:1px solid blue" label="OK"/&gt;
&lt;bluebutton style="border:1px solid blue" label="Cancel"/&gt;</programlisting>
<para>此外，你可以用下面的方式来覆盖<code>button</code>组件的定义，当然，这不会影响到其他的页面：</para>
<programlisting>&lt;?component name="button" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;button/&gt;
&lt;button label="Cancel"/&gt;</programlisting>
<para>如需要更多的信息，请参考ZK用户界面标记语言(ZK User Interface Markup Language)一章中关于组件指令(<code>component</code>Directive )的部分。</para></sect1></chapter><chapter><title>基础</title><para>这一章讲述了ZK的基础。这里使用了XUL来说明ZK的功能，但同样可用于ZK支持的其他标记语言。</para><sect1><title>架构概况</title>
<para>ZK包括一种基于AJAX机制用来实现自动的交互性，一套丰富的基于XUL的组件用以丰富可用性，和一种的标记语言用来简化开发。</para>
<para>基于AJAX的机制包括三个部分，描绘如下：ZK 加载器(ZK loader)，ZK AU引擎(ZK AU Engine )，和ZK客户端引擎(ZK Client Engine)。</para>

<graphic align="center"  fileref="img/3-1.png"/><para>基于用户的请求，ZK 加载器(ZK loader)加载一个ZK页面，解释它，并将结果送到HTML页面来响应URI请求。ZK页面是用一种被称为ZUML的标记语言写成的。ZUML，就像HTML，被用来描述什么组件被创建，以及如何把它们呈现出来。这些组件一旦被创建，就会一直处于可用状态知道会话超时。</para>
<para>然后ZK AU<footnote>
<para>AU 即Asynchronous Update，异步更新。</para>
</footnote> 引擎(ZK AU Engine )和ZK客户端引擎(ZK Client Engine)作为投手和捕手一起工作。它们将在浏览器端发生的事件送到运行在服务器端的应用程序，然后更新浏览器段的DOM树，基于组件如何被应用程序操纵。这种方式即所谓的事件驱动编程模型。</para><sect2><title>执行流</title>
<orderedlist>
<listitem>
<para>当用户在浏览器中键入一个URL或点击一个超链接时，一个请求便被送到了Web服务器，如果URI符合ZK的配置<footnote>
<para>参考 the Developer's Reference中的Appendix A 。</para>
</footnote>，ZK 加载器则援引担任这一要求 。</para>
</listitem>
<listitem>
<para>ZK 加载器(ZK loader)加载指定的页面然后解释它，以据此创建和适的组件。</para>
</listitem>
<listitem>
<para>当解释完整个页面后，ZK 加载器(ZK loader)将结果送到一个HTML页面。然后这个HTML页面被送回浏览器和ZK客户端引擎(ZK Client Engine)<footnote>
<para>ZK客户端引擎(ZK Client Engine)是由JavaScript语言编写的。浏览器缓存ZK客户端引擎，所以通常仅需在首次读取时设置引擎。</para>
</footnote>一起。</para>
</listitem>
<listitem>
<para>ZK客户端引擎(ZK Client Engine)坐落在浏览器，以监视由客户的活动触发的事件，例如挪动鼠标，或改变某个值。一旦监测到，它就通知ZK AU引擎通过发送一个ZK请求<footnote>
<para>Zk请求(ZK requests)是一种特殊的AJAX 请求。 但是，对于mobile版本，ZK 请求是一种特殊的HTTP 请求。</para>
</footnote>。</para>
</listitem>
<listitem>
<para>当从客户端引擎接到ZK请求后，如果有需要的话AU引擎就更新相应组件的内容。然后，AU引擎通过调用相关的事件处理程序(如果有的话)来通知应用程序。</para>
</listitem>
<listitem>
<para>如果应用程序选择改变组件的内容，添加或移动组件，AU引擎通过ZK响应(ZK responses)将更新后组件的新内容送至客户端引擎。</para>
</listitem>
<listitem>
<para>这些ZK响应实际上是一些命令，这些命令指示客户端引擎如何更新DOM树的内容。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>组件，页面和桌面</title><sect2><title>组件</title>
<para>组件即一个用户界面(UI)对象，如标签，按钮和树。它用来定义 一个特定用户界面的视觉表现和行为。通过操纵他们， 开发 人员来控制如何在客户端展示一个应用程序。</para>
<para>组件必须实现 <code>org.zkoss.zk.ui.Component</code>接口。</para></sect2><sect2><title>页面</title>
<para>页面(<code>org.zkoss.zk.ui.Page</code>)是一系列组件的集合，一个页面限制属于它的组件，这样它们会被展示在浏览器的特定部分。一个页面被自动创建当ZK 加载器(ZK loader)解释完一个ZUML页面时。</para><sect3><title>页面标题</title>
<para>每个页面都可以有一个标题，这个标题将被作为浏览器窗口标题(window caption)的一部分。请参考ZK用户界面标记语言(ZK User Interface Markup Language)一章中有关处理指令(Processing Instructions)的部分。</para>
<programlisting>&lt;?page title="My Page Title"?&gt;&#13;</programlisting></sect3></sect2><sect2><title>桌面</title>
<para>一个ZUML可以直接或间接包含另外一个ZUML页面。由于这些页面是为服务同样的URL请求而创建的，它们被统称为桌面(<code>org.zkoss.zk.ui.Desktop</code>)。换句话说，桌面是页面的集合，这些 页面服务于同样的URL请求。</para>

<graphic align="center"  fileref="img/3-2-3a.png"/>

<para>为了实现Zk应用程序与用户的交互，更多的页面需要被加到桌面，而另一些需要从桌面移除。类似的，一个组件可能被加到页面或从页面移除。</para><sect3><title>createComponents 方法</title><para>请注意创建移除页面和桌面都是在背后达成的。并没有关于此的API。每次ZUML加载一个页面时，这个页面就被创建。当ZK发现某个页面不再被用到时这个页面就会被移除。当第一个ZUML页面被加载时桌面被创建。当太多的桌面为特定的会话而创建时桌面会被移除。</para>
<para>
<code>org.zkoss.zk.ui.Executions</code>类中的<code>CreateComponents</code>方法仅能创建组件，而不是页面，即使它装载一个ZUML页面(亦=page)。</para></sect3></sect2><sect2><title>组件树的森林</title>
<para>一个组件至多有一个父组件，而可能有多个子组件。一些组件只能接受某些类型的组件作为子组件，一些组件必须为某些类型组件的子组件，一些组件根本不允许有子组件。例如，XUL中的Listbox接受Listcols 和 Listitem 。没有任何父组件的组件称为根组件(root component)。一个页面可能有多个根组件，这些组件可以由<code>getRoots</code> 方法获得。</para></sect2><sect2><title>组件：视觉表现和Java对象</title>
<para>除了在服务器端的Java对象，组件在浏览器端有一个可视部分<footnote>
<para>如果客户端为浏览器， 视觉表现为 一个 DOM 元素 或一个套DOM 元素。</para>
</footnote> ，并且当且仅当它属于一个页面时。当一个组件附加到一个页面时，其视觉部分就会被创建<footnote>
<para>可是部分是自动创建，更新和移除的。应用程序开发人员很少需要注意到它的存在。 他们在在服务器端操纵对象部分（object part)。</para>
</footnote>。当一个组件从一个页面脱离时，其视觉部分被移除。</para>
<para>有两种方法将一个组件附加到一个页面。第一种，你可以调用<code>setPage</code>方法使一个组件成为指定页面的根组件。第二中，你可以调用<code>setParent</code>，<code>insertBefore</code>或<code>appendChild</code>方法来使其成为另外一个的子组件，那么属于同一页面的子组件将会属于父组件所属于的页面。</para>
<para>同样，你可以通过调用<code>setPage</code>方法并将其参数设为<code>null</code>将一个根组件从页面卸载。当一个子组件从父 组件被卸载或其父组件从页面被卸载时，此组件被卸载。</para></sect2><sect2><title>Identifiers</title>
<para>每个组件都有一个标识(可利用<code>getId</code>方法获得)，当一个组件被创建时它被自动创建。开发人员可以在任何时候改变它。对于标识如何命名并没有限制。但是，如果一个字母标识(alphabetical identifier)被指定之后，开发人员可以通过Java代码或 嵌入到ZUML页面的EL表达式直接读取到它。</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;Do you like ZK? &lt;label id="label"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;separator/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Yes" onClick="label.value = self.label"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="No" onClick="label.value = self.label"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>UUID</title>
<para>一个组件有另外一个称为UUID的标识，但应用程序开发人员很少用到它。</para>
<para>UUID是被组件和客户端引擎用来操纵浏览器端的DOM以及和服务器进行通信的。更确切地说，客户端DOM元素的id属性就是UUID。</para>
<para>当一个组件被创建时，UUID会自动产生。除了用以呈现HTML标签的组件标识，它是一成不变的。</para>
<para>相关的HTML组件处理UUID的方式不同于其他的一套组件：UUID就像ID一样。如果你改变一个HTML相关组件的ID，UUID就会跟着改变。因此原来的JavaScript 代码和servlets 将会继续工作，而无需任何修改。</para></sect2></sect1><sect1><title>ID空间 </title>
<para>将视觉表现(visual representation)分为几个ZUML页面是很常见的。例如，一个页面用来展示订购单，一个对话框用于进入付款期。如果同一个桌面内所有的组件都是非常明确的，开发人员必须为这个桌面内所有页面维护所有标识的唯一性。为了解决这个问题，ID空间的概念被引入。一个ID空间是一个桌面的组件的子集。唯一性只在ID空间的范围内有保障。</para>
<para>Id空间的最简单形式是一个window(<code>org.zkoss.zul.Window</code>)。所有window衍生出来的组件(包括window)形成了一个独立的ID空间。因此，你可以将window作为每个页面的最高组件使用，这样，开发人员需要维护每个页面的唯一性。</para>
<para>更一般地说，任何组件可形成一个ID空间，只要它实现了<code>org.zkoss.zk.ui.IdSpace</code>接口。页面(Page)也实现了这个接口，所以它又是个空间所有者(space owner)。</para>
<para>一个ID空间的最高组件即为空间的所有者，可以使用<code>Component</code>接口中的<code>getSpaceOwner</code>方法来获得这个组件。</para>
<para>如果一个称为X的ID空间，从另外一个称为Y的ID空间衍生而来，那么X的所有者是空间Y的一部分，但从X衍生出来的部分并不是空间Y的一部分。</para>
<para>就像在图中描绘的一样，有三个空间：P，A 和C。空间P包括P，A，F和G。空间A包括A，B，C和D。空间C包括C和E。</para>

<graphic align="center"  fileref="img/3-3.png"/>

<para>在相同ID空间内的组件称为fellows，例如A，B，C和D就是同一ID空间内的fellows。</para>
<para>为了获得另一个fellow，可以使用<code>IdSpace</code>或<code>Component</code>接口中的<code>getFellow</code>方法。</para>
<para>请注意可以<code>getFellow</code>方法可以被同一ID空间内任何组件调用，并不仅限于空间所有者。同样，对于在同一空间内的任何组件，<code>getSpaceOwner</code>方法返回的是同样的对象，与是否是空间所有者无关。</para>
<para>
<code>org.zkoss.zk.ui.Path</code>类提供了在ID空间内简化定位组件的工具。其使用凡是类似<code>java.io.File</code>
</para>
<programlisting>Path.getComponent("/A/C/E");
new Path("A/C", "E").getComponent();</programlisting><sect2><title>命名空间和ID空间</title>
<para>为了能让解释器(interpreter)直接读取到组件，命名空间(<code>org.zkoss.scripting.Namespace</code>)的概 念被引入。首先，每一个ID空间都有一个确切的命名空间。第二，定义在命名空间内的变量对于属于 同一个命名空间的脚本代码及EL表达式是可见的。</para>
<programlisting>&lt;window border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;label id="l" value="hi"/&gt;&#13;<inlinegraphic align="right"  fileref="img/3-3-1.png"/>&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.value = "Hi, namespace";&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;${l.value}&#13;&lt;/window&gt;&#13;</programlisting>
<para>下面的例子有两个命名空间，一个属于window <code>w1</code>，另一个属于window <code>w2</code>。<code>b1</code>按钮的<code>onClick</code>事件针对window <code>w1</code>内定义的label，而<code>b2</code>按钮的<code>onClick</code>事件是针对窗口window <code>w2</code>
<footnote>
<para>window 实现了 <code>org.zkoss.zk.ui.IdSpace</code>, 所以它形成了一个独立的ID空间和命名空间。</para>
</footnote>内的定义的checkbox。</para>
<programlisting>&lt;window id="w1"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;window id="w2"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label id="c"/&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/window&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;checkbox id="c"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button id="b2" onClick="c.label = &amp;quot;OK&amp;quot;"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>请注意命名空间是有等级的。换言之，window <code>w2</code>中的<code>zscript</code>可以看见window <code>w1</code>中的组件，除非她凌驾于window <code>w2</code>。因此，在下面的例子中button <code>b1</code>将会改变标签<code>c</code>。</para>
<programlisting>&lt;window id="w1"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;window id="w2"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/window&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;label id="c"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>除了ZK指定的添加到命名空间的组件，你可以指定自己的变量通过使用<code>setVariable</code>方法，这样 <code>zscript</code>可以直接参考(reference)它们。</para></sect2><sect2><title>在<code>zscript</code>中定义变量和函数</title><para>除了执行代码,你可以在<code>zscript</code>元素中直接定义变量和函数，就像下面描绘的一样:</para>
<programlisting>&lt;window id="A&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object myvar = new LinkedList();&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void myfunc() {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;...&#13;&nbsp;&nbsp;&nbsp;&lt;button label="add" onClick="myvar.add(some)"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="some" onClick="myfunc()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>在<code>zscript</code>中定义的变量和函数存储在相应脚本语言的解释器(interpreter )中。</para><sect3><title>
<code>zscript</code>和<code>EL</code>表达式</title>
<para>就像命名空间<footnote>
<para>
<code>org</code>
<code>.zkoss.zk.scripting.Namespace</code>
</para>
</footnote>一样，定义在<code>zscript</code>中的变量对于EL表达式都是可见的。</para>
<programlisting>&lt;window&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;String var = "abc";&#13;
&nbsp;&nbsp;&nbsp;self.setVariable("var2", "xyz", true);
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;${var} ${var2}&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;&#13;abc xyz&#13;&lt;/window&gt;&#13;</programlisting>
<para>请注意，定义在<code>zscript</code>中的变量比定义在命名空间中的变量有更高的优先级。</para>
<programlisting>&lt;window&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;String var = "abc";&#13;&nbsp;&nbsp;&nbsp;self.setVariable("var", "xyz", true);&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;${var}&#13;&lt;/window&gt;&#13;</programlisting>
<para>等价于：</para>
<programlisting>&lt;window&gt;
abc
&lt;/window&gt;</programlisting>
<para>但如果你之后声明了一个同名组件，这就会令人困惑，就像下面展示的那样。</para>
<programlisting>&lt;window&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;String var = "abc";&#13;
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;label id="var" value="A label"/&gt;
&nbsp;&nbsp;&nbsp;${var.value} &lt;!-- Wrong! var is "abc", not the label --&gt;
&lt;/window&gt;</programlisting>
<para>因此，建议使用一些命名方式来避免这种困惑。例如，你可以为所有的解释(interpreter)变量加上前缀<code>zs_</code>。</para>
<para>另外，应该尽量使用局部变量。局部变量是和类名一起被声明的，并且只对某一范围的<code>zscript</code>代码可见。</para>
<programlisting>&lt;zscript&gt;&#13;Date now = new Date();&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>你可以通过将其放在{}中使局部变量对于EL表达式不可见，如下：</para>
<programlisting>&lt;zscript&gt;&#13;
{ //create a new logic scope
&nbsp;&nbsp;&nbsp;String var = "abc"; //visible only inside of the enclosing curly brace&#13;
}
&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>多范围(Multi-Scope)的解释器</title><para>依靠实现，一个解释器或许有确切的范围，或每个ID空间一个逻辑范围来存储这些变量和方法。出于 以上的描述，我们将它们分别称为单范围和多范围的解释器(single-scope and multi-scope interpreters)。</para>
<para>Java解释器(BeanShell)是一个典型的多范围解释器。<footnote>
<para>Java 解释器支持多范围(multi-scope )在 2.3.1 (包括)之后及2.2.1 (包括)之前</para>
</footnote>。它为每个ID空间创建一个独立的解释范围。例如，在下面的例子中分别为window <code>A</code>和<code>B</code>创建两个逻辑范围。因此在下面的例子中，<code>var2</code>仅对于window <code>B</code>是可见的，<code>var1</code>对于窗口<code>A</code>和<code>B</code>都是可见的。</para>
<programlisting>&lt;window id="A"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;var1 = "abc";&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;var2 = "def";&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/window&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect4><title>Java解释器(BeanShell)</title>
<para>通过Java解释器，你可以为一个最近ID空间(例如一个窗口window)的逻辑范围声明一个局部解释变量(interpreter variable)通过指定类名，如下例所示：</para>
<programlisting>&lt;window id="A"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;String b = "local to window B";&#13;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;/window&gt;
&lt;/window&gt;</programlisting>
<para>下面是一个更复杂的例子，可以产生<code>abc def</code>。</para>
<programlisting>&lt;window id="A"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;var1 = var2 = "abc";&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;window id="B"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;Object var1 = "123";&#13;&nbsp;&nbsp;&nbsp;var2 = "def";&#13;&nbsp;&nbsp;&nbsp;var3 = "xyz";&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/window&gt;&#13;&nbsp;&nbsp;&nbsp;${var1} ${var2} ${var3}&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>Object var1 =</code>"<code>123</code>"实际上是为window <code>B</code>创建了一个局部变量，对象是指定的。另一方面，<code>var2 =</code>"<code>def</code>"会使解释器(interpreter)在当前或更高的范围内寻找名称为<code>var2</code>的变量。<code>var2</code>变量在window <code>A</code>内已被定义，变量在此被重定义(overrided)。<code>var3 =</code>"<code>xyz</code>
<code>"</code>为窗口(winodw)<code>B</code>创建了一个局部变量，而window <code>A</code>并没有定义任何叫做<code>var3</code>的变量。</para></sect4></sect3><sect3><title>单范围(Single-Scope)解释器</title>
<para>Ruby, Groovy 和javaScript解释器(Interpreters)并不支持多范围<footnote>
<para>在不久的将来我们或许会支持。</para>
</footnote>。这就意味着定义的所有变量，就是说， Ruby存储在一个逻辑范围内(每一个解释器)。因此，定义在一个窗口中的解释变量(interpreter variables)会覆盖定义在另一个窗口中的变量，如果它们在同一个页面内。为了避免这种困惑，你可以为每个变量的名字加上与窗口相关的特殊前缀。</para>
<para>[提示]:每个页面都有它自己的解释器(interpreter)来为zscript代码赋值，如果一个桌面有多个页面，那么它或许有多个解释器的实例(instances of the interpreters)(每一种脚本语言)。</para></sect3><sect3><title>在一个页面中使用多种脚本语言</title>
<para>每种脚本语言都与一种解释器(interpreter)相关联。因此，定义在一种语言中的变量和方法对于另外一种语言是不可见的。例如在下面的例子中，变量<code>var</code>
<code>1</code>和<code>var2</code>属于两种不同的解释器(interpreter)。</para>
<programlisting>&lt;zscript language="Java"&gt;&#13;&nbsp;&nbsp;&nbsp;var1 = 123;&#13;&lt;/zscript&gt;&#13;&lt;zscript language="JavaScript"&gt;&#13;&nbsp;&nbsp;&nbsp;var2 = 234;&#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>
<code>getVariable</code>VS <code>getZScriptVariable</code>
</title>

<para>可以通过<code>getVariable</code>方法获得定义在命名空间内的变量。另一方面，定义在<code>zscript</code>中的变量是解释它的解释的一部分，它们不是任何命名空间的一部分。换句话说，你不能通过<code>getVariable</code>方法获取它。</para>
<para>你必须使用<code>getZScriptVariable</code>方法来获得<code>zscript</code>中的定义的变量。同样，可以使用<code>getZScriptClass</code>和<code>getZScriptMethod</code>方法来获取定义在<code>zscript</code>中的类和方法。这些方法将会遍历所有的被加载的解释器直到指定的一个被找到。</para>
<para>如果你想找到某个解释器，可以使用<code>getInterpreter</code>方法先获得解释器，就像下面一样：</para>
<programlisting>&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;var1 = 123; //var1 belongs to the interpreter, not any namespace
&nbsp;&nbsp;&nbsp;page.getVariable("var1"); //returns null
&lt;/zscript&gt;</programlisting>
<para>相反，你必须使用<code>getZScriptVariable</code>方法来获得<code>zscript</code>中的定义的变量。同样，可以使用<code>getZScriptClass</code>和<code>getZScriptMethod</code>方法来获取定义在<code>zscript</code>中的类和方法。这些方法将会遍历所有的被加载的解释器(interpreter)知道指定的一个被找到。</para>
<para>如果你想找到某个解释器，可以使用<code>getInterpreter</code>方法先获得解释器，就像下面一样：</para>
<programlisting>page.getInterpreter("JavaScript").getVariable("some"); //interpreter for JavaScript&#13;
page.getInterpreter(null).getVariable("some"); //interpreter for default language</programlisting></sect3></sect2></sect1><sect1><title>事件</title>
<para>事件(<code>org.zkoss.zk.ui.event.Event</code>)用来通知服务器发生了什么。每种类型的事件都由一种不同的类来表示。例如，<code>org.zkoss.zk.ui.event.MouseEvent</code>来代表鼠标活动，如点击。</para>
<para>为了响应事件，服务器需要为其注册一个或多个事件监听器。由两种方法来注册一个事件监听器。一种是通过在标记语言中指定<code>onXxx</code>属性。另一种方法是为你要监听的组件或页面调用<code>addEventListener</code>方法。</para>
<para>除了在浏览器端由客户活动触发的事件，一个应用程序可以<code>org.zkoss.zk.ui.event.Events</code>类中的<code>sendEvent</code>和<code>postEvent</code>方法来触发事件。</para></sect1><sect1><title>桌面和事件处理</title>
<para>如上所述，桌面是页面的集合，这些页面服务于同样的URL请求。一个桌面当然是事件监听器能读取的范围。</para>
<para>当一个事件被触发时，它就和桌面联系在一起。ZK分离基于关联桌面及流水事件(pipelines events)分成单独的队列。因此，同一桌面的事件可以被顺序处理。另一方面，不同桌面的事件可以被并行处理。</para>
<para>一个事件监听器是被允许读取事件关联桌面内任何页面的任何组件的。它也被允许将一个组件从一个页面移到另一个页面，只要这些页面在同一桌面内。另一方面，它不能读取到其它桌面的组件。</para>
<para>[注]: 开发人员可以在一个事件监听器中将一个组件从一个桌面卸载，然后在另外的事件监听器中将其添加到另外一个桌面。</para><sect2><title>桌面及创建组件</title>
<para>当一个组件在一个事件监听器中被创建时，它就自动被分配到被处理的事件相关联的桌面。即使组件不属于一个页面这种分配也会发生。这就意味着你在事件监听器中创建的任何组件可以用于监听正在处理的同一桌面。</para>
<para>如果一个组件是在一个线程(thread)而不是任何事件监听器中创建的话，它就不属于任何桌面。在这种情况下，可以将它添加到任何一个桌面，只要添加发生在一个合适的监听程序中。当然，一旦组件被添加到一个桌面，它就一直属于这个桌面。</para>
<para>对于大多数应用程序而言，很少在线程(thread)而不是事件监听器中创建组件。然而，如果有一个长操作(long operation)，你或许会在后台线程(background thread)中执行它。那么，你可以在后台准备一些组件树，然后在合适的事件被接收时将它们添加到桌面。关于此的详细信息，请参考事件监听和处理(Event Listening and Processing)中关于长操作(Long Operations)的部分。</para></sect2></sect1><sect1><title>ZUML 和XML命名空间</title><para>ZK用户界面标记语言(ZK User Interface Markup Language，ZUML)是一套基于XML的语言，开发人员可以用它来描述视觉表现。ZK的目标是分离出一套独立的组件一供使用。换句话说，一套不同的组件<footnote>
<para>亦称为标签(tags)。 在组件与标签之间有一对一的映射。</para>
</footnote>，就像XUL和XHTML，可以同时在同一ZUML页面内使用。不同的标记语言可以被透明地添加。如果两套或更多的组件在同一页面内被使用，开发人员必须使用XML命名空间来区分它们。请参考 ZK用户界面标记语言(ZK User Interface Markup Language )一章中关于组件集合XML命名空间(Component Sets and XML Namespaces)的部分，如果你想在同一页面中使用多套组件，就像XUL和XHTML。</para>
<para>[提示]:在ZUML中使用XML命名空间是可选的，你只有在使用多套组件时会用到它。</para></sect1></chapter><chapter><title>组件活动周期</title><para>本章描述了加载页面和更新页面的活动周期。</para><sect1><title>加载页面的活动周期</title>
<para>ZK加载器(ZK loader)加载并解释页面需要经历四个阶段：页面初始阶段，组件创建阶段，事件处理阶段及响应阶段(the Page Initial Phase, the Component Creation Phase, the Event Processing Phase, and the Rendering Phase)。</para><sect2><title>页面初始阶段</title>
<para>在这个阶段，ZK处理处理指令，被称为初始化(<code>init</code>)。如果并没有定义这样的处理指令，此阶段会被跳过。</para>
<para>对于每个<code>init</code>处理指令都有一个<code>class</code>属性，一个指定类的实例(instance)将会被创建，然后它的<code>doInit</code>方法将会被调用。当然，这个类要做什么取决于你的应用程序的需求。</para>
<programlisting>&lt;?init class="MyInit"?&gt;&#13;</programlisting>
<para>初始处理指令的另一种形式是使用<code>zscrtpt</code>属性指定包含脚本代码的文件如下。那么在页面初始阶段这个文件将会被解释。</para>
<programlisting>&lt;?init zscript="/my/init.zs"?&gt;&#13;</programlisting>
<para>请注意在这个阶段页面并没有被附加到桌面。</para></sect2><sect2><title>组件创建阶段</title>
<para>在这个阶段，ZK加载器(ZK loader)解释一个ZUML页面，它创建并初始组件。这需要以下的一些步骤：</para>
<orderedlist>
<listitem>
<para>对于每个元素，它检查<code>if</code>和<code>unless</code>以确定元素是否有效。如果无效，此元素及其所有的子元素将 会被忽略。</para>
</listitem>
<listitem>
<para>如果<code>forEach</code>被指定并伴随着一个项目的集合，ZK将会为集合中的每个项目重复以下步骤。</para>
</listitem>
<listitem>
<para>基于元素名字，或使用<code>use</code>属性指定的类(如果有的话)创建一个组件。</para>
</listitem>
<listitem>
<para>基于在ZUML页面属性指定的顺序依次初始成员。</para>
</listitem>
<listitem>
<para>解释嵌套的元素(nested elements)并重复整个过程。</para>
</listitem>
<listitem>
<para>调用<code>afterCompose</code>方法如果组件实现了<code>org.zkoss.zk.ui.ext.AfterCompose</code>
<footnote>
<para>step 3-5 即所谓的composing。这是此方法称为 <code>AfterCompose</code>的原因。</para>
</footnote>接口。</para>
</listitem>
<listitem>
<para>在所有的组件都被创建后，<code>onCreate</code>事件被送到该组件，这样之后应用程序可以初始划化一些元素的内容。注意，<code>onCreate</code>事件首先为子组件公布。</para>
</listitem>
</orderedlist>
<para>[注]: 开发人员可以通过监听<code>onCreate</code>事件或实现<code>AfterCompose</code>接口来完成一些特定应用程序的初始化。<code>AfterCompose</code>在组件创建阶段(the Component Creation Phase)被调用，而<code>onCreate</code>事件是由事件监听器来处理的。一个事件监听器者可以自由地挂起或恢复执行(例如创建对话框(modal dialogs)),而由于<code>AfterCompose</code>不需要派生另一个线程， 所以它快一些。</para></sect2><sect2><title>事件处理阶段</title>
<para>在这个阶段，ZK依次调用每个事件的监听器，这些事件已经为桌面排好队列。一个独立线程开始调用监听，这样它可以在不影响其它事件处理的情况下被挂起。</para>
<para>在处理过程中，一个事件可能引发其它事件，事件监听和处理(The Event Listening and Processing)一章来获得更多细节。</para></sect2><sect2><title>响应阶段</title>
<para>在所有的事件都被处理后，ZK将这些组件组成一个规则的HTML页面并将这个页面送到浏览器。</para>
<para>为了发送一个组件，<code>redraw</code>会被调用。在这个方法中，一个组件的实现(implementation)并不会更改其它组件的内容。</para></sect2></sect1><sect1><title>更新页面的活动周期</title>
<para>ZK AU引擎处理从客户端来的ZK请求需要三个阶段：请求处理阶段，事件处理阶段及响应阶段。</para>
<para>ZK AU引擎将ZK请求传递到队列(每个桌面一个队列)。因此，来自相同桌面的请求可以被顺序处理，而来自不同桌面的请求可以被并行处理。</para><sect2><title>请求处理阶段</title>
<para>依赖于请求，ZK AU引擎可能会更新被影响组件的内容，这样它们的内容就和在客户端展示的一样。</para>
<para>然后，它将相应的事件提交到队列。</para></sect2><sect2><title>事件处理阶段</title>
<para>这个阶段和组件创建阶段中的事件处理阶段是类似的。它在独立的线程中依次处理事件。</para></sect2><sect2><title>响应阶段</title>
<para>在所有的事件都被处理后，ZK送出受影响的组件，产生相应的ZK响应，并将这些请求送回到客户端。然后，客户端引擎会基于这些响应更新浏览器端的DOM树。</para>
<para>是否重设一个组件的整个视觉表现或更新浏览器端的一个属性完全取决于组件的实现。平衡互动性与简易性，这是开发人员的工作。</para></sect2></sect1><sect1><title>模型(The Molds)</title><para>一个组件可以有不同的外观，甚至在同一页面内，这个概念被称为模型(aka., template)。通过使用<code>setMold</code>方法，开发人员可以动态的改变组件界面的模型。所有的组件都支持的模型(mold)为<code>default</code>，即默认值。一些组件可以支持两种或更多的模型。例如，<code>tabbox</code>同时支持<code>default</code>和<code>accordion</code>模型。</para>
<programlisting>&lt;tabbox&gt;&lt;!-- if not specified, the default mold is assumed. --&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;tabs&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="Default"/&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/tabs&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;tabpanels<inlinegraphic align="right"  fileref="img/4-3.png"/>&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabbox mold="accordion"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabs&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="First Accordion"/&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tab label="Second Accordion"/&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabs&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanels&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tabpanel&gt;The second panel.&lt;/tabpanel&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabpanels&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabbox&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tabpanel&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/tabpanels&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting></sect1><sect1><title>组件垃圾回收</title>
<para>不同于其它基于组件的图形用户界面(GUI)， 组件类并没有destroy 或close方法。就像W3C的DOM，当一个组件从页面被卸载时它就从浏览器被移除。它的表现就像附着在页面上一样。</para>
<para>更确切地说，一旦一个组件被卸载，如果应用程序不再涉及到它，它就不再受ZK的管理。它所占用的内存会被Java虚拟机的垃圾回收机制(JVM's garbage collector)所释放。</para></sect1></chapter><chapter><title>事件监听及处理</title><para>本章描述事件是如何被处理的。</para><sect1><title>通过标记语言添加事件监听器</title>
<para>添加一个事件监听器最简单的方法就是在一个ZUML页面内声明一个属性。用来监听的属性的值是可以被BeanShell解释的任何Java代码。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>通过程序添加或移除事件监听器</title>
<para>有两种方法通过程序添加或移除事件监听器。</para><sect2><title>声明一个成员</title>
<para>当用你自己的类重定义(overriding)一个组件后，你可以声明一个成员函数成为事件监听器。</para>
<para>在一个ZUML页面中，你可以使用<code>use</code>属性来指定你想使用的类，即用它去替换默认类。如下所示，它使用了MyClass来替换默认的<code>org.zkoss.zul.Window</code>
<footnote>
<para>默认的类定义在 in zul.jar中的lang.xml .</para>
</footnote>。</para>
<programlisting>&lt;window use="MyClass"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>然后你淂实现MyWindow.java同过继承默认的类，就像下面一样:</para>
<programlisting>public class MyWindow extends org.zkoss.zul.Window {&#13;&nbsp;&nbsp;&nbsp;public void onOK() { //add an event listener&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//handles the onOK event (sent when ENTER is pressed)&#13;&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting>
<para>如果你想获得关于事件的更多信息，你可以按如下方式声明：</para>
<programlisting>public void onOK(org.zkoss.zk.ui.event.KeyEvent event) {
...
}&#13;</programlisting>
<para>不同的事件或许与不同的事件对象相关联。参考附录C(Append C)来获取更多的细节。</para></sect2><sect2><title>动态地添加与移除事件监听器</title>
<para>开发人员可以使用<code>org.zkoss.zk.ui.Component</code>接口中的<code>addEventListene</code>和<code>removeEventListener</code>方法来动态地添加或移除事件监听器。如下所示，动态添加的事件监听器必须实现<code>org.zkoss.zk.ui.event.EventListener</code>接口。</para>
<programlisting>void init(Component comp) {&#13;&nbsp;&nbsp;&nbsp;...&#13;&nbsp;&nbsp;&nbsp;comp.addEventListener("onClick", new MyListener());&#13;&nbsp;&nbsp;&nbsp;...&#13;}&#13;class MyListener implements org.zkoss.zk.ui.event.EventListener {&#13;&nbsp;&nbsp;&nbsp;public void onEvent(Event event) throws UiException {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//processing the event&#13;&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting></sect2><sect2><title>延期事件监听器</title>
<para>默认情况下，当客户端的事件被触发时就会被送到服务器。但是，许多事件仅用于维持服务器端的现状，而不是向客户端提供视觉响应(visual response)。换句话说，这些监听器的事件并不需要马上被送出。相反，它们应该仅被提交一次，以降低客户端和服务器端的来往，以提高服务器的性能。为求描述方便，我们称它们为延期事件监听器(Deferrable Event Listeners)。</para>
<para>为了使一个事件监听延期，必须实现<code>org.zkoss.zk.ui.event.Deferrable</code>接口(和 EventListener)并且使用<code>isDeferrable</code>方法返回true，就像下面一样。</para>
<programlisting>public class DeferrableListener implements EventListener, Deferrable {&#13;
&nbsp;&nbsp;&nbsp;private boolean _modified;
&nbsp;&nbsp;&nbsp;public void onEvent(Event event) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_modified = true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public boolean isDeferrable() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
}</programlisting>
<para>当客户端的一个事件(例如，选择一个列表项目(list item))被触发时，如果没有为其注册事件监听器或仅有延期(deferrable)的监听器被注册，ZK不会将事件送出。</para>
<para>一方面，如果至少有一个非延期(non-deferrable)监听器，事件会被马上送到服务器端，和所有的队列事件(queued events)一起。没有事件会丢失，到达顺序是保存好的。</para>
<para>[提示]:当有非延期监听器为用户提供视觉响应，可以使用使用延期的(deferrable)事件监听器维持(maintaining)服务器状态。</para></sect2><sect2><title>为页面动态地添加和移除事件监听器</title>
<para>开发人员可以为页面(<code>org.zkoss.zk.ui.Page</code>)动态地添加和移除事件监听器。一旦被添加，所有被指定名字的事件会被送到指定页面的任何组件，这些页面将会被送到监听器。 </para>
<para>所有的页面级(page-level)事件监听器都是非即时。换言之，<code>isArap</code>方法被忽略了。</para>
<para>一个典型的例子是使用页面级事件监听器来维护修改标志(modification flag)，如下：</para>
<programlisting>public class ModificationListener implements EventListener, Deferrable {&#13;&nbsp;&nbsp;&nbsp;private final Window _owner;&#13;&nbsp;&nbsp;&nbsp;private final Page _page;&#13;&nbsp;&nbsp;&nbsp;private boolean _modified;&#13;&#13;&nbsp;&nbsp;&nbsp;public ModificationListener(Window owner) {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Note: we have to remember the page because unregister might&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//be called after the owner is detached&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_owner = owner;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page = owner.getPage();&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onChange", this);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onSelect", this);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.addEventListener("onCheck", this);&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;/** Called to unregister the event listener.&#13;&nbsp;&nbsp;&nbsp;&nbsp;*/&#13;&nbsp;&nbsp;&nbsp;public void unregister() {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onChange", this);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onSelect", this);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_page.removeEventListener("onCheck", this);&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;/** Returns whether the modified flag is set.&#13;&nbsp;&nbsp;&nbsp;&nbsp;*/&#13;&nbsp;&nbsp;&nbsp;public boolean isModified() {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _modified;&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;//-- EventListener --//&#13;&nbsp;&nbsp;&nbsp;public void onEvent(Event event) throws UiException {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_modified = true;&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;//-- Deferrable --//&#13;&nbsp;&nbsp;&nbsp;public boolean isDeferrable() {&#13;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
}&#13;</programlisting>
<para>[注]: 在事例中是否实现<code>Deferrable</code>接口是可选的，因为页面的事件监听器总是假定为延期的，与是否实现<code>Deferrable</code>接口无关。</para></sect2><sect2><title>调用顺序</title>
<para>调用事件监听器的顺序如下。假定接收的是<code>onClick</code>事件。</para>
<orderedlist>
<listitem>
<para>如果监听器实现了<code>org.zkoss.zk.ui.event.Express</code>接口，依次为添加到目标组件(targeting component)的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
<listitem>
<para>调用目标组件的<code>onClick</code>属性指定的脚本语言。</para>
</listitem>
<listitem>
<para>如果监听器没有实现<code>org.zkoss.zk.ui.event.Express</code>接口，依次为添加到目标组件的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
<listitem>
<para>调用目标组件的<code>onClick</code>成员方法。</para>
</listitem>
<listitem>
<para>依次为添加到目标组件所属页面的的<code>onClick</code>事件调用事件监听器。按照添加的顺序调用。</para>
</listitem>
</orderedlist>
<para>
<code>org.zkoss.zk.ui.event.Express</code>接口是一个装饰器(decorative interface)，用来改变调用事件监听器的优先级。注意，如果事件监听器被添加到页面，而不是组件，这个接口是没有意义的。</para></sect2><sect2><title>中止调用序列</title>
<para>你可以通过调用<code>org.zkoss.zk.ui.event.Event</code>类中的<code>stopPropagation</code>方法来中止调用序列。一旦事件监听器调用了这个方法，之后所有的事件监听器将会被忽略。</para></sect2></sect1><sect1><title>事件监听器提交和发送事件</title>
<para>除了接收事件，一个应用程序可以在事件监听器间通信通过向他们发送和提交事件。</para><sect2><title>提交事件</title>
<para>通过使用<code>org.zkoss.zk.ui.event.Events</code>类中的<code>postEvent</code>方法，一个事件监听器可以把事件提提交到事件队列的末尾。将事件放到队列中后立即返回。当这个事件之前的所有事件都被处理完毕后，该事件就会被处理。</para></sect2><sect2><title>发送事件</title>
<para>通过使用<code>org.zkoss.zk.ui.event.Events</code>类中的<code>sendEvent</code>方法，一个事件监听器可以使ZK马上处理指定的事件。当指定事件的事件监听器都被处理完毕后才返回。事件是在相同的线程内被处理的。</para></sect2></sect1><sect1><title>线程(Thread)模型</title>
<para>对于每个桌面，事件总是被顺序处理的，所以线程模型是很简单的。就像开发桌面应用程序一样，你不需要担心racing和多线程(multi-threading)。所有你需要做的就是注册一个事件监听器且事件被调用时处理它。</para>
<para>[提示]:当一个ZUML页面在servlet线程中被赋值时，每一个事件监听器都在一个被称为事件处理线程的独立线程中运行。</para>
<para>[提示]:事件处理线程的使用可以被禁止，这样所有的线程都可以在Servlet线程中被处理。这样有更好一点的表现并且减少集成的问题。但是，你不能中止执行。参考高级功能(Advanced Features)一章中关于处理事件的Servlet线程(Servlet Thread to Process Events)的部分。</para><sect2><title>挂起及恢复</title>
<para>为了高级的应用，你或许必须挂起一个执行直到一些条件被满足，<code>org.zkoss.zk.ui.Executions</code>类中的<code>wait</code>，<code>notify</code>和<code>notifyAll</code>方法都是为这样的目的而设计的。</para>
<para>当一个事件监听器想挂起自己，它可以调用<code>wait</code>。如果申请的具体条件得到满足，另一个线程可以通过<code>notify</code>和<code>notifyAll</code>方法唤醒它。对话框是使用这种机制的典型例子。</para>
<programlisting>public void doModal() throws InterruptedException {&#13;...
&nbsp;&nbsp;&nbsp;Executions.wait(_mutex); //suspend this thread, an event processing thread
}&#13;public void endModal() {&#13;...&#13;&nbsp;&nbsp;&nbsp;Executions.notify(_mutex); //resume the suspended event processing thread&#13;}&#13;</programlisting>
<para>它们的使用类似于<code>java.lang.Object</code>中的<code>wait</code>，<code>notify</code>和<code>notifyAll</code>方法。但是，你不能使用<code>java.lang.Object</code>中的方法来挂起和恢复事件监听器。否则，关联到这个桌面的所有的事件处理都会停滞。</para>
<para>请注意，不同于Java的<code>Object</code>类的<code>wait</code>和<code>notify</code>方法，是否使用同步的<code>synchronized</code> block来包<code>Executions</code>的<code>wait</code>和<code>notify</code>是可选的。在上述情况下中，我们并不需要这样做，因为没有可能的racing问题。但是，如果存在这样的racing问题，你可以使用<code>synchronized</code> block，就像在Java <code>Object</code>的<code>wait</code>和<code>notify</code>中使用那样。</para>
<programlisting>//Thread 1&#13;public void request() {&#13;
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;synchronized (mutex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//start another thread
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.wait(mutex); //wait for its completion
&nbsp;&nbsp;&nbsp;}
}

//Thread 2
public void process() {
&nbsp;&nbsp;&nbsp;... //process it asynchronously
&nbsp;&nbsp;&nbsp;synchronized (mutex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.notify(mutex);
&nbsp;&nbsp;&nbsp;}
}</programlisting></sect2><sect2><title>长操作(Long Operations)</title><para>对于同一个桌面而言，事件是被顺序处理的。换言之，一个事件的处理程序可以阻塞所有的后继处理程序。如果一个事件处理程序要花费大量的时间，阻塞用户请求的时间可能是不可接受的。就像桌面应用程序那样，你需要为这种长操作(Long Operations)创建一个工作线程以减少阻塞时间。</para>
<para>限于HTTP协议，你必须遵守以下规则：</para>
<orderedlist>
<listitem>
<para>创建工作线程后，使用<code>org.zkoss.zk.ui.Executions</code>类的<code>wait</code>方法来挂起事件处理程序本身。</para>
</listitem>
<listitem>
<para>由于工作线程不是一个事件监听器，所以它不能读取任何组件，除非这个组件不属于任何桌面。因此在开始工作线程之前你可能需要手动添加(pass)一些必要信息。</para>
</listitem>
<listitem>
<para>然后，若有必要的话，工作线程可以取出信息，并且创建组件。只是不引用属于任何桌面的任何组件。</para>
</listitem>
<listitem>
<para>工作线程完成之后，在工作线程中使用<code>org.zkoss.zk.ui.Executions</code>类中的<code>notify(Desktop desktop，Object flag)</code>或 <code>notifyAll(Desktop desktop，Object flag)</code>方法来恢复事件处理程序。</para>
</listitem>
<listitem>
<para>直到另一个事件从客户端被发送过来，恢复的事件处理程序才会执行。为了强制发送一个组件，你可以使用timer组件(<code>org.zkoss.zul.Timer</code>)触发事件片刻之后或定期的。这个timer 的事件监听器可以不做任何事情或更改进展状况。</para>
</listitem>
</orderedlist><sect3><title>事例：一个异步产生标签的工作线程</title>
<para>假定我们以异步的方式创建标签。当然，用多线程来做这么小的事是没有意义的，但是我们可以用更复杂的(sophisticated)任务来代替这个。</para>
<programlisting>//WorkingThread&#13;package test;&#13;public class WorkingThread extends Thread {
&nbsp;&nbsp;&nbsp;private static int _cnt;

&nbsp;&nbsp;&nbsp;private Desktop _desktop;
&nbsp;&nbsp;&nbsp;private Label _label;
&nbsp;&nbsp;&nbsp;private final Object _mutex = new Integer(0);

&nbsp;&nbsp;&nbsp;/** Called by thread.zul to create a label asynchronously.
&nbsp;&nbsp;&nbsp;&nbsp;* To create a label, it start a thread, and wait for its completion.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public static final Label asyncCreate(Desktop desktop)
&nbsp;&nbsp;&nbsp;throws InterruptedException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final WorkingThread worker = new WorkingThread(desktop);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (worker._mutex) { //to avoid racing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.wait(worker._mutex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return worker._label;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public WorkingThread(Desktop desktop) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_desktop = desktop;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label = new Label("Execute "+ ++_cnt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (_mutex) { //to avoid racing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executions.notify(_desktop, _mutex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}&#13;</programlisting>
<para>然后，在一个事件监听器中，我们使用ZUML页面来调用这个工作线程，如在<code>onClick</code>事件中。</para>
<programlisting>&lt;window id="main" title="Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;timer.start();
&nbsp;&nbsp;&nbsp;Label label = test.WorkingThread.asyncCreate(desktop);
&nbsp;&nbsp;&nbsp;main.appendChild(label);
&nbsp;&nbsp;&nbsp;timer.stop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;timer id="timer" running="false" delay="1000" repeats="true"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>注意到我们必须使用timer来真正地恢复被挂起的事件监听器(<code>onClick</code>)。这看起来是多余的，但是由于HTTP的限制：为了保持Web页面在浏览器端的活跃，当事件处理程序被挂起时我们必须返回响应。然后，工作线程完成了工作并唤醒了事件监听器，HTTP请求已经不在了。因此，我们需要一种方式来”捎带(piggyback)”这个结果，而这就使timer为什么会被使用的原因。</para>
<para>更确切地说，当工作线程唤醒一个事件监听器时，ZK只是把它加到一个等待列表。当另一个HTTP请 求到达时，监听器才真正恢复(如上面例子中的<code>onTimer</code>事件)。</para>
<para>在这个简单的事例中，我们并没有为<code>onTimer</code>事件作任何事情。对于一个复杂的应用程序，你可以用它来返回处理状态。</para></sect3><sect3><title>选择 1: Timer(没有挂起/恢复)</title>
<para>无需挂起和恢复来实现一长操作(long operation)是由可能的。这在同步代码(synchronization codes)对于调试来说太复杂的情况下是很有用的。</para>
<para>注意是很简单的。工作线程将结果保存在一个临时空间，然后使用<code>onTimer</code>事件将结果弹到(pops)桌面。</para>
<programlisting>//WorkingThread2&#13;package test;&#13;public class WorkingThread2 extends Thread {
&nbsp;&nbsp;&nbsp;private static int _cnt;

&nbsp;&nbsp;&nbsp;private final Desktop _desktop;
&nbsp;&nbsp;&nbsp;private final List _result;

&nbsp;&nbsp;&nbsp;public WorkingThread2(Desktop desktop, List result) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_desktop = desktop;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_result = result;
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_result.add(new Label("Execute "+ ++_cnt));
&nbsp;&nbsp;&nbsp;}
}&#13;</programlisting>
<para>然后，在<code>onTimer</code>事件监听器上附加标签。</para>
<programlisting>&lt;window id="main" title="Working Thread2"&gt;
&nbsp;&nbsp;&nbsp;&lt;zscript&gt;
&nbsp;&nbsp;&nbsp;int numPending = 0;
&nbsp;&nbsp;&nbsp;List result = Collections.synchronizedList(new LinkedList());
&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;
&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;
&nbsp;&nbsp;&nbsp;++numPending;&nbsp;&nbsp;&nbsp;timer.start;
&nbsp;&nbsp;new test.WorkingThread2(desktop, result).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/button&gt;
&nbsp;&nbsp;&nbsp;&lt;timer id="timer" running="false" delay="1000" repeats="true"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onTimer"&gt;
&nbsp;&nbsp;&nbsp;while (!result.isEmpty()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.appendChild(result.remove(0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--numPending;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (numPending == 0) timer.stop();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;
&nbsp;&nbsp;&nbsp;&lt;/timer&gt;
&lt;/window&gt;</programlisting></sect3><sect3><title>选择 2：捎带(piggyback)(没有挂起/恢复，没有Timer)</title>
<para>当用户，例如，点击一个按钮或输入一些东西时，你可以将结果捎带(piggyback)到客户端，而不必循环地检查它们。</para>
<para>为了完成捎带(piggyback)，你需要为一个根组件注册一个<code>onPiggyback</code>事件监听器。然后每次ZK更新引擎(ZK Update Engine)处理事件时，这个监听器将会被调用。例如，你可以按如下的方式重写代码。</para>
<programlisting>&lt;window id="main" title="Working Thread3" onPiggyback="checkResult()"&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;zscript&gt;&#13;&nbsp;&nbsp;&nbsp;List result = Collections.synchronizedList(new LinkedList());&#13;&#13;&nbsp;&nbsp;&nbsp;void checkResult() {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!result.isEmpty())&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.appendChild(result.remove(0));&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;&lt;/zscript&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;button label="Start Working Thread"&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="onClick"&gt;&#13;&nbsp;&nbsp;&nbsp;timer.start();&#13;&nbsp;&nbsp;&nbsp;new test.WorkingThread2(desktop, result).start();&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/button&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>捎带(piggyback)方式的优点是客户端与服务器端没有额外的往来。但是，如果用户没有任何活动(如点击或打字)的话是无法看到更新的。这种方式是否合适取决于应用程序的要求。</para>
<para>[注]: 一个延期的事件(deferrable)不会马上被送到客户端，所以，只有一个非延期的事件被触发后<code>onPiggyback</code>事件才会被触发。请参考关于延期事件监听器(Deferrable Event Listeners)的部分获得详细信息。</para></sect3></sect2></sect1><sect1><title>初始与清理事件处理线程</title><sect2><title>处理每个事件前的初始化</title>
<para>一个事件监听器是在一个事件处理线程中执行的。有时，你必须在处理所有事件前初始该线程。</para>
<para>一个典型的例子是初始化认证所使用的线程。一些J2EE或Web容器将认证信息存储在局部存储器(local storage)线程中。这样，可以在需要的时候自动进行重复验证。</para>
<para>为了初始化事件处理线，必须在<code>WEBINF/zk.xml</code>文件<footnote>
<para>the Developer's Reference 的附录(Appendix B) 进行了详细描述。</para>
</footnote>的<code>listener</code>元素中注册一个是实现了<code>org.zkoss.zk.ui.event.EventThreadInit</code>接口的类。</para>
<para>一旦注册完毕，一个指定类的实例就会在主线程中被创建。然后，在处理其他事情之前，该实例的<code>init</code>方法就会在事件处理线程的上下文中被调用。</para>
<para>请注意构造程序(constructor)和<code>init</code>方法是在不同的线程中被调用的，因此开发人员可以从一个线程取得独立线程数据并传送给另外一个线程。</para>
<para>这里有一个 JBoss<footnote>
<para>http://www.jboss.org</para>
</footnote>的认证机制。在这个例子中，我们在构造程序中获取存储在Servlet线程中的信息。然后当<code>init</code>方法被调用时初始事件处理线程。</para>
<programlisting>import java.security.Principal;&#13;import org.jboss.security.SecurityAssociation;&#13;import org.zkoss.zk.ui.Component;&#13;import org.zkoss.zk.ui.event.Event;&#13;import org.zkoss.zk.ui.event.EventThreadInit;&#13;&#13;public class JBossEventThreadInit implements EventThreadInit {&#13;&nbsp;&nbsp;&nbsp;private final Principal _principal;&#13;&nbsp;&nbsp;&nbsp;private final Object _credential;&#13;&nbsp;&nbsp;&nbsp;/** Retrieve info at the constructor, which runs at the servlet thread. */&#13;&nbsp;&nbsp;&nbsp;public JBossEventThreadInit() {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_principal = SecurityAssociation.getPrincipal();&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_credential = SecurityAssociation.getCredential();&#13;&nbsp;&nbsp;&nbsp;}&#13;&nbsp;&nbsp;&nbsp;//-- EventThreadInit --//&#13;&nbsp;&nbsp;&nbsp;/** Initial the event processing thread at this method. */&#13;&nbsp;&nbsp;&nbsp;public void init(Component comp, Event evt) {&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityAssociation.setPrincipal(_principal);&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityAssociation.setCredential(_credential);&#13;&nbsp;&nbsp;&nbsp;}&#13;}&#13;</programlisting>
<para>然后，在<code>WEB-INF/zk.xml</code>文件中，你需要完成如下的配置：</para>
<programlisting>&lt;zk&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listener&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;JBossEventThreadInit&lt;/listener-class&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;/listener&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect2><sect2><title>处理完每个事件后清理</title>
<para>类似的，在处理完每个事件后你或许必须清理一个事件处理线程。</para>
<para>一个典型的例子是关闭事务处理，如果它没有被适时地关闭。</para>
<para>为了清理一个事件处理线程，你必须在<code>WEBINF/zk.xml</code>文件的<code>listener</code>元素中注册一个实现<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>接口的监听类。</para>
<programlisting>&lt;zk&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listener&gt;&#13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;my.MyEventThreadCleanup&lt;/listener-class&gt;&#13;&nbsp;&nbsp;&nbsp;&lt;listener&gt;&#13;&lt;/zk&gt;&#13;</programlisting></sect2></sect1></chapter></book>
