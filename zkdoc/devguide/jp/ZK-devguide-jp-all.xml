<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book lang="ja-JP">
<bookinfo>
    <title>ZK開発者ガイド</title>
	 <copyright>
      <year>2007</year>
      <holder>Potix Corporation. All rights reserved.</holder>
	</copyright>
</bookinfo>
<para>
</para>
<para/>
<chapter>
<title>1. はじめに</title>
<para>ようこそ、ウェブアプリケーションのコンテンツを豊富にする最も簡単な方法、ZKへ。</para>
<para>開発者ガイドはZKの内容と特徴が書いてあります。インストールの際にはクイックスタートガイドをご覧ください。また、操作方法と内容の詳細については開発用リファレンスを参照してください。</para>
<para>この章はウェブプログラミング・Ajax技術・ZKプロジェクトにおける現在までの流れを説明します。ZKの特徴についてすでにご存知でしたら、この章を飛ばしても構いません。</para><sect1><title>従来のウェブアプリケーション</title>
<para>効率的に簡単にウェブ上の情報を交換する目的として、Web技術、HTTPとHTMLはページをベースにした方式とステートレスモデルを基にしていました。このモデルの中では、ページは独立したものであり、クライアントとサーバーの間の最小のコミュニケーション単位でもあります。</para>
<para>
<graphic align="center" fileref="img/1.png">2
			
		</graphic>ウェブが次世代のアプリケーション進化として現れたとき、このモデルは本質的な試練に直面しました：今日のアプリケーションの中で視覚的に複雑さをあらわせないという問題です。たとえば、ユーザーに見積もりを見せるため、他のページを開いて自分の取引の記録探す、または最近の値段のページを開く、あるいは現在の株価のページを開かなければなりません。ユーザーは現在作業しているページをそのままにし、いくつものページ間を移動しなければなりません。ユーザーはページ間で簡単に迷子になるし、混乱しやすいです。結果として、ユーザーは機嫌を損ね、売り上げが落ち、生産力も下がります。</para>
<para>ページをベースにあした方式に頼る近代のアプリケーションを進化させるのは一つの挑戦で、本質に関わる問題です。このモデルではサーバー上で作動しているアプリケーションは全てを見なければいけません。リクエストに応えること、返答を送付すること、ユーザーをページと他のページに結び付ける過程を順番付けること、エラーを処理することなどです。そこでStruct・Tapestry・JSFなど多数のフレームワークが進化過程を簡単にするため開発されました。ページ方式と近代のアプリケーションとの大きな差によって、これらの構造は理解しにくいし、使うことは楽しいものではなく、簡単でも直感的なものでもありませんでした。</para></sect1><sect1><title>Ad-hoc AJAX アプリケーション</title>
<para>
<graphic align="center" fileref="img/1-2.png">2
			
		</graphic>進化期間を終えて、ウェブアプリケーションは静的なHTMLのページから動的なHTMLへと、アプレットとフラッシュへと、そして、最後にはAjax<footnote>
<para>AJAXとはJesse James Garrett氏がAjax: A New Approach to Web Applicationsで提出したものです。 </para>
</footnote>技術(非同期、JavaスクリプトとXML)まで至りました。Google マップ とSuggestによって示されているように、AJAXは対話性と返答機能を提供することにより、新しい生命をウェブアプリケーションに吹き込みました。アプレットやFlashとは違ってAJAXは標準的なブラウザとJavaScriptを基盤としており、AJAXだけのプラグインは必要ありません。</para>
<para>AJAXはDHTMLのような新しい世代です。というのはDHTMLのように、JavaScriptに深く依存しています。ユーザーの操作によって行われるイベントを監視し、ブラウザの中で動的にページ(aka.DOM)の視覚表現をうまく処理します。ページをそのままにしたり、再び送付したりすることなく、非同期でサーバーとのやり取りするを可能にすることで、更に進化をさせます。クライアントとサーバーの間の簡単なやり取りでページ方式を変えています。適切なデザインで、AJAXはデスクトップアプリケーションのように豊富な内容をウェブウェブアプリケーションに提供し、全ての内容はアプリケーションのコントロールの下、動的に更新されます。</para>
<para>AJAXでユーザーが期待する対話機能を達成するのは元々コスト高のウェブアプリケーション開発にさらに開発費用を増やします。開発者はブラウザ側でDOMを処理すると同時に、バグだらけのJavaScript APIを通してサーバーとコミュニケーションを取らなければなりません。さらに、より高度な対話を実現するため、開発者はアプリケーションデータやビジネスロジックをブラウザにコピーしますが、それによってメンテンのコストとデータ同期の難度はより高くなります。</para>
<para>結論として、リクエストの処理について、ad-hoc AJAXのアプリケーションと従来のウェブアプリケーションのとは同じです。また、開発者は依然としてページ方式とステートレスモデルによって起こるギャップを埋めなければなりません。</para></sect1><sect1><title>ZKとは？</title>
<para>ZKはイベント駆動型コンポーネントをベースにした、豊富なユーザーインターフェイスのあるウェブアプリケーションを可能にするフレームワークです。ZKはAjJaxをベースにした駆動型エンジンと豊富なXUL・XHTMLコンポーネント集とZUMLと呼ばれる(ZKユーザーインターフェースマークアップ言語)マークアップ言語を提供しています。</para>
<para>ZKの特徴のある多彩なXULとXHTMLコンポーネントでアプリケーションを表現することができます。何年間もデスクトップアプリケーションの中でしてきたように、ユーザー操作によって行われるイベントはXULとXHTMLにより処理しています。ほとんどの構成とは違い、AJAXは舞台裏の技術です。コンポーネントの同期とイベントの並行処理はZKエンジンにより自動的に行われます。</para>
<para>デスクトップアプリケーションを開発する簡単なレベルで、同じ程度の対話と応答ができます。</para>
<para>シンプルなモデルと豊富なコンポーネントに加え、ZKはZUMLと呼ばれるマークアップ言語をサポートしています。ZUMLはXHTMLのようなもので、開発者にユーザーインターフェイスをプログラムなしでデザイン可能にしています。XMLのネーム空間を用いて、ZUMLはシームレスな、異なったタグ<footnote>
<para>タグはXML要素です。コンポーネントはZUMLページが翻訳された時に生成されました。</para>
</footnote>セットを同じページに組み込むことができます。現在、ZUMLはXULとHTMLの二つのタグセットに対応しています。</para>
<para>迅速なプロトタイピングやカスタマイズ化するため、開発者はZUMLにてELまたはJava<footnote>
<para>JavaインタプリタはBeanShell (http://www.beanshell.org)を使用します。</para>
</footnote>, JavaScript<footnote>
<para>JavaScriptインタプリタはRhino (http://www.mozilla.org/rhino)を使用します。</para>
</footnote>, Ruby<footnote>
<para>RubyインタプリタはJRuby (http://jruby.codehaus.org/)を使用します。</para>
</footnote> and Groovy<footnote>
<para>GroovyインタプリタはGroovy (http://groovy.codehaus.org/)を使用します。</para>
</footnote>等のスクリプトを使用することができます。必要がなければ開発者はスクリプトを使わなくても結構です。JavaScriptがHTMLに埋め込まれているのと違って、ZKはサーバー側でスクリプトを実行します。</para>
<para>ここで全てのタスクはサーバー側で実行しているというのは開発者の立場で言ったものです。コンポーネントを開発するデベロッパーは対話とシンプルのバランスを取りながら、それぞれのタスクがサーバー側またはクライアント側いずれかで決定しなければなりません。</para></sect1><sect1><title>ZKでないものとは？</title>
<para>ZKはサーバー同士の通信と耐久性について設計したものではありません。ZKはできる限り小さく設計されています。それは、ZKはプレゼンテーション層を目的としているからです。バックエンドの技術を必要としていないし、推奨もしていません。JDBC、Hibemate、Java Mail、EJB or JＭＳなど 全てのミドルウェアーは今まで動いていたように作動します。</para>
<para>ZKはクライアントとサーバー間を通信する開発者のための通信路、RMI又は他のAPIを提供していません。なぜなら、全てのコードは同じJVMを使用し、サーバーで作動してるからです。</para>
<para>ZKは開発者にMVCや他のデザインパターンを強制的に使わせません。それを使うかどうかは開発者が選択します。</para>
<para>ZKはXULをウェブアプリケーションに提供することを目的としたフレームワークではありません。デスクトッププログラムモデルをウェブアプリケーションに提供することを目的としています。ZKは現在ではXULとXHTMLが使用可能で、将来的にはXAMLとXQueryまたは他の言語に対応することは可能です。</para>
<para>現在、ZKはAJAXを組み込んでいますが、それだけではありません。近い将来、ZKモバイルを用いて、今開発したウェブアプリケーションはそのまま<footnote>
<para>画面のサイズに合わせて調整する必要がある場合があります。 </para>
</footnote>PDA・モバイル・ゲーム等J2MEが使えるデバイスに適用できます。</para></sect1><sect1><title>ZKの制限</title>
<para>ZKは3Dゲームのような、クライアントで行われるタスクを動かすためにあるのではありません。</para>
<para>特別なコンポーネントを作らない限り、ZKはクライアント側の能力を有効に利用するアプリケーションのためにあるのではありません。</para></sect1></chapter>
<chapter>
<title>2. さあ、はじめましょう</title>
<para>この章ではどのようにZUMLページを作成するか説明しています。お時間のない方でも、必ずこの章を読んでください。</para>
<para>この章ではXULを用いてZKの要素を説明しますが、ZKで使用可能な他のマークアップ言語も使えます。</para><sect1><title>Hello World!</title>
<para>ZKをウェブサーバー<footnote>
<para>クイックスタートガイドをご覧ください。</para>
</footnote>にインストールしたら、アプリケーションを作成することは難しくありません。下の例を参考にして<footnote>
<para>本資料にある例のライブデモを見ることもできます。</para>
</footnote> 適切なディレクトリーの下に<code>hello.zul</code>ファイルを作りましょう。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;    Hello World!    &#13;&lt;/window&gt;&#13;</programlisting>
<para>そうして、間違えないように <code>http://localhost/myapp/hello.zul</code>
を参照すれば以下の結果が表示されます。
</para>
<para>
<graphic align="center" fileref="img/100000000000016B0000003225F823E1.png">2
			
		</graphic>ZUMLページの中で、XML要素はどんなコンポーネントを作るかを説明しています。この例では、ひとつのウィンドウです（<code>org.zkoss.zul.Window</code>）。XMLの属性はウィンドウコンポーネントプロパティの値を指定する際に使います。この例では、<code>title</code>と<code>boarder</code>プロパティを「Hello」と「normal」にそれぞれ設定し、ウィンドウが作られています。</para>
<para>XML要素の中で括弧を付けたテキストはラベル（<code>org.zkoss.zui.Latel</code>）と呼ばれる特別なコンポーネントとして指定されます。このようにして、上の例は下記のものと同じ内容になります。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;    &lt;label value="Hello World!"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>対話</title>
<para>いくつかの対話機能を加えてみましょう。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;
   &lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>ボタンをクリックしたら、以下のようなものが表示されます。</para>
<para>
<graphic align="center" fileref="img/2-2c.png">2
			
		</graphic>
<code>onClick</code>の機能はコンポーネントにイベントリスナを付け加えます。属性の値はJavaコードであれば何でも構いません。ZKは<code>&amp;quot</code>でダブルコーテーションマーク（”）を表現し、標準的なXMLにします。XMLをよくご存じでないなら、ZKユーザーインターフェースマークアップ言語 の章のXML セクションを見てください。</para>
<para>
<code>alert</code>ファンクションはダイアログボックスを表示するためのグローバルファンクションです。それは<code>org.zkoss.zui.Messagebox</code>クラスの<code>show</code>コマンドへのショートカットです。</para>
<programlisting>&lt;button label="Say Hello" onClick="Messagebox.show(&amp;quot;Hello World!&amp;quot;)"/&gt;&#13;</programlisting>
<para>【補足】：</para>
<itemizedlist>
<listitem>
<para>ZUMLに組み込まれているスクリプトはJava,JavaScript,Ruby,Groovyに限らずに、異なった言語で編集することができます。さらにそれらはサーバーで実行されます。</para>
</listitem>
<listitem>
<para>ZKは実行中にBeanShellを使ってJavaを翻訳します。つまり、<code>alert</code>といったグローバルファンクションを宣言することができます。同じように、ほとんどのスクリプト言語ではグローバルファンクションは簡単に定義できます。クラスを簡単に定義できる言語は少ないですが存在します。</para>
</listitem>
<listitem>
<para>
<code>ava.lang</code>
<code>、</code>
<code>java.util</code>
<code>、</code>
<code>org.zkoss</code>
<code>、</code>
<code>sk.ui</code>
<code>、</code>
<code>org.zkoss.zk.ui.event</code>
<code>、</code>
<code>org.zkoss.zuil</code>のパッケージにあるすべてのクラスはZUMLページに組み込まれているスクリプトコードを処理する前に挿入されています。</para>
</listitem>
</itemizedlist></sect1><sect1><title>
<code>zscript </code>
</title>
<para>
<code>zscript</code>はZUMLページが生成された際、処理されるスクリプトコードを定義する特別な要素です。代表的な使用方法は初期化、グローバル変数及びメソッドの宣言です。</para>
<para>【補足】：<code> </code>
<code>zscript</code>ではELを使用できません。</para>
<para>たとえば、下の例はボタンが押されるたびに、異なったメッセージを表示します。.</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;    &lt;button label="Say Hello" onClick="sayHello()"/&gt;    &#13;    &lt;zscript&gt;    &#13;    int count = 0;    &#13;    void sayHello() { //declare a global function    &#13;        alert("Hello World! "+ ++count);        &#13;    }    &#13;    &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>【補足】： <code>zscript</code>はページを読み込むときに一度だけ、翻訳します。それは大抵、初期変数とメソッドを定義します。</para><sect2><title>スクリプト言語</title>
<para>デフォルトで、スクリプト言語はJavaに設定されています。しかし、<code>language</code>属性を使えば異なった言語を選ぶことができます。なお、<code>language</code>は大文字と小文字を識別しません。</para>
<programlisting>&lt;zscript language="javascript"&gt;&#13;    alert('Say Hi in JavaScript');    &#13;    new Label("Hi, JavaScript!").setParent(win);    &#13;&lt;/zscript&gt;</programlisting>
<para>イベントハンドラのスクリプト言語を指定するために、以下のように言語名（この例では<code>javascript</code>）を前置き記述します。補足：言語名の前後にはスペースを入れてはいけません。</para>
<programlisting>&lt;button onClick="javascript: do_something_in_js();"/&gt;&#13;</programlisting>
<para>これによって、同じページに異なった言語でスクリプトを書くことができます。</para></sect2><sect2><title>別ファイルの中のスクリプト</title>
<para>コードとビューを別にするために、開発者はスクリプトコードを他のファイルに保存することができます。たとえば<code>say</code>
<code>Hello</code>
<code>.zs</code>と作り、それから、<code>src</code>属性を使いそれを参照します。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;    &lt;button label="Say Hello" onClick="sayHello()"/&gt;    &#13;    &lt;zscript src="sayHello.zs"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>sayHello.zs</code>の中身は以下のようにします。</para>
<programlisting>int count = 0;&#13;void sayHello() { //declare a global function&#13;    alert("Hello World! "+ ++count);    &#13;}&#13;</programlisting></sect2></sect1><sect1><title>
<code>attribute </code>要素</title>
<para>
<code>attribute</code>要素は要素 (ここでは<code>button</code>) のXML属性を定義する要素です。適切に使えばページがより読みやすくなります。以下のコードは上に紹介した<code>hello.zul</code>と同様です。.</para>
<programlisting>&lt;button label="Say Hello"&gt;&#13;     &lt;attribute name="onClick"&gt;alert("Hello World!");&lt;/attribute&gt;    &#13;&lt;/button&gt;&#13;</programlisting>
<para>以下のように<code>trim</code>を設定するより、入力時のスペースを無視するかどうか決めることができます。デフォルトでは <code>trim</code>が設定されていません。</para>
<programlisting>&lt;button&gt;&#13;    &lt;attribute label="value" trim="true"&gt;    &#13;        The leading and trailing whitespaces will be omitted.        &#13;    &lt;/attribute&gt;    &#13;&lt;/button&gt;&#13;</programlisting></sect1><sect1><title>EL 表記</title>
<para>属性の名前や、要素、プロセスの指令を除いて、JSPのように、ZUMLのどの部分でもEL表記を使うことができます。</para>
<para>EL表記は構文<code>$</code>
<code>{</code>
<code>expr</code>
<code>}</code>を使います。例えば、</para>
<programlisting>&lt;element attr1=”${bean.property}”.../&gt;&#13;${map[entry]}&#13;&lt;another-element&gt;${3+counter} is ${empty map}&lt;/another-element&gt;&#13;</programlisting>
<para>【ヒント】： <code>empty</code>はマップ、集合、配列、文字列が空(null)かどうかをテストする演算子です。</para>
<para>【ヒント】： <code>map[entry]</code> はマップの要素にアクセスする方法です。つまり、Javaで言う、 <code>map.get(entry)</code> と同じです。</para>
<para>EL表記が属性の値として使われるとき、コンポーネントがその値を受け取れる限り、戻り値はどのようなオブジェクトでも構いません。たとえば、以下の表記は<code>Boo</code>
<code>le</code>
<code>an</code>オブジェクトとして処理されます。</para>
<programlisting>&lt;window if="${some &gt; 10}"&gt;&#13;</programlisting>
<para>【ヒント】： ELの中の <code>+ operator</code>は算術です。文字列の連結処理はしません。文字列の連結は”<code>${exprl} </code>
<code>is added with </code>
<code>${expr2}</code>”でできます。</para>
<para>
<code>p</code>
<code>aram</code>と<code>requestScope</code>のような標準的な暗黙オブジェクトと<code>self</code>と<code>page</code>のようなZKの暗黙オブジェクトは簡単に使えるようになっています。</para>
<programlisting>&lt;textbox value="${param.who} does ${param.what}"/&gt;&#13;</programlisting>
<para>EL機能をTLDファイルから挿入するために、以下のようにtaglibと呼ばれるプロセス指令が使えます。</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.tld" prefix="p" ?&gt;&#13;</programlisting>
<para>開発用レファレンスにEL表記の詳細が書かれています。または、JSP2.0チュートリアルかガイドを参照してください。</para></sect1><sect1><title><code>id</code> 属性</title>
<para>JavaコードとEL表記の中のコンポーネントにアクセスするために、<code>id</code>という属性を使って識別子を指定することができます。以下の例では、識別子をラベルに指定し、ボタンが押された時にその値を処理できます。</para>
<para/>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;    Do you like ZK? &lt;label id="label"/&gt;    &#13;    &lt;separator/&gt;    &#13;    &lt;button label="Yes" onClick="label.value = self.label"/&gt;    &#13;    &lt;button label="No" onClick="label.value = self.label"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>Yesボタンを押したのち、下記のように表示されます。</para>
<para>
<graphic align="center" fileref="img/100000000000029A0000006E7B745AB5.png">2
			
		</graphic>以下はEL表記の中のコンポーネントを参照する例です。</para>
<programlisting>&lt;textbox id="source" value="ABC"/&gt;&#13;&lt;label value="${source.value}"/&gt;&#13;</programlisting></sect1><sect1><title>
<code>if</code> と<code> unless</code> 属性</title>
<para>
<code>if</code>と<code>unless</code>属性によりコンポーネントを生成するかどうかが決められます。下の例では、リクエストが<code>vote</code>というパラメーターを持つ場合のみ、二つのラベル(コンポーネント)が両方とも作られます。</para>
<programlisting>&lt;label value="Vote 1" if="${param.vote}"/&gt;&#13;&lt;label value="Vote 2" unless="${!param.vote}"/&gt;&#13;</programlisting>
<para>二種類の属性が同時に指定された場合、ともに正しい(True)と判断されない限り、コンポーネントは作られません。</para></sect1><sect1><title>
<code>forEach</code> 属性</title>
<para>
<code>forEach</code>属性によりどれくらいコンポーネントが作られるかが決められます。この属性にオブジェクトの集合を指定したら、ZKローダーが集合にあるそれぞれの項目にコンポーネントを作成します。たとえば、以下のZUMLページの中で、<code>listitem</code>要素が三回 (Mondayと Tuesdayと Wednesdayを)指定したので、三つのリスト項目が作成されます。</para>
<programlisting>&lt;zscript&gt;contacts = new String[] {"Monday", "Tuesday", "Wednesday"};&lt;/zscript&gt;&#13;&lt;listbox width="100px"&gt;<inlinegraphic fileref="img/100000000000006A00000037D22ADEEF.png" align="right"/>&#13; &lt;listitem label="${each}" forEach="${contacts}"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>forEach</code>属性を使って要素を処理する際、<code>each</code> 変数はひとつずつ集合のオブジェクトより値が指定されます。たとえば、ひとつ前の例の<code>contacts</code>です。ですので、上記のZUMLページは以下のものとは同様です。</para>
<programlisting>&lt;listbox&gt;&#13; &lt;listitem label="Monday"/&gt;&#13; &lt;listitem label="Tuesday"/&gt;&#13; &lt;listitem label="Wednesday"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>forEach</code>に加えて、<code>forEachBegin</code>と<code>forEachEnd</code>を使って繰り返すこともできます。詳細ZKユーザーインターフェースマークアップ言語のZK属性をご覧ください。</para></sect1><sect1><title>
<code>use</code> 属性</title>
<para>ページ中に不適切に組み込まれているコードはメンテナンスの際に問題を起こさせるかもしれません。ビューからコードを分離させるには二つの方法があります。</para>
<para>一つ目は、大事なイベントに注目し、それに応じて、適切なメソッドを適用します。たとえば、初期化、プロセス、取り消しをそれぞれ<code>onCreate</code>
<footnote>
<para>ZUMLページに定義されたウィンドウが生成されたら、<code>onCreate</code>イベントが送信されます。</para>
</footnote>、 <code>onOK</code>
<footnote>
<para>ユーザーがリターンキーを押したら、<code>onOK</code>イベントが送信されます。</para>
</footnote>、<code>onCancel</code>
<footnote>
<para>ユーザーがESCキーを押したら、<code>onCancel</code>イベントが送信されます。</para>
</footnote>で対応します。</para>
<programlisting>&lt;window id="main" onCreate="MyClass.init(main)"&#13;
   onOK="MyClass.process(main)" onCancel="MyClass.cancel(main)"/&gt;    &#13;</programlisting>
<para>なお、<code>MyClass</code>というJavaクラスが存在しなければなりません。</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyClass {&#13;    public static void init(Window main) { //does initialization    &#13;    }    &#13;    public static void save(Window main) { //saves the result    &#13;    }    &#13;    public static void cancel(Window main) { //cancel any changes    &#13;    }    &#13;}&#13;</programlisting>
<para>二つ目の方法は、<code>use</code>属性によりクラスを指定してデフォルトコンポーネントクラスを取り換えます。</para>
<programlisting>&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>そして、以下のように<code>MyWindow</code>というJavaクラスが存在しなければなりません。</para>
<programlisting>import org.zkoss.zul.Window;&#13;&#13;public class MyWindow extends Window {&#13;    public void onCreate() { //does initialization    &#13;    }    &#13;    public void onOK() { //save the result    &#13;    }    &#13;    public void onCancel() { //cancel any changes    &#13;    }    &#13;}&#13;</programlisting>
<para>これら二つのアプローチは異なった利点があります。これらは二つともMVCモデルのコントローラーとして作動しています。どちらを使うのかはユーザーの選択です。</para><sect2><title>
<code>zscript</code>でJavaクラスを作る</title>
<para>BeanShell<footnote>
<para>http://www.beanshell.org</para>
</footnote>のおかげで、以下のようにJavaクラスは<code>zscript</code>の中で使用することができます。</para>
<programlisting>&lt;zscript&gt;&#13;    public class MyWindow extends Window {    &#13;
    }&#13;
&lt;/zscript&gt;&#13;
&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>【ヒント】： JRuby 等多くのスクリプト言語では、開発者はJVMにアクセスできるクラスを定義できます。詳しくは関連したマニュアルを参照してください。</para>
<para>コードをビューから分けるのに、全ての<code>zscript </code>コードを別ファイルに置くことができます。たとえば、 <code>mywnd.zs</code>ファイルに。そして以下のようにパスを指定します。</para>
<programlisting>&lt;zscript src="/zs/mywnd.zs"/&gt;&#13;&lt;window use="MyWindow"/&gt;&#13;</programlisting>
<para>【ヒント】： <code>init </code>指令で <code>zscript</code> を指定するのも可能です。その違いは、<code>init</code> 指令は全てのコンポーネントが生成される前に(Pageの初期の時点で)処理されます。ZKユーザーインターフェースマークアップ言語 の<code>init</code> コマンド セクションを参考にしてください。</para></sect2></sect1><sect1><title>手動でコンポーネントを作る</title>
<para>ZUMLページで作られるコンポーネントの記述に加え、開発者は手動でそれらを作ることもできます。すべてのコンポーネントのクラスは結合体で、直接<footnote>
<para>簡素化するため、ここではファクトリデザインパターンが使われていません。</para>
</footnote> 構築子から作られます。</para>
<programlisting>&lt;window id="main"&gt;&#13;    &lt;button label="Add Item"&gt;    &#13;        &lt;attribute name="onClick"&gt;        &#13;    new Label("Added at "+new Date()).setParent(main);    &#13;    new Separator().setParent(main);    &#13;        &lt;/attribute&gt;        &#13;    &lt;/button&gt;    &#13;    &lt;separator bar="true"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>コンポーネントが手動で作られたとき、自動的にページに付け加えられることはありません。つまり、ユーザーのブラウザには現れません。ページにそれを追加するため、<code>setParent</code>
<code>・</code>
<code>appendChild</code>
<code>・</code>
<code>insertBefore</code>を使い、親とそれをつなげます。そうすれば親がページの一部であれば、そのコンポーネントもページの一部になります。</para>
<para>コンポーネントを削除したり、クローズしたりする方法はありません<footnote>
<para>W3C DOMのコンセプトと類似です。一方、Windows APIでは、開発者はライフサイクルを管理しなければなりません。</para>
</footnote>。コンポーネントがページから離れるとすぐに、ブラウザからも離れてしまいます。ページにつけられるとすぐに表示されます。</para>
<programlisting>&lt;window id="main"&gt;&#13;    &lt;zscript&gt;Component detached = null;&lt;/zscript&gt;    &#13;    &lt;button id="btn" label="Detach"&gt;    &#13;        &lt;attribute name="onClick"&gt;        &#13;    if(detached != null) {    &#13;        detached.setParent(main);        &#13;        detached = null;        &#13;        btn.label = "Detach";        &#13;    } else {    &#13;        (detached = target).setParent(null);        &#13;        btn.label = "Attach";        &#13;    }    &#13;        &lt;/attribute&gt;        &#13;    &lt;/button&gt;    &#13;    &lt;separator bar="true"/&gt;    &#13;    &lt;label id="target" value="You see this if it is attached."/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>上の例では、<code>setVisible</code>方法を使えば同じような効果があります。しかしながら、<code>setVisible(false)</code>はブラウザからコンポーネントを取り除きません。ただ、コンポーネント（とすべての子ページ）を見えなくします。</para>
<para>コンポーネントがページから離れると、使っていた(使わなくなった)メモリーはJVMのガーベージコレクタよりリリースされます。</para><sect2><title>ZUMLを使わずにZKアプリケーションを開発</title>
<para>ZUMLを使わない開発者は、いわゆる<code>richlet</code>を使ってすべてのコンポーネントを手動で作ることができます。</para>
<programlisting>import org.zkoss.zul.*;&#13;public class TestRichlet extends org.zkoss.zk.ui.GenericRichlet {&#13;   public void service(Page page) {
      page.setTitle("Richlet Test");

      final Window w = new Window("Richlet Test", "normal", false);&#13;
      new Label("Hello World!").setParent(w);&#13;
      final Label l = new Label();
      l.setParent(w);
      //...
      w.setPage(page);
   }&#13;}&#13;</programlisting>

<para>上級者のための機能 の章のリッチレット部分をご覧ください。</para></sect2></sect1><sect1><title>特定のページに新しいコンポーネントを定義する</title>
<para>下記の例のように、XML属性でプロパティをコンポーネントに指定することは簡単です。</para>
<programlisting>&lt;button label="OK" style="border:1px solid blue"/&gt;&#13;</programlisting>
<para>開発者に特定ページに新しいコンポーネントを定義させ、パワフルで簡単な方法をZKは提供しています。多くの同じタイプのコンポーネントがプロパティセットを共有する場合は便利です。</para>
<para>はじめに <code>component </code>指令を使って新しいコンポーネントを定義します。</para>
<programlisting>&lt;?component name="bluebutton" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;bluebutton/&gt;
&lt;bluebutton label="Cancel"/&gt;</programlisting>
<para>は以下の内容と同様です。</para>
<programlisting>&lt;bluebutton style="border:1px solid blue" label="OK"/&gt;
&lt;bluebutton style="border:1px solid blue" label="Cancel"/&gt;</programlisting>
<para>さらに、以下のように<code>button</code>の定義を無効にすることができます。もちろん他のどのページには、影響ありません。</para>
<programlisting>&lt;?component name="button" extends="button" style="border:1px solid blue" label="OK"?&gt;&#13;

&lt;button/&gt;
&lt;button label="Cancel"/&gt;</programlisting>
<para>より詳しい情報はZKユーザーインターフェースマークアップ言語 の章のcomponent コマンドセクションをご覧ください。</para></sect1></chapter>
<chapter>
<title>3. 基礎</title>
<para>この章はＺＫの基礎を説明します。XULを使ってZKの特徴を表していますが、ZKで使用できる他のマークアップ言語も大抵、使うことができます。</para><sect1><title>構造</title>
<para>ZKはAJAX方式の構造を用いて対話を自動化し、XUL方式のコンポーネントのセットにより使い勝手を良くし、マークアップ言語を使用することより開発を簡単化しています。AJAX方式は下にかいてあるように三つの構造から成っています。ZKローダー、ZK AUエンジン、ZKクライアントエンジン</para>
<para/>
<para>
<graphic align="center" fileref="img/3-1.png">2
			
		</graphic>ユーザーリクエストを基にして、ZKローダーはZKページを読み込んで翻訳し、結果をURLで指定されたHTMLページに表示します。ZKページはZUMLと呼ばれるマークアップ言語で書かれています。ZUMLはHTMLに似ていて、視覚的にどのように表示するかと、どんなコンポーネントを作成するかが書かれています。これら一度作られたコンポーネントはセッションが時間切れになるまで、使うことができます。</para>
<para>ZKAU<footnote>
<para>AUはAsynchronous Updateの略です。 </para>
</footnote>エンジンとZKクライアントエンジンは投手と捕手のような関係です。それらはサーバーで作動しているアプリケーションにブラウザ上のイベントを配信し、ブラウザ上でアプリケーションにより操作されているコンポーネントを基にしてDOMツリーを更新します。これがいわゆるイベント駆動型のプログラミングモデルです。</para><sect2><title>実行の流れ</title>
<orderedlist>
<listitem>
<para>URLを入力するか、また、ブラウザ上でハイパーリンクをクリックしたとき、リクエストはウェブサーバーに送られます。もしそのURLがZKに照合されたら、ZKローダーが呼び出され、このリクエストを処理します<footnote>
<para>開発用リファレンスのAppendix A をご覧ください。</para>
</footnote>。</para>
</listitem>
<listitem>
<para>ZKローダーは指定されたページを読み込み、翻訳し、それに応じて、適切なコンポーネントを作成します。</para>
</listitem>
<listitem>
<para>1ページすべてを翻訳した後、ZKローダーはHTMLページに結果を表示します。そのHTMLページはZKクライアントエンジンとともにブラウザへ送り返されます<footnote>
<para>ZKクライアントエンジンはJavaScriptで作成されました。ブラウザはZKクライアントエンジンをキャッシュしますので、エンジンは大抵、最初の一回目のみ送信されます。 </para>
</footnote>。</para>
</listitem>
<listitem>
<para>ZKクライアントエンジンはブラウザ側にあり、ユーザーによって行われた、マウス移動、値の変化のようなイベントを検出します。一度、検出すると、ZKAUエンジンにZKリクエストを送ることによって通知します<footnote>
<para>ZKリクエストは特別なAJAXリクエストですが、ZKモバイルの場合、ZKリクエストは特別なHTTPリクエストです。</para>
</footnote>。</para>
</listitem>
<listitem>
<para>クライアントエンジンからZKリクエストを受け取ることで、AUエンジンは、必要ならコンポーネントの内容を更新します。そして、AUエンジンは関連するイベントハンドラーを呼び出すことによって、アプリケーションに通知します。</para>
</listitem>
<listitem>
<para>もし、アプリケーションがコンポーネントの内容を改変したり、移動させたり、つけ足したりしたら、AUエンジンは改変されたコンポーネントの新しい内容をクライアントエンジンにZKのレスポンスにより送ります。</para>
</listitem>
<listitem>
<para>これらZKのレスポンスはDOMツリーの状況に応じた更新方法をクライアントエンジンに指示するメソッドです。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>コンポーネント、ページ と デスクトップ</title><sect2><title>コンポーネント</title>
<para>コンポーネントはラベル、ボタン、ツリーのようなUIオブジェクトです。それらは視覚的な表現と特定ユーザーインターフェイスの動作を定義します。それらを操作することで、開発者はクライアント側の視覚的なアプリケーションの表し方をコントロールします。</para>
<para>コンポーネントは<code>org.zkoss.zk.ui.Component</code>インターフェイスを実装しなければなりません。</para></sect2><sect2><title>ページ</title>
<para>ページ (<code>org.zkoss.zk.ui.Page</code>) はコンポーネントの集合です。それぞれのコンポーネントはブラウザのある部分で表示されています。ZKローダーがZUMLのページを翻訳したときにページは自動的に作成されます。</para><sect3><title>ページのタイトル</title>
<para>どのページでも、ブラウザウィンドウのキャプションにタイトルを追加できます。詳しくはZKユーザーインターフェースマークアップ言語 の章のプロセス命令セクションを参照してください。</para>
<programlisting>&lt;?page title="My Page Title"?&gt;&#13;</programlisting></sect3></sect2><sect2><title>デスクトップ</title>
<para>
<graphic align="center" fileref="img/3-2-3a.png">2
			
		</graphic>ZUMLページは直接的にまたは間接的にほかのZUMLページを含んでいます。これらのページは同じURLにつながっているので、まとめてデスクトップ(org.zkoss.zk.ui.Desktop)と呼ばれています。つまりデスクトップとは同じURLにつながっているページの集合です。</para>
<para>ZKアプリケーションがユーザーと対話するとき、ページがデスクトップに追加されたり、またいくつかがデスクトップから削除されます。同様に、ページからコンポーネントがつけ足されたり、消されたりします。</para><sect3><title>
<code>createComponents</code>　メソッド</title>
<para>ページとデスクトップは自動的に作られたり、消されたりします。それらを消したり作ったりするAPIはありません。ZUMLがページを読み込むたびにページが作成され、ZKがこれ以上参照しないと認識したときにページは削除されます。最初のZUMLページが読み込まれた時にデスクトップは作成され、一つのセッションに対して、デスクトップが多く作られすぎたときに消されます。</para>
<para>
<code>org.zkoss.zk.ui.Executions</code>クラスの<code>creatComponents</code>メソッドはページではなくてコンポーネントだけ作成します。また、ZUMLファイル(aka.,page)を読み込んだ時も同様です。</para></sect3></sect2><sect2><title>コンポーネントの森</title>
<para>一つのコンポーネントは一つ以上の親コンポーネントを持つことができません。一つのコンポーネントには複数の子コンポーネントを持つことがあります。あるコンポーネントは特定の種類のコンポーネントのみを子として受け入れます。また別のコンポーネントは全く子をとりません。たとえば、XUL中の<code>Listbox</code>は<code>Listcols</code>と<code>Listite</code>
<code>m</code>だけを受け入れます。詳しいことが知りたければ、JavadocまたはXULチュートリアルを参照してください。</para>
<para>親のいないコンポーネントはルートコンポーネントと呼ばれます。一つのページは複数のルートコンポーネントから成り立っていることがあります。なお、ルートコンポーネントは<code>getRoots</code>メソッドによって検索できます。</para></sect2><sect2><title>コンポーネント：視覚表現とJavaオブジェクト</title>
<para>サーバー中でジャバオブジェクトになる他に、コンポーネントはブラウザ上で視覚要素<footnote>
<para>ブラウザがクライアントのであれば、視覚的な表現はDOM要素かその集合です。 </para>
</footnote>を担当します。ただし、それはただ一ページのみに属している場合です。コンポーネントがページに添付されているとき、その視覚要素<footnote>
<para>ビジュアル部分は自動的に生成・更新・削除されます。開発者はそれを処理する必要はほとんどありません。開発者主なタスクはサーバー側のオブジェクトを処理することです。 </para>
</footnote>は作成されます。コンポーネントがページから外れるとき、視覚部分はなくなります。</para>
<para>ページにコンポーネントを添付する方法は二つあります。まず一つ目は<code>setPage</code>メソッドを呼び出して、任意のコンポーネントをそのページのルートコンポーネントにします。二つ目は<code>setParent, insertBefore, appendChild</code>メソッドを呼び出す方法で、コンポーネントを他に所属している子コンポーネントにすることができます。そして、子コンポーネントは親が属しているページと同じページに属することになります。</para>
<para>同様にして、nullで<code>setPage</code>を呼び出すことでページからルートコンポーネントを外すことができます。子は親から離れる、または親がページを離れることで外れます。</para>
<para/></sect2><sect2><title>識別子</title>
<para>どのコンポーネントも識別子(<code>getId</code>メソッド)を持っています。識別子はコンポーネントが作成されるとき自動的に作成され、開発者はいつでもそれを編集することができます。識別子に名前をつける制限はありません。しかしながら、識別子がアルファベットで指定されたら、ZUMLページに組み込まれているJavaコードとEL表記で直接アクセスすることができます。</para>
<programlisting>&lt;window title="Vote" border="normal"&gt;&#13;    Do you like ZK? &lt;label id="label"/&gt;    &#13;    &lt;separator/&gt;    &#13;    &lt;button label="Yes" onClick="label.value = self.label"/&gt;    &#13;    &lt;button label="No" onClick="label.value = self.label"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>UUID</title>
<para>コンポーネントはUUID(Universal Unique ID)という別の識別子を持っていますが、アプリケーション開発者はめったに使用しません。</para>
<para>UUIDはコンポーネントとクライアントエンジンによって使われ、ブラウザ上でDOMを操作したり、サーバーと通信するために使われます。より正しく言うと、クライアント上にあるDOM要素の<code>id</code>属性はUUIDです。</para>
<para>UUIDはコンポーネントが作られるときに自動で作られます。UUIDのうちでHTMLタグを表すコンポーネントの識別子以外は、変えることができません。</para>
<para>HTML関連のコンポーネントはUUIDを他のコンポーネントと異なる方法で処理します。UUIDはIDと同じです。もしHTML関連のコンポーネントのIDを変えてしまったら、UUIDはそれに応じて変わります。この特性によって、古いJavaScriptコードと<code>servelets</code>は以前のまま使うことができます。</para></sect2></sect1><sect1><title>IDスペース</title>
<para>視覚表現をいくつかのZUMLページに分けるのはよくあることです。たとえば、注文購入のページ、支払いモーダルのダイアログ。すべてのコンポーネントが同じデスクトップで認識できるのなら、開発者は一つのデスクトップに追加されるすべてのページに対して、すべての認識詞を独特なものにしなければなりません。</para>
<para>IDスペースのコンセプトはこの問題を解決するため導入したものです。IDスペースはデスクトップコンポーネントのサブセットです。その唯一性はIDスペース内でのみ保障されています。</para>
<para>IDスペースのもっとも簡単な形はウィンドウ（<code>org.zkoss.zul.Window</code>）です。ひとつのウィンドウ（ウィンドウ自体を含む）との子コンポーネントコンポーネントは独立したIDスペースを形作ります。このようにして、ウィンドウをそれぞれのページの最上段のコンポーネントとして使えます。そうして開発者はそれぞれのページ別々に唯一性を保持する必要があります。</para>
<para>一般的に、<code>org.zkoss.zk.ui.IdSpace</code>インターフェイスを実装する限り、どのコンポーネントもIDスペースを形成できます。ページはまた<code>IdSpace</code>インターフェイスを実装するので、ページは空間所有者なのです。</para>
<para>最上段のIDスペースコンポーネントはIDスペースの所有者と呼ばれていて、コンポーネントインターフェイスの中から<code>getSpaceOwner</code>メソッドによってIDスペースを引き出すことができます。</para>
<para>IDスペース、例えばXは他のIDスペースの子で、X空間の所有者はY空間に含まれています。しかし、Xの子はY空間には含まれていません。</para>
<para><graphic align="center" fileref="img/3-3.png">2
			
		</graphic>図に例示されたように三つの空間（P、A、C）がああります。P空間はPとAとFとGを含んでいます。A空間はAとBとCとDを含んでいます。C空間はCとEを含んでいます。</para>
<para>同じIDスペース中のコンポーネントはフェローと呼ばれます。たとえば、A・B・C・Dは同じIDスペースのフェローです。</para>
<para>ほかのフェローを引き出すのに、<code>IdSapce</code>インターフェイス、又は、コンポーネントインターフェイスの中の<code>getFellow </code>メソッドを使います。</para>
<para>
<code>getFellow</code>メソッドは同じIDスペースの最上段（所有者）に限らず、IDスペースのどのコンポーネントに対しても呼び出すことができます。同様に、空間所有者とは関係なく、<code>getSpaceOwner</code>メソッドは同じIDスペースのどのコンポーネントに対しても同じオブジェクトを返します。</para>
<para>
<code>org.zkoss.zk.ui.Path</code>クラスはIDスペース上のコンポーネントの位置を簡単化するためのユーティリティプログラムを提供します。その使用方法は<code>java.io.File</code>と同様です。</para>
<programlisting>Path.getComponent("/A/C/E");&#13;new Path("A/C", "E").getComponent();&#13;</programlisting><sect2><title>ネーム空間とIDスペース</title>
<para>インタプリタでコンポーネントに直接にアクセスするため、ネーム空間(<code>org.zkoss.scripting.Namespace</code>)のコンセプトを使用します。まず、どのIDスペースもネーム空間を持っています。さらに、ネーム空間の中で定義された値をネーム空間内のスクリプトコードとEL表記は参照できます。</para>
<programlisting>&lt;window border="normal"&gt;<inlinegraphic fileref="img/100000000000013A0000001CEEC7BB2A.png" align="right"/>&#13;    &lt;label id="l" value="hi"/&gt;    &#13;    &lt;zscript&gt;    &#13;        l.value = "Hi, namespace";        &#13;    &lt;/zscript&gt;    &#13;    ${l.value}    &#13;&lt;/window&gt;&#13;</programlisting>
<para>以下の例の中で二つのネーム空間があります。一つはウィンドウw1に属していて、もう一つはウィンドウ<code>w2</code>
<footnote>
<para>ウィンドウは<code>org.zkoss.zk.ui.IdSpace</code>を実装しますので、独立したIDスペースとネーム空間が形成されます。 </para>
</footnote>に属している。このようにして、b1ボタンの<code>onClick</code>スクリプトはウィンドウw1で定義されたラベルを参照して、b2ボタンの<code>onClick</code>スクリプトはw2内で定義された<code>checkbox</code>を参照します。</para>
<programlisting>&lt;window id="w1"&gt;&#13;    &lt;window id="w2"&gt;    &#13;        &lt;label id="c"/&gt;        &#13;        &lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;        &#13;    &lt;/window&gt;    &#13;    &lt;checkbox id="c"/&gt;    &#13;    &lt;button id="b2" onClick="c.label = &amp;quot;OK&amp;quot;"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>ここで一つ注意するポイントがあります：ネーム空間は階層です。つまり、ウィンドウ<code>w2</code>内の<code>zscript</code>は<code>w2</code>の中に重複がない限り、ウィンドウw1のコンポーネントを見ることができます。このようにして、以下の例の中でボタンb1をクリックすることはラベルcを変えます。</para>
<programlisting>&lt;window id="w1"&gt;&#13;    &lt;window id="w2"&gt;    &#13;        &lt;button id="b1" onClick="c.value = &amp;quot;OK&amp;quot;"/&gt;        &#13;    &lt;/window&gt;    &#13;    &lt;label id="c"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>ZKのコンポーネントはネーム空間にコンポーネントを指定する他に、<code>setVariable</code>メソッドによって変数をコンポーネントに指定することができます。そうして<code>zscript</code>はそれらを直接参照することができます。</para></sect2><sect2><title>
<code>zscript</code>の中で定義された変数とファンクション</title>
<para>コードを実行するに加えて、以下のように記述することで、変数と要素を<code>zscript</code>メソッドの中で直接定義することができます。</para>
<programlisting>&lt;window id="A&gt;&#13;    &lt;zscript&gt;    &#13;        Object myvar = new LinkedList();        &#13;        void myfunc() {        &#13;            ...            &#13;        }        &#13;    &lt;/zscript&gt;    &#13;    ...    &#13;    &lt;button label="add" onClick="myvar.add(some)"/&gt;    &#13;    &lt;button label="some" onClick="myfunc()"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>zscript</code>の中で定義された変数とメソッドはスクリプト言語のインタプリタの中に保存されています。</para><sect3><title>
<code>zscript</code>とEL表記</title>
<para>ネーム空間<footnote>
<para><code>org.zkoss.zk.scripting.Namespace</code></para>
</footnote>のように、<code>zscript</code>の中で定義された変数をEL表記は参照できます</para>
<programlisting>&lt;window&gt;&#13;    &lt;zscript&gt;    &#13;    String var = "abc";    &#13;    self.setVariable("var2", "xyz", true);    &#13;    &lt;/zscript&gt;    &#13;    ${var} ${var2}    &#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は以下と同様です。</para>
<programlisting>&lt;window&gt;&#13;abc xyz&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>zscript</code>の中で定義された変数はネーム空間で定義されたものより優先度が高いです。</para>
<programlisting>&lt;window&gt;&#13;    &lt;zscript&gt;    &#13;    String var = "abc";    &#13;    self.setVariable("var", "xyz", true);    &#13;    &lt;/zscript&gt;    &#13;    ${var}    &#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は以下と同様です。</para>
<programlisting>&lt;window&gt;&#13;abc&#13;&lt;/window&gt;&#13;</programlisting>
<para>以下の例のようにコンポーネントを宣言すると混乱を招くことがあります。</para>
<programlisting>&lt;window&gt;&#13;    &lt;zscript&gt;    &#13;    String var = "abc";    &#13;    &lt;/zscript&gt;    &#13;    &lt;label id="var" value="A label"/&gt;    &#13;    ${var.value} &lt;!-- Wrong! var is "abc", not the label --&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>混乱を避けるために、いくつかの名付け方式を使うことをお勧めします。たとえば、インタプリタ変数にはプレフィックス<code>zs_</code>をつけます。</para>
<para>加えて、できるだけローカル変数を使いましょう。ローカル変数はクラスの名前とともに定義され、<code>zscript</code>コードの特定の範囲内のみに有効です。</para>
<programlisting>&lt;zscript&gt;&#13;Date now = new Date();&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>さらに、以下のように括弧でくくることでローカル変数をEL表記が参照できないように設定できます。</para>
<programlisting>&lt;zscript&gt;&#13;
{ //create a new logic scope
   String var = "abc"; //visible only inside of the enclosing curly brace&#13;
}
&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>多領域(マルチ・スコープ)インタプリタ</title>
<para>定義することによって、インタプリタはひとつの領域を持つか、変数とメソッドを保存する論理領域を持つことができます。区別するために、それぞれ、シングル領域と多領域インタプリタと呼びます。</para>
<para>Javaインタプリタ（BeamShell）は代表的な多領域インタプリタ<footnote>
<para>2.3.1(含む)以降および2.2.1(含む)以前、Javaインタプリタはマルチスコープに対応可能です。 </para>
</footnote>で、それぞれのIDスペースに独立のインタプリタ領域を作ります。例えば、以下の例で二つの論理領域はそれぞれウィンドウAとBのために確保されます。そうして、var2はウィンドウBのみに有効で、var1はAとBの両方のウィンドウに有効です。</para>
<programlisting>&lt;window id="A"&gt;&#13;    &lt;zscript&gt;var1 = "abc";&lt;/zscript&gt;    &#13;    &lt;window id="B"&gt;    &#13;        &lt;zscript&gt;var2 = "def";&lt;/zscript&gt;        &#13;    &lt;/window&gt;    &#13;&lt;/window&gt;&#13;</programlisting><sect4><title>Javaインタプリタ(BeanShell)</title>
<para>Javaインタプリタ（BeanShell）を使って、以下のようにクラスの名前を定義することで一番近いIDスペースの論理領域（つまり、ウィンドウ）にローカルインタプリタ変数を宣言することができます。</para>
<programlisting>&lt;window id="A"&gt;&#13;    &lt;window id="B"&gt;    &#13;        &lt;zscript&gt;        &#13;    String b = "local to window B";    &#13;        &lt;/zscript&gt;        &#13;    &lt;/window&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>以下はabcとdefを作成するより正確な例です。</para>
<programlisting>&lt;window id="A"&gt;&#13;    &lt;zscript&gt;    &#13;    var1 = var2 = "abc";    &#13;    &lt;/zscript&gt;    &#13;    &lt;window id="B"&gt;    &#13;        &lt;zscript&gt;        &#13;    Object var1 = "123";    &#13;    var2 = "def";    &#13;    var3 = "xyz";    &#13;        &lt;/zscript&gt;        &#13;    &lt;/window&gt;    &#13;    ${var1} ${var2} ${var3}    &#13;&lt;/window&gt;&#13;</programlisting>
<para>オブジェクトvar1＝123は、クラス名とオブジェクトが指定されているので、ローカル変数をウィンドウBに定義しています。一方、オブジェクトvar2 = defはインタプリタに、現領域、又は上層領域(親など)内でvar2と定義された変数を参照させます。var2はウィンドウA中で定義されていて、変数はオーバーライドされています。var3＝xyzの場合では、ウィンドウAがvar3と呼ばれる変数を定義していないので、ウィンドウBにローカル変数が指定されています。</para></sect4></sect3><sect3><title>単領域インタプリタ</title>
<para>Ruby,Groovy,JavaScriptインタプリタはまだ多領域をサポートしていません<footnote>
<para>今後サポートする予定です。 </para>
</footnote>。つまり、すべての変数はひとつの論理領域のみに定義されていることを意味しています。例えば、Rudyの変数は(インタプリタごとに)一領域中に保存されます。このように、同ページのであれば、ひとつのウィンドウ中に定義されたインタプリタ変数はほかのウィンドウでオーバーライドされます。混乱を避けるために、ウィンドウを意味する特別なプレフィックスのついた変数を書きます。</para>
<para>【ヒント】：どのページもzkscriptコードを処理するために自身のインタプリタを持っています。デスクトップは多数のページを持っていて、(スクリプト言語ごとに)インタプリタが複数のインスタンスを持っている場合があります。</para></sect3><sect3><title>一ページの中にある複数のスクリプト言語</title>
<para>どのスクリプト言語もひとつのインタプリタと繋がっています。変数とメソッドはひとつの言語の中で定義されていて、ほかの言語には使えません。例えば、以下の例の中でvar1とvar2は異なった2つのインタプリタに属しています。</para>
<programlisting>&lt;zscript language="Java"&gt;&#13;    var1 = 123;    &#13;&lt;/zscript&gt;&#13;&lt;zscript language="JavaScript"&gt;&#13;    var2 = 234;    &#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>
<code>getVariable</code>と<code>getZScriptVariable</code>
</title>
<para>ネーム空間の中で定義された変数は<code>getVariable</code>メソッドで引き出すことができます。</para>
<para>一方，<code>zscript</code>中で定義された変数はそれを翻訳するインタプリタの一部です。ネーム空間の一部ではありません。つまり、<code>getVariable</code>メソッドでそれらを取得することはできません。</para>
<programlisting>&lt;zscript&gt;&#13;    var1 = 123; //var1 belongs to the interpreter, not any namespace    &#13;    page.getVariable("var1"); //returns null    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>代わりに<code>getZScriptVariable</code>をつかって<code>zscript</code>内で定義された変数を引き出さなければなりません。同様にして、<code>getZScriptClass</code>を使ってクラスを取得し、<code>getZScriptMethod</code>をつかってメソッドを取得します。これらのメソッドは見つかるまで、呼び出されたインタプリタを通して、繰り返されます。</para>
<para>特定のインタプリタを探す場合、以下のように<code>getInterpreter</code>メソッドを使って、インタプリタを引き出します。</para>
<programlisting>page.getInterpreter("JavaScript").getVariable("some"); //interpreter for JavaScript&#13;page.getInterpreter(null).getVariable("some"); //interpreter for default language&#13;</programlisting></sect3></sect2></sect1><sect1><title>イベント</title>
<para>イベントは(<code>org.zkoss.zk.ui.event.Event</code>)はアプリケーションに何が起こったかを通知します。異なった種類のイベントは異なったクラスによって表されます。たとえば<code>org.zkoss.zk.ui.event.MouseEvent</code>はマウスをクリックしたような動きを表します。</para>
<para>イベントへレスポンスするためには、アプリケーションがひとつ以上のリスナーを登録しなければなりません。イベントリスナーを登録する方法は二つあります。ひとつはマークアップ言語中で<code>onXxx</code>属性を定義する方法です。もうひとつは<code>addEventListener</code>メソッドをつかってコンポーネント又は参照するページを呼び出します。</para>
<para>イベントがブラウザでユーザーの操作によって発生することに加えて、アプリケーションは<code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>postEvent</code>と<code>sendEvent</code>メソッドを使ってイベントを発生させます。</para></sect1><sect1><title>デスクトップとイベント処理</title>
<para>上に記述したように、デスクトップはURLリクエストが集まるページです。デスクトップはイベントリスナが通信できる領域でもあります。</para>
<para>イベントが発生したとき、イベントはデスクトップ上で行われます。ZKはイベントをデスクトップごとに別々の待ち行列に分けます。こうして、同じデスクトップ上のイベントは順番に行われ、一方、別デスクトップ上のイベントは同時進行で行われます。</para>
<para>イベントリスナはイベントが行われるデスクトップ上のどのページコンポーネントにも通信できます。同じデスクトップ内ではひとつのページから別のページにコンポーネントを動かすこともできます。一方で、他のデスクトップに属しているコンポーネントへは通信することができません。</para>
<para>【補足】：開発者はイベントリスナ中のデスクトップからコンポーネントをはずすことができます。そして他のイベントリスナ中の別デスクトップにつけることができます。</para><sect2><title>デスクトップとコンポーネントの作成</title>
<para>イベントリスナ中にコンポーネントを作成する時、現在イベントが行われているデスクトップにコンポーネントを自動的に指定します。コンポーネントがページに添付されていないときでさえ、指定作業は行われます。イベントリスナの中にユーザーが作成したどのコンポーネントもリスナが操作しているデスクトップ上で使用できます。</para>
<para>コンポーネントがイベントリスナ以外のスレッドの中で作成される時、コンポーネントはどのデスクトップにも属していません。この場合、適したイベントリスナ中で添付作業が行われる限り、添付したいどのデスクトップへも添付できます。もちろん、一度、コンポーネントがデスクトップへ添付されると、そのデスクトップへずっと付属することになります。</para>
<para>ほとんどのアプリケーションで、イベントリスナ以外のスレッドの中にコンポーネントを作成する必要はほとんどありません。しかし、ロングオペレーションを行うなら、バックグラウンドスレッド中でそれを実行した方がいいかもしれません。そのときバックグラウンドにコンポーネントツリーを準備します、適したイベントを受け取ったときそれをデスクトップへ添付します。イベントの監視と処理の章の中の長時間処理セクションを参照してください。</para></sect2></sect1><sect1><title>ZUMLとXMLネーム空間</title>
<para>ZKユーザーインターフェイスマークアップ言語(ZUML)は視覚表現を記述するのに開発者が使用するXML基盤の言語であります。ZUMLはコンポーネントセットへの依存を避けることを目的としています。つまりXULとXHTMLといったコンポーネントの異なったセット<footnote>
<para>タグともいいます。コンポーネントとタグは一対一の関係です。 </para>
</footnote>を同じZUMLページで同時に使うことができます。異なったマークアップ言語は透過的に添付されます。二つ以上のコンポーネントセットが同じページ中で使用されると、開発者はXMLのネーム空間を使ってそれらを区別します。XHTML・XULといった多数コンポーネントセットを同じページ中に組み合わせる場合はZKユーザーインターフェースマークアップ言語の章のコンポーネントセットとネーム空間セクションを参照してください。</para>
<para>【ヒント】：ZUMLの中のXMLのネーム空間を使用するかどうかは選択できます。二つ以上を組み合わせる際に使います。</para></sect1></chapter>
<chapter>
<title>4. コンポーネントのライフサイクル</title>
<para>この章はページの読み込みとページ更新のライフサイクルについて説明します。</para><sect1><title>ページの読み込みサイクル</title>
<para>ZKローダーがZUMLページを読み込み、翻訳するのに４段階があります。ページ初期段階、コンポーネント作成段階、イベント処理段階、書き込み段階です。</para><sect2><title>ページ初期段階</title>
<para>この段階ではZKは<code>init</code>と呼ばれるコマンドを処理します。このようなコマンドが定義されていなければ、この段階は省略されます。</para>
<para>
<code>class</code> 属性を伴ったプロセスのコマンドに対し、指定されたクラスのインスタンスは作られます。そして、<code>doInit</code>メソッドが呼び出されます。クラスが何をするか？はアプリケーションしだいです。</para>
<programlisting>&lt;?init class="MyInit"?&gt;&#13;</programlisting>
<para>他形式のinitコマンドは以下のように<code>zscript</code>属性でスクリプトコードファイルを指定します。そのファイルはページの初期段階で翻訳されます。</para>
<programlisting>&lt;?init zscript="/my/init.zs"?&gt;&#13;</programlisting>
<para>ページ初期段階ではページはデスクトップにまだ添付されていないことに注意してください。</para></sect2><sect2><title>コンポーネント作成段階</title>
<para>この段階ではZKローダーがZUMLページを翻訳します。必要に応じて、コンポーネントを初期化したり、作成したりします。以下のようにいくつかのステップを踏みます。</para>
<orderedlist>
<listitem>
<para>どの要素に対しても、if とunless属性を調べて有効かどうかを決めます。有効でないなら、メソッドとその子メソッドは無視されます。</para>
</listitem>
<listitem>
<para>
<code>forEach</code>属性が指定されたら、ZKはその項目の集合中で以下のステップを繰り返します。</para>
</listitem>
<listitem>
<para>要素名を基にしてコンポーネントを作成します。または、<code>use</code>属性の中に指定されたクラスを使って作成します。</para>
</listitem>
<listitem>
<para>ZUMLページの中で明記された属性の順番でメンバーは一つ一つ初期化されます。</para>
</listitem>
<listitem>
<para>重ねられた要素を翻訳し、すべてのプロセスを繰り返します。</para>
</listitem>
<listitem>
<para>コンポーネントが<code>org.zkoss.zk.ui.ext.AfterCompose</code>インターフェースを実装するなら、<code>afterCompose</code>メソッドを使用します。<footnote>
<para>
<code>AfterCompose</code>と呼ばれるのはステップ3～5がいわゆるcomposingです。 </para>
</footnote>.</para>
</listitem>
<listitem>
<para>子要素が作成されてから<code>onCreate</code>イベントはこのコンポーネントに送られます。それによって、アプリケーションがいくつかの要素を初期化できます。<code>onCreate</code>イベントは初めに子コンポーネントのために呼び出されます。</para>
</listitem>
</orderedlist>
<para>【補足】：開発者は<code>onCreate</code>イベント又は<code>AfterCompose</code>を実装することで、各々のアプリケーションに対して異なる初期化を行うことができます。<code>AfterCompose</code>はコンポーネント作成段階の中で呼び出されます。一方<code>onCreate</code>イベントはイベントリスナによってコントロールされます。</para>
<para>イベントリスナはモーダルダイアログ作成といった操作を一時保留にしたり再び行ったりできます。一方<code>AfterCompose</code>は他のスレッドに分岐させる必要がないのでより速いです。</para></sect2><sect2><title>イベント処理段階</title>
<para>この段階ではデスクトップ上の待ち行列にあるイベントに対し、対応するリスナをZKが呼び出します。</para>
<para>独立したスレッドはリスナを呼び出します。そうして、他のイベントプロセスに影響を与えることなく一旦停止できます。</para>
<para>プロセスの中のイベントリスナは他のイベントを起こすこともあります。詳しくはイベントの監視と処理の章を参照してください。</para></sect2><sect2><title>書き込み(Rendering)段階</title>
<para>すべてのイベントを終えたら、ZKはそれらのコンポーネントをHTMLページへ書き込み、そのページをブラウザへ送ります。</para>
<para>コンポーネントを書き込むのに、redrawメソッドを呼び出します。このメソッドでは、コンポーネントの実装はコンポーネントの中身を変えてはいけません。</para></sect2></sect1><sect1><title>ページ更新のライフサイクル</title>
<para>ZKのAUエンジンは三段階でクライアントから送られたZKのリクエストを処理します：リクエスト処理段階、イベント処理段階、書き込み段階。</para>
<para>ZKのAUエンジンは、ひとつのデスクトップにはひとつの待ち行列を当てることを原則にして、同じデスクトップのリクエストを順番で処理し、異なったデスクトップのリクエストを並列に処理します。</para><sect2><title>リクエスト処理段階</title>
<para>リクエストによって、ZK AUエンジンは変更したコンポーネントの内容をクライアント側に表示しているように更新する場合があります。</para>
<para>更新終わったら、関連するイベントを待ち行列に送ります。</para></sect2><sect2><title>イベント処理段階</title>
<para>この段階はコンポーネント作成段階の中のイベント処理段階と同じです。独立したスレッド中でイベントは一つずつ処理されます。</para></sect2><sect2><title>書き込み段階</title>
<para>イベントが処理されたら、ZKは変更されたコンポーネントを書き込み、対応するレスポンスを生成し、レスをクライアントに返します。そうして、クライアントエンジンはその返信を基にして、ブラウザにてDOMツリーを更新します。</para>
<para>ブラウザでコンポーネントの視覚表現を全体的に表現しなおす、又は属性を更新するかどうかは全てコンポーネントの実装によります。対話と簡単さの間でバランスを取ることがコンポーネント開発者の仕事です。</para></sect2></sect1><sect1><title>モールド(Molds)</title>
<para>同じページにコンポーネントを異なった外見で見せることができます。そのコンセプトをモールドと呼びます(aka.,template)。開発者はコンポーネントインターフェイス中で<code>setMold</code>メソッドの使用し、動的に外見を変えることができます。すべてのコンポーネントは<code>default</code>と呼ばれるデフォルトモールドを持っています。あるコンポーネントは二つ以上のモールドを持っています。例えば、<code>tabbox</code>は<code>default</code>と<code>accordion</code>モールドが使用可能です。</para>
<programlisting>&lt;tabbox&gt;&lt;!-- if not specified, the default mold is assumed. --&gt;&#13;    &lt;tabs&gt;    <inlinegraphic fileref="img/10000000000000A100000085680109CC.png" align="right"/>&#13;        &lt;tab label="Default"/&gt;        &#13;    &lt;/tabs&gt;    &#13;    &lt;tabpanels&gt;    &#13;        &lt;tabpanel&gt;        &#13;        &lt;tabbox mold="accordion"&gt;        &#13;            &lt;tabs&gt;            &#13;                &lt;tab label="First Accordion"/&gt;                &#13;                &lt;tab label="Second Accordion"/&gt;                &#13;            &lt;/tabs&gt;            &#13;            &lt;tabpanels&gt;            &#13;                &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;                &#13;                &lt;tabpanel&gt;The second panel.&lt;/tabpanel&gt;                &#13;            &lt;/tabpanels&gt;            &#13;        &lt;/tabbox&gt;        &#13;        &lt;/tabpanel&gt;        &#13;    &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect1><sect1><title>不要なコンポーネントの処理</title>
<para>他のコンポーネントをベースにしたGUIとは違って、ZKはコンポーネントを削除したり、閉じたりするメソッドがありません。W3C DOMのようにコンポーネントはページから外れるとすぐにブラウザから消えます。また、ページに添付されるとすぐに現れます。</para>
<para>より正しく言うと、一度ページから外れると、ZKはもうそれをコントロールすることができません。また、アプリケーションがそのコンポーネントをこれ以上参照しないのであれば、そのコンポーネントに対応するメモリはJVMのGabageCollectorによって開放されます。</para></sect1></chapter>
<chapter>
<title>5. イベントの監視・処理</title>
<para>このチャプターはどのようにイベントが処理されるかを説明します。</para><sect1><title>マークアップ言語によるイベントリスナの追加</title>
<para>イベントリスナを追加する最も簡単な方法はZUMLページで属性を宣言することです。イベントを監視する属性の値はBeanShellが翻訳できるJavaコードでしたら何でもOKです。</para>
<programlisting>&lt;window title="Hello" border="normal"&gt;&#13;    &lt;button label="Say Hello" onClick="alert(&amp;quot;Hello World!&amp;quot;)"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>プログラムによるイベントリスナの追加・削除</title>
<para>プログラムによってイベントリスナを追加する方法は二つあります。</para><sect2><title>メンバーを宣言する</title>
<para>ユーザーによって作られたクラスを使ってコンポーネントをオーバーライドするとき、以下のようにメンバーファンクションをイベントリスナとして宣言できます。</para>
<para>ZUMLページの中で、use属性を宣言することでデフォルト以外のクラスを指定できます。以下に書いたようにZKに<code>org.zkoss.zul.Window</code>
<footnote>
<para>デフォルトクラスは<code>zul.jar</code>にある<code>lang.xml</code>に定義されています。 </para>
</footnote>の代わりに<code>MyClass</code>を使用させます。</para>
<programlisting>&lt;window use="MyClass"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>そうして、以下のようにデフォルトクラスから拡張することで<code>MyWindow.java</code>を実装します。</para>
<programlisting>public class MyWindow extends org.zkoss.zul.Window {&#13;    public void onOK() { //add an event listener    &#13;        ...//handles the onOK event (sent when ENTER is pressed)        &#13;    }    &#13;}&#13;</programlisting>
<para>以下のように宣言すると、イベントについてより多くの情報を取得できます。</para>
<programlisting>public void onOK(org.zkoss.zk.ui.event.KeyEvent event) {...}&#13;</programlisting>
<para>異なったイベントは異なったイベントオブジェクトに関連している可能性があります。詳しくはAppendx Cを参照ください。</para></sect2><sect2><title>動的にイベントリスナを追加と削除</title>
<para>開発者は<code>org.zkoss.zk.ui.Component</code>インターフェイスの<code>addEventListener</code>と<code>removeEventListener</code>メソッドを使って、イベントリスナを動的に追加したり削除したりします。以下に書いたように、動的に追加されるイベントリスナは<code>org.zkoss.zk.ui.Component</code>インタフェイスを実装しなければなりません。</para>
<programlisting>void init(Component comp) {&#13;    ...    &#13;    comp.addEventListener("onClick", new MyListener());    &#13;    ...    &#13;}&#13;class MyListener implements org.zkoss.zk.ui.event.EventListener {&#13;    public void onEvent(Event event) throws UiException {    &#13;        ...//processing the event        &#13;    }    &#13;}&#13;</programlisting></sect2><sect2><title>可延イベントリスナ(通信のタイミングを遅らせるイベントリスナ)</title>
<para>デフォルトではクライアントで起こったイベントはサーバーに送られます。しかし、多くのイベントリスナはユーザー側で何かを表示させるよりは、ただサーバーの状態をコントロールします。つまりこの状態制御リスナに対して起こったイベントは即座に情報を送る必要がありません。サーバーのパフォーマンスをあげるため、クライアントとサーバー間の通信量を最小にし、これらのリスナをまとめて送信します。便宜上これらを、可延イベントリスナと呼びます。</para>
<para>イベントリスナの通信を一時保留するのに<code>org.zkoss.zk.ui.event.Deferrable</code>インタフェイスを実装し、以下のように<code>isDeferrable</code>メソッドにtrueを返します。</para>
<programlisting>public class DeferrableListener implements EventListener, Deferrable {&#13;    private boolean _modified;    &#13;    public void onEvent(Event event) {    &#13;        _modified = true;        &#13;    }    &#13;    public boolean isDeferrable() {    &#13;        return true;        &#13;    }    &#13;}&#13;</programlisting>
<para>クライアントでイベントが発生したとき(例えば、ユーザーがリスト項目を選択したとき)、可延リスナだけが登録しているか、又は、イベントリスナが全く登録していない場合、ZKはイベントを送信しません。代わりに、イベントはクライアント側の待ち行列に保存されます。</para>
<para>少なくともひとつ可延でないリスナが登録しているのであれば、イベントはすぐにすべて待ち行列にあるイベントとともにサーバーへ送られます。すべてのイベントは順番通り送信されます。</para>
<para>【ヒント】：可延リスナを使って、サーバーの状態を維持します。一方、ユーザー側での視覚的な変更は。不可延リスナを使用します。</para></sect2><sect2><title>動的にページにてイベントリスナを追加と削除</title>
<para>開発者は動的にページへ(org.zkoss.zk.ui.Page)イベントリスナを追加できます。一度付加されると、指定したページのコンポーネントに名前が指定されたすべてのイベントはリスナへ送られます。</para>
<para>すべてのページイベントリスナは即時に作動するものではありません。つまり<code>isArap</code>メソッドは無視されます。</para>
<para>代表的な例はページ単位のイベントリスナを使用して、以下のように”変更フラグ”をコントロールします。</para>
<programlisting>public class ModificationListener implements EventListener, Deferrable {&#13;    private final Window _owner;    &#13;    private final Page _page;    &#13;    private boolean _modified;    &#13;&#13;    public ModificationListener(Window owner) {    &#13;        //Note: we have to remember the page because unregister might        &#13;        //be called after the owner is detached        &#13;        _owner = owner;        &#13;        _page = owner.getPage();        &#13;        _page.addEventListener("onChange", this);        &#13;        _page.addEventListener("onSelect", this);        &#13;        _page.addEventListener("onCheck", this);        &#13;    }    &#13;    /** Called to unregister the event listener.    &#13;     */    &#13;    public void unregister() {    &#13;        _page.removeEventListener("onChange", this);        &#13;        _page.removeEventListener("onSelect", this);        &#13;        _page.removeEventListener("onCheck", this);        &#13;    }    &#13;    /** Returns whether the modified flag is set.    &#13;     */    &#13;    public boolean isModified() {    &#13;        return _modified;        &#13;    }    &#13;    //-- EventListener --//    &#13;    public void onEvent(Event event) throws UiException {    &#13;        _modified = true;        &#13;    }    &#13;    //-- Deferrable --//    &#13;    public boolean isDeferrable() {    &#13;        return true;        &#13;    }    &#13;}&#13;</programlisting>
<para>【メモ】：<code>Deferrable</code>
<code> </code>インターフェイスを実装するかどうかはこの例の中ではオプションです。それはページイベントリスナは<code>Deferrable</code> を実装しなくてもデフォルトでも可延であるからです。</para></sect2><sect2><title>呼び出し順序</title>
<para>イベントリスナの呼び出す順序は以下の通りです。<code>onClick</code>イベントが届いたと想定しましょう。</para>
<orderedlist>
<listitem>
<para>目的コンポーネントへ追加された<code>onClick</code>イベントのリスナをひとつずつ呼び出します。ただしこれは、リスナが<code>org.zkoss.zk.ui.event.Express</code>インターフェイスを実装する場合のみです。また、追加される順番と呼び出される順番は同じです。</para>
</listitem>
<listitem>
<para>目的コンポーネントの中の<code>onClick</code>属性に明記したスクリプトを呼び出します。</para>
</listitem>
<listitem>
<para>
<code>org.zkoss.zk.ui.event.Express</code>インタフェイスを実装していない目的コンポーネントへ追加された<code>onClick</code>イベントのリスナをひとつずつ呼び出します。追加される順番と呼び出される順番は同じです。</para>
</listitem>
<listitem>
<para>目的コンポーネントの<code>onClick</code>メンバーメソッドを呼び出します。</para>
</listitem>
<listitem>
<para>目的コンポーネントが属しているページへ追加された<code>onClick</code>イベントに対してイベントリスナを呼び出します。追加される順番と呼び出される順番は同じです。</para>
</listitem>
</orderedlist>
<para>
<code>org.zkoss.zk.ui.event.Express</code>インタフェイスは装飾用のインタフェイスです。イベントリスナの呼び出される優先順位を変更する際に使用します。イベントリスナがコンポーネントではなく、ページへ追加された場合は、このインターフェースは使用できません。</para></sect2><sect2><title>呼び出し順序を中止</title>
<para>
<code>org.zkoss.zk.ui.event.Event</code>クラスの中の<code>stopPropagation</code>メソッドを呼ぶことで呼び出し順序を中止できます。一度あるイベントリスナがこのメソッドを呼び出すと、それ以降のすべてのイベントリスナは無視されます。</para></sect2></sect1><sect1><title>イベントリスナからイベントを送信と生成</title>
<para>イベントを受け取ることに加えて、イベントを生成または送信することでアプリケーションは多くのイベントリスナ間で通信できます。</para><sect2><title>イベントを生成</title>
<para>
<code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>postEvent</code>メソッドを使って、イベントリスナはイベント待ち行列の最後にイベントを追加できます。待ち行列にイベントを置いた後、すぐに戻ります。追加されたイベントは待ち行列にあるイベントがすべて処理された後、処理されます。</para></sect2><sect2><title>イベントを送信</title>
<para>
<code>org.zkoss.zk.ui.event.Events</code>クラス中の<code>sendEvent</code>メソッドを使うことでイベントリスナはZKにすぐに指定したイベントを処理させます。指定されたイベントのイベントリスナがすべて処理されるまで、このプロセスは続きます。なお、イベントは同じスレッド内で処理されます。</para></sect2></sect1><sect1><title>スレッドモデル</title>
<para>ひとつのデスクトップにあるイベントは順番に処理されるので、スレッドモデルは簡単です。 デスクトップアプリケーションを開発するように、マルチスレッドと競合を心配する必要はありません。必要なのはイベントリスナを登録し、そして、呼び出されたときにイベントを処理することです。</para>
<para>【ヒント】：イベントリスナはイベント処理スレッドと呼ばれる独立したスレッドの中で実行します。一方、ZUMLページはサーブレットスレッドの中で処理されます。</para>
<para>【ヒント】：イベント処理スレッドを無効にし、すべてのイベントをサーブレットスレッドの中で処理させることができます。これによって、処理速度を速くし、統合問題を少なくします。しかし、処理を一時中断させることはできません。詳しくは上級者のための機能の章のサーブレットスレッドを使用してイベントを処理セクションを参照してください。</para><sect2><title>中断と再開</title>
<para>アドバンスアプリケーションでは、いくつかの条件を満足するまで処理を一時中断させなければならないことがあります。<code>org.zkoss.zk.ui.Executions</code>クラスの<code>wait</code>と<code>notify</code>と<code>notifyAll</code>メソッドはこの目的のために作られました。</para>
<para>イベントリスナが自身を一時中断させるには<code>wait</code>メソッドを使用します。アプリケーションの条件が満足したら、他のスレッドは<code>notify</code>又は<code>notifyAll</code>でそれを呼び起こします。モーダルダイアログはこのメカニズムを使った代表的な例です。</para>
<programlisting>public void doModal() throws InterruptedException {&#13;    ...Executions.wait(_mutex); //suspend this thread, an event processing thread}    &#13;public void endModal() {&#13;...&#13;    Executions.notify(_mutex); //resume the suspended event processing thread    &#13;}&#13;</programlisting>
<para>これらの使用は<code>java.lang.Object</code>クラスの<code>wait</code>、<code>notify</code>と<code>notigyAll</code>と同じです。しかし、<code>java.lang.Object</code>クラスのメソッドを使い、イベントリスナを中断や再開できません。さもなければ、関連したデスクトップのすべてのイベント処理はコントロールできなくなります。</para>
<para>Javaオブジェクトの<code>wait</code>と<code>notify</code>とは違って、<code>synchronized </code>ブロックで<code>Executionsのwait</code>と<code>notify</code>を含むかは自由です。上記のケースでは競合問題にはなりえないので、ブロックを使わなくても結構です。しかし、競合状態になる可能性があれば、Javaオブジェクトの<code>wait</code>と<code>notify</code>を処理するのと同じように<code>synchronized </code>ブロックを使います。</para>
<programlisting>//Thread 1&#13;public void request() {&#13;    ...    &#13;    synchronized (mutex) {    &#13;        ...//start another thread        &#13;        Executions.wait(mutex); //wait for its completion        &#13;    }    &#13;}&#13;&#13;//Thread 2&#13;public void process() {&#13;    ... //process it asynchronously    &#13;    synchronized (mutex) {    &#13;        Executions.notify(mutex);        &#13;    }    &#13;}&#13;</programlisting></sect2><sect2><title>長時間処理</title>
<para>同じデスクトップのイベントは順番に処理されます。つまりイベントハンドラは以下のどのハンドラも遮断します。イベントハンドラが実行するのに時間が長ければ、ユーザーのリクエストを遮断する時間も長くなります。デスクトップアプリケーションのように、ワーキングスレッドを作り、長時間処理の遮断時間を最小にするようにしなければなりません。</para>
<para>HTTPの制限により、以下のルールに従っているかどうかを確認しなければなりません。</para>
<itemizedlist>
<listitem>
<para>ワーキングスレッドを作った後に、<code>Org.zkoss.zk.ui.Executions</code>クラスの<code>wait</code>メソッドを使い、イベントハンドラ自体を一時中断させます。</para>
</listitem>
<listitem>
<para>ワーキングスレッドはイベントリスナではないので、コンポーネントにアクセスすることができません。ただし、どのデスクトップにも属していないコンポーネントでしたらアクセスできます。ですので、ワーキングスレッドを開始する前に、必要な情報を手動で追加する必要があります。</para>
</listitem>
<listitem>
<para>そして、ワーキングスレッドは必要に応じて、情報を削除したり、コンポーネントを作成したりします。ただし、デスクトップに属しているコンポーネントを参照しないことに注意しましょう。</para>
</listitem>
<listitem>
<para>ワーキングスレッドが終了したら、その中にある<code>org.zkoss.zk.ui.Executions</code>クラスの中の<code>Notify(Desktop desktop, Object flag)</code>又は<code>notifyAll(Desktop desktop, Object flag)</code>メソッドを使って、イベントハンドラを再開します。</para>
</listitem>
<listitem>
<para>他のイベントがクライアントから送られてくるまで、再開されたイベントハンドラは実行されません。強制的にイベントを送信させるには、タイマーコンポーネント<code>(org.zkoss.zul.Timer)</code>を使い、イベントを少し後にまたは周期的に起こします。このタイマーのイベントリスナは何もしないか、状態の更新を行います。</para>
</listitem>
</itemizedlist><sect3><title>例：ワーキングスレッドが非同期ラベルを作成</title>
<para>ラベルを非同期的に生成することを想定します。もちろん、マルチスレッドでそのような簡単なタスクをするのは効率的ではありませんが、この例を参考にして、複雑なタスクで使用してください。</para>
<programlisting>//WorkingThread&#13;package test;&#13;public class WorkingThread extends Thread {
   private static int _cnt;

   private Desktop _desktop;
   private Label _label;
   private final Object _mutex = new Integer(0);

   /** Called by thread.zul to create a label asynchronously.
    * To create a label, it start a thread, and wait for its completion.
    */
   public static final Label asyncCreate(Desktop desktop)
   throws InterruptedException {
      final WorkingThread worker = new WorkingThread(desktop);
      synchronized (worker._mutex) { //to avoid racing
         worker.start();
         Executions.wait(worker._mutex);
         return worker._label;
      }
   }
   public WorkingThread(Desktop desktop) {
      _desktop = desktop;
   }
   public void run() {
      _label = new Label("Execute "+ ++_cnt);
      synchronized (_mutex) { //to avoid racing
         Executions.notify(_desktop, _mutex);
      }
   }
}&#13;</programlisting>
<para>次に、<code>onClick</code>のようなイベントリスナでワーキングスレッドを呼び出すZUMLページを作成します。</para>
<programlisting>&lt;window id="main" title="Working Thread"&gt;
   &lt;button label="Start Working Thread"&gt;
   &lt;attribute name="onClick"&gt;
   timer.start();
   Label label = test.WorkingThread.asyncCreate(desktop);
   main.appendChild(label);
   timer.stop()
      &lt;/attribute&gt;
   &lt;/button&gt;
   &lt;timer id="timer" running="false" delay="1000" repeats="true"/&gt;
&lt;/window&gt;&#13;</programlisting>
<para>中断されているイベントリスナ(<code>onClick</code>)を再開するにはタイマーを使わなければなりません。それを不自然だと感じるかもしれませんが、それはHTTPの制限によるものです：ブラウザでページを存続させるには、イベント処理が一時中断されているときでもレスポンスをしなければいけません。その結果、ワーキングスレッドが役割を果たしてイベントリスナに通知したとき、HTTPのリクエストはすでになくなっています。それを解決するため、タイマーを使用します。</para>
<para>より正しくいうと、ワーキングスレッドがイベントリスナへ再開を通知するとき、ZKは順番待ちのリストに再開通知を追加するだけです。他のHTTPリクエストを受け取ってからリスナが本当に再開されます。(上の例ではそれが<code>onTimer</code>イベントです。)</para>
<para>この単純な例の中で、<code>onTimer</code>イベントを操作しませんでした。複雑なアプリケーションを処理する場合、<code>onTimer</code>で処理のステータスを送信することもできます。</para></sect3><sect3><title>方法１：タイマー(再開/中断なし)</title>
<para>中断と再開なしで長時間処理を実装することは可能です。同期コードが複雑になる場合にとても便利です。</para>
<para>そのアイデアは単純です。ワーキングスレッドはある場所に結果を一時的に保存します。そして、<code>onTimer</code>イベントリスナは結果をデスクトップへ表示させます。</para>
<programlisting>//WorkingThread2&#13;package test;&#13;public class WorkingThread2 extends Thread {
   private static int _cnt;

   private final Desktop _desktop;
   private final List _result;

   public WorkingThread2(Desktop desktop, List result) {
      _desktop = desktop;
      _result = result;
   }   public void run() {
      _result.add(new Label("Execute "+ ++_cnt));
   }
}&#13;</programlisting>
<para>そして、onTimerイベントリスナの中にラベルを付加します。</para>
<programlisting>&lt;window id="main" title="Working Thread2"&gt;
   &lt;zscript&gt;
   int numPending = 0;
   List result = Collections.synchronizedList(new LinkedList());
   &lt;/zscript&gt;
   &lt;button label="Start Working Thread"&gt;
      &lt;attribute name="onClick"&gt;
   ++numPending;   timer.start;
  new test.WorkingThread2(desktop, result).start();
      &lt;/attribute&gt;
   &lt;/button&gt;
   &lt;timer id="timer" running="false" delay="1000" repeats="true"&gt;
      &lt;attribute name="onTimer"&gt;
   while (!result.isEmpty()) {
      main.appendChild(result.remove(0));
      --numPending;
   }
   if (numPending == 0) timer.stop();
      &lt;/attribute&gt;
   &lt;/timer&gt;
&lt;/window&gt;</programlisting></sect3><sect3><title>方法２：ピギーバック(中断、再開、タイマーなし)</title>
<para>周期的に結果を検査する代わりに、例えば、ユーザーがボタンをクリックしたり何かを入力したりするときに便乗し、クライアントへ送信することができます。</para>
<para>それをするには、ルートコンポーネントの<code>onPiggyback</code>イベントにイベントリスナを登録します。そうすると、ZK Update Engine がイベントを処理するたびにリスナが呼び出されます。例えば、以下のようにコードを書き換えることができます。</para>
<programlisting>&lt;window id="main" title="Working Thread3" onPiggyback="checkResult()"&gt;&#13;    &lt;zscript&gt;    &#13;    List result = Collections.synchronizedList(new LinkedList());    &#13;&#13;    void checkResult() {    &#13;        while (!result.isEmpty())        &#13;            main.appendChild(result.remove(0));            &#13;    }    &#13;    &lt;/zscript&gt;    &#13;    &lt;button label="Start Working Thread"&gt;    &#13;        &lt;attribute name="onClick"&gt;        &#13;    timer.start();    &#13;    new test.WorkingThread2(desktop, result).start();    &#13;        &lt;/attribute&gt;        &#13;    &lt;/button&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>Piggybackのいいところは、クライアントとサーバー間の通信パケットを増やさないことです。しかし、この方法だと、クリックや入力などのユーザーの操作がなければ、ページは更新されません。ですので、Piggybackを適用できるかどうかはそのアプリケーションの要求しだいです。</para>
<para>【補足】：可延イベントはすぐにクライアントに送られることはありませんので、不可延のイベントが起こったときにのみ<code>onPiggyback</code>イベントは発生します。可延イベントリスナセクションを参照してください。</para></sect3></sect2></sect1><sect1><title>イベント処理スレッドを初期化とクリーンアップ</title><sect2><title>各イベントを処理する前に初期化</title>
<para>イベント処理スレッドの中でイベントリスナは実行されます。イベントを処理する前にスレッドを初期化しなければならない場合もあります。</para>
<para>代表的な例はユーザー認証スレッドの初期化です。一部のJ2EE又はウェブコンテナは、ユーザー認証用の情報をスレッドローカルメモリに保存し、必要なときに自動的に最認証できるようにしています。</para>
<para>イベント処理スレッドを初期化するのに、<code>org.zkoss.zk.ui.event.EventThreadInit</code>インターフェイスを実装するクラスを<code>WEB-INF/zk.xml</code>ファイルの<code>listener</code>
<code> </code>要素に登録しなければなりません<footnote>
<para>詳細は開発用リファレンスのAppendix Bを参照してください。 </para>
</footnote>。</para>
<para>登録できたら、指定したクラスのインスタンスはイベント処理スレッドが始まる前に、メインスレッドに構築されます(aka.、サーブレッドスレッド)。そして、何よりも先に、インスタンスの<code>init</code>メソッドはイベント処理の状況で呼び出されます。</para>
<para>コンストラクタとinitコマンドは異なったスレッドの中に呼び出されて、開発者はスレッド依存するデータをひとつのスレッドから取得し、他へ送ります。</para>
<para>ここにJBossのユーザー認証メカニズムの例をあげます<footnote>
<para>http://www.jboss.org</para>
</footnote>。この例では、コンストラクタの中のサーブレッドスレッドに保存されている情報を取得します。そうして、initメソッドが呼ばれたときにイベント処理スレッドを初期化します。</para>
<programlisting>import java.security.Principal;&#13;import org.jboss.security.SecurityAssociation;&#13;import org.zkoss.zk.ui.Component;&#13;import org.zkoss.zk.ui.event.Event;&#13;import org.zkoss.zk.ui.event.EventThreadInit;&#13;&#13;public class JBossEventThreadInit implements EventThreadInit {&#13;    private final Principal _principal;    &#13;    private final Object _credential;    &#13;    /** Retrieve info at the constructor, which runs at the servlet thread. */    &#13;    public JBossEventThreadInit() {    &#13;        _principal = SecurityAssociation.getPrincipal();        &#13;        _credential = SecurityAssociation.getCredential();        &#13;    }    &#13;    //-- EventThreadInit --//    &#13;    /** Initial the event processing thread at this method. */    &#13;    public void init(Component comp, Event evt) {    &#13;        SecurityAssociation.setPrincipal(_principal);        &#13;        SecurityAssociation.setCredential(_credential);        &#13;    }    &#13;}&#13;</programlisting>
<para>そして、<code>WEB-INF/zk.xml</code>の中で以下のように指定しなければなりません。</para>
<programlisting>&lt;zk&gt;&#13;    &lt;listener&gt;    &#13;        &lt;listener-class&gt;JBossEventThreadInit&lt;/listener-class&gt;        &#13;    &lt;/listener&gt;    &#13;&lt;/zk&gt;&#13;</programlisting></sect2><sect2><title>各イベントを処理した後にクリーンアップ</title>
<para>同様にして、イベントを処理した後に、イベント処理スレッドを削除しなければなりません。</para>
<para>適切に終了していなかった処理を終了させるのが代表的な例です。</para>
<para>イベント処理スレッドをクリーンアップには、<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>インターフェイスを実装するリスナクラスを<code>WEB-INF/zk.xml</code>ファイルの<code>listener</code>
<code> </code>要素に登録しなければなりません。</para>
<programlisting>&lt;zk&gt;&#13;    &lt;listener&gt;    &#13;        &lt;listener-class&gt;my.MyEventThreadCleanup&lt;/listener-class&gt;        &#13;    &lt;listener&gt;    &#13;&lt;/zk&gt;&#13;</programlisting></sect2></sect1></chapter>
<chapter>
<title>6. ZKユーザーマークアップ言語</title>
<para>ZKユーザーインターフェースマークアップ言語(ZUML)はXMLを基にして作られています。XML要素ではどのコンポーネントが生成されるのかが書かれています。XML属性には作成されたコンポーネントに指定された初期値が書かれてあります。XMLプロセスコマンドはページ全体がどういうふうに処理されるのかを説明します。例えば、ページタイトルについてなど。</para>
<para>異なったコンポーネントセットはXMLネーム空間によって区別されています。例えば、XULのネーム空間は <code>http://www.zkoss.org/2005/zul</code>
<footnote>
<para>
<code>http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul.</code>
<code> </code>という名前になっていますが、non-XUL の特徴もたくさん追加されているので、独立したネーム空間を使いましょう。</para>
</footnote> です。また、XHTMLのネーム空間は<code> </code>
<code>http://www.w3.org/1999/xhtml</code>です。</para><sect1><title>XML</title>
<para>この章ではZKとともにXMLの基本的なコンセプトを紹介します。XMLをよくご存知の場合、この章を飛ばしてください。また、インターネットに関連するリソースがたくさんあります。たとえば、 <code>http://www.xml.com/pub/a/98/10/guide0.html</code>
と<code>http://www.w3schools.com/xml/xml_whatis.asp</code>です。
</para>
<para>XMLはHTMLのようなマークアップ言語ですが、より厳密でより簡潔な言語です。そこにはいくつかの注目すべき特徴があります。 </para><sect2><title>要素の良形式化</title>
<para>はじめに、どの要素も括弧でくくられていなければなりません。以下に示したように、要素を括弧でくくる方法は二つありますが、どちらを使っても結果は同じです。 </para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>タグを使用して閉じる:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt;&lt;<code>window</code>/&gt;</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>終端タグなしで閉じる:</para>
</entry>
<entry>
<para>&lt;<code>window</code>/&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>二つ目に、要素は順序を適切にかかなければなりません。 </para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>正しい:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt; &lt;<code>groupbox</code>&gt;    <code>Hello</code> <code>World</code>!    &lt;/<code>groupbox</code>&gt;&lt;/<code>window</code>&gt;</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>間違い:</para>
</entry>
<entry>
<para>&lt;<code>window</code>&gt; &lt;<code>groupbox</code>&gt;    <code>Hello</code> <code>World</code>! &lt;/<code>window</code>&gt;&lt;/<code>groupbox</code>&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title/></sect2><sect2><title>特別な記号は取り替えなければなりません</title>
<para>XMLは　<code>&lt;</code>
<code>element-name</code>
<code>&gt;</code>　を使って要素を示すので、特別な記号は別表記します。例えば、&amp;lt;を使って &lt; の記号を表します。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Special Character</para>
</entry>
<entry>
<para>Replaced With</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>&lt;</para>
</entry>
<entry>
<para>
<code>&amp;lt;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>&gt;</code>
</para>
</entry>
<entry>
<para>
<code>&amp;gt;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>&amp;</code>
</para>
</entry>
<entry>
<para>
<code>&amp;amp;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>"</code>
</para>
</entry>
<entry>
<para>
<code>&amp;quot;</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>'</code>
</para>
</entry>
<entry>
<para>
<code>&amp;apos;</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>代わりに、以下のように<code>CDATA</code>を使用してXMLパーサ(構文解析プログラム)にプログラムを変換させないようにできます。</para>
<programlisting>&lt;zscript&gt;&#13;&lt;![CDATA[&#13;void myfunc(int a, int b) {&#13;          if (a &lt; 0 &amp;&amp; b &gt; 0) {    &#13;                    //do something        &#13;          }    &#13;]]&gt;&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>バックスラッシュ（\）は特別な記号ではありません。特に避ける必要はありません。</para></sect2><sect2><title>属性値は指定し引用しなければなりません</title>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>正しい:</para>
</entry>
<entry>
<para>
<code>width="100%"</code>
</para>
<para>
<code>checked="true"</code>
</para>
</entry>
</row>
</tbody><tbody>
<row>
<entry>
<para>間違い:</para>
</entry>
<entry>
<para>
<code>width=100%</code>
</para>
<para>
<code>checked</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>コメント</title>
<para>コメントはXMLコード部分を一時的に機能しないようにするか、またはノート注解をそのまま残すために使います。XMLにコメントを付加するのに&lt;!--と--&gt;を使します。くくられた部分はインタープリットされません。</para>
<programlisting>&lt;window&gt;&#13;&lt;!-- this is a comment and ignored by ZK --&gt;&#13;&lt;/window&gt;&#13;</programlisting>
</sect2><sect2><title>文字のエンコード</title>
<para>オプションですが、XMLの中でエンコードを指定したら、XMLパーサ(構造解析プログラム)は正確に翻訳してくれます。メモ：ファイルの初めの行で指定しなければなりません。</para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;</programlisting>
<para>正しいエンコーディングを指定する他、必ずXMLエディタがサポートしていることも確認してください。 </para></sect2><sect2><title>ネーム空間</title>
<para>ネーム空間はXMLのプログラム中で使われた名前を区別する簡単な方法です。ZKはXMLネーム空間を使用してコンポーネント名を区別し、違うネーム空間である限り、二つのコンポーネントに同じ名前を使うことは可能です。要するに、ZKはXMLネーム空間を使いコンポーネントセットを表します。そうして、以下に示すように、ディベロッパーは同ページ内で二つ以上のコンポーネントセットを使用することができます。</para>
<programlisting>&lt;html xmlns:="http://www.w3.org/1999/xhtml"&#13; xmlns:x="http://www.zkoss.org/2005/zul"&#13; xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;table&gt;&#13;   &lt;tr&gt;&#13;      &lt;td&gt;&lt;x:textbox/&gt;&lt;/td&gt;&#13;      &lt;td&gt;&lt;x:button label="Now" zk:onClick="addItem()"/&gt;&lt;/td&gt;&#13;   &lt;/tr&gt;&#13;   &lt;/table&gt;&#13;&#13;   &lt;zk:zscript&gt;&#13;   void addItem() {&#13;   }&#13;   &lt;/zk:zscript&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>定義</para>
<itemizedlist>
<listitem>
<para>
<code>xmlns:x=</code>
<code>http://"www.zkoss.org/2005/zul</code>
<code>"</code>
<code> </code>は<code>http://www.zkoss.org/2005/zul</code>と呼ばれるネーム空間を指定し、ｘを使ってこのネーム空間を表しています。</para>
</listitem>
<listitem>
<para>
<code>xmlns:="http://www.w3.org/1999/xhtml"</code> は<code>http://www.w3.org/1999/xhtml</code>
<code> </code>と呼ばれるネーム空間を表し、それをデフォルトとして使用します。</para>
</listitem>
<listitem>
<para>
<code>&lt;html&gt;</code> はネーム空間のhtmlと呼ばれる要素を表します。この例では、 <code>http://www.w3.org/1999/xhtml</code> </para>
</listitem>
<listitem>
<para>
<code>&lt;x:textbox/&gt;</code>はtextboxと呼ばれる要素を<code>http://www.zkoss.org/2005/zul</code>と呼ばれるネーム空間から引用して指定しています。</para>
</listitem>
</itemizedlist><sect3><title>スキーマで自動補完</title>
<para>EclipseなどのIDEにてXML スキーマを以下のように指定すれば、自動補完ができます。</para>
<programlisting>&lt;window xmlns="http://www.zkoss.org/2005/zul"&#13;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&#13;xsi:schemaLocation="http://www.zkoss.org/2005/zul http://www.zkoss.org/2005/zul/zul.xsd"&gt;&#13;</programlisting>
<para>
<code>zul.xsd </code>
は
<code>http://www.zkoss.org/2005/zul/zul.xsd</code>からダウンロードするか、ZKパッケージの<code>dist/xsd</code> ディレクトリーからコピーできます。</para></sect3></sect2></sect1><sect1><title>条件付き処理</title>
<para>条件付きで要素を処理することができます。<code>i</code>
<code>f</code>と<code>unless</code>属性どちらか、又は両方を指定することで、ディベロッパーは関連している要素を処理するかどうかが決められます。</para>
<para>以下の例では、aが１で、bが2ではない場合のみ、ウィンドウコンポーネントは作成されます。要素が無視される場合、そのすべての子要素も無視されます。</para>
<programlisting>&lt;window if="${a==1}" unless="${b==2}"&gt;&#13;          ...    &#13;&lt;/window&gt;&#13;</programlisting>
<para>以下の例はJavaコードをいつ翻訳するか決めています。</para>
<programlisting>&lt;textbox id="contributor"/&gt;&#13;&lt;zscript if="${param.contributor}"&gt;&#13;          contributor.label = Executions.getCurrent().getParameter("contributor");    &#13;&lt;/zscript&gt;&#13;</programlisting></sect1><sect1><title>繰り返し</title>
<para>同じ処理を何回もさせることができます。<code>forEach</code>属性にオブジェクト集(コレクション)を指定することで、ディベロッパーは関連している要素の処理回数を決めます。便宜上、要素が<code>forEach</code>属性に指定される場合、その要素を繰り返し要素と呼びます。</para>
<para>以下の例でリスト項目は三回作成されます。集合を指定するのに、EL表記を使わなければなりません。 </para>
<programlisting>&lt;listbox&gt;&#13;  &lt;zscript&gt;&#13;  grades = new String[] {"Best", "Better", "Good"};&#13;  &lt;/zscript&gt;&#13;  &lt;listitem label="${each}" forEach="${grades}"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>繰り返す方式は<code>forEach</code>属性の指定された値のタイプによって違います。</para>
<itemizedlist>
<listitem>
<para>値が<code>java.util.Collection</code>場合、コレクションのそれぞれの要素に処理が繰り返されます。</para>
</listitem>
<listitem>
<para>値が<code>Java.util.Map</code>場合、それぞれマップの<code>Map.Entry</code>に処理が繰り返されます。</para>
</listitem>
<listitem>
<para>値が<code>Java.util.Iterator</code>場合、iteratorにある要素に処理が繰り返されます。</para>
</listitem>
<listitem>
<para>値が、<code>java.utilEnumeration</code>場合、一覧表のそれぞれの要素に処理が繰り返されます。</para>
</listitem>
<listitem>
<para>
<code>Object[]</code>、<code>Int[]</code>、<code>short[]</code>、<code>byte[]</code>、<code>char[]</code>、<code>char[]</code>、<code>float[]</code>、<code>double[]</code>が指定される場合、配列のそれぞれの要素に繰り返されます。</para>
</listitem>
<listitem>
<para>
<code>null</code>の場合、何も生成されません(無視されます)。</para>
</listitem>
<listitem>
<para>上のタイプのどれにもあてはまらない場合、一項目のみであるように、関連した要素は一度だけ処理されます。</para>
</listitem>
</itemizedlist>
<programlisting>&lt;listbox&gt;&#13;  &lt;listitem label="${each}" forEach="grades"/&gt;&#13;&lt;/listbox&gt;&#13;</programlisting><sect2><title>
<code>each</code> 変数</title>
<para>処理中、<code>each</code>と呼ばれる変数は作成され、指定されたコレクションの項目に指定されます。上の例では最初の繰り返し処理の中で、<code>each</code>にBestが指定されて、次にBetterが指定され、最後にGoodが指定されます。</para>
<para>
<code>each</code>変数はEL表記と<code>zscript</code>どちらを使っても参照することができます。<code>each</code>変数の値は一度定義されたら、ZKはそれを関連要素の処理が終わるまで保存します。 </para></sect2><sect2><title>
<code>forEachStatus </code>変数</title>
<para>
<code>forEachStatus</code>変数は<code>org.zkoss.ui.util.ForEachStatus</code>のインスタンスです。現在の繰り返し処理についての情報を持っています。主に、<code>forEach</code>属性に指定された括弧でくくられた要素の項目を取得します。</para>
<para>以下の例では入れ子状態の繰り返しを使い、二つのリストボックスを生成します。</para>
<programlisting>&lt;hbox&gt;&#13;    &lt;zscript&gt;&#13;classes = new String[] {"College", "Graduate"};&#13;grades = new Object[] {&#13;    new String[] {"Best", "Better"}, new String[] {"A++", "A+", "A"}&#13;};&#13;    &lt;/zscript&gt;&#13;    &lt;listbox width="200px" forEach="${classes}"&gt;&#13;        &lt;listhead&gt;&#13;            &lt;listheader label="${each}"/&gt;&#13;        &lt;/listhead&gt;&#13;        &lt;listitem label="${forEachStatus.previous.each}: ${each}"&#13;        forEach="${grades[forEachStatus.index]}"/&gt;&#13;    &lt;/listbox&gt;&#13;&lt;/hbox&gt;&#13;</programlisting>
<para>
<graphic align="center" fileref="img/10000000000001A20000004E0C4C66ED.png">2
			
		</graphic>
<code>forEachStatus</code>変数はEL表記と<code>zscript</code>どちらを使っても参照することができます。.</para></sect2><sect2><title>イベントリスナ中の<code>each</code>と<code>forEachStatus</code>変数の使用方法</title>
<para>イベントリスナ中でforEachと<code>forEachStatus</code>を使うことは、コンポーネント作成段階<footnote>
<para>コンポーネントのライフサイクルの章をご覧ください。</para>
</footnote>でのみ使用可能なので注意を払わなければなりません。こうして、以下の例は正しくありません。<code>onClick</code>リスナが呼び出されると、<code>each</code>変数が使えなくなります。 </para>
<para/>
<para/>
<programlisting>&lt;window title="Countries" border="normal" width="100%"&gt;&#13;          &lt;zscript&gt;&lt;![CDATA[    &#13;          String[] countries = {    &#13;                    "China", "France", "Germany", "United Kindom", "United States"};        &#13;          ]]&gt;&lt;/zscript&gt;    &#13;&#13;          &lt;hbox&gt;    &#13;                    &lt;button label="${each}" forEach="${countries}"        &#13;                              onClick="alert(each)"/&gt; &lt;!-- incorrect!! --&gt;            &#13;          &lt;/hbox&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>同じ段階(コンポーネント作成段階)で行われるので、ボタンのラベルは正確に指定されています。</para>
<para>また、イベントリスナ中でEL表記を使うことはできません。例えば、<code>Onclick</code>リスナはJavaコードではないので以下のコードは実行失敗してしまいます。(つまり、EL表記は<code>zscript</code>中で無視されます。)</para>
<programlisting>&lt;button label="${each}" forEach="${countries}"&#13;                    onClick="alert(${each})"/&gt; &lt;!-- incorrect!! --&gt;        &#13;</programlisting><sect3><title>解決策：　custom-attributes</title>
<para>
<code>each</code>(と<code>forEachStatus</code>)のコンテンツをどこかに保存すれば問題は解決します。保存したコンテンツはリスナ実行中でも使用可能です。また、コンテンツはどこでも保存可能ですが、以下のようにするとわかりやすいです。</para>
<programlisting>&lt;window title="Countries" border="normal" width="100%"&gt;&#13;          &lt;zscript&gt;&lt;![CDATA[    &#13;          String[] countries = {    &#13;                    "China", "France", "Germany", "United Kindom", "United States"};        &#13;          ]]&gt;&lt;/zscript&gt;    &#13;&#13;          &lt;hbox&gt;    &#13;                    &lt;button label="${each}" forEach="${countries}"        &#13;                    onClick="alert(self.getAttribute(&amp;quot;country&amp;quot;))"&gt;        &#13;                              &lt;custom-attributes country="${each}"/&gt;            &#13;                    &lt;/button&gt;        &#13;          &lt;/hbox&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>ボタンラベルのように、custom属性のプロパティはコンポーネント作成段階で処理され、そこで<code>each</code>を使うことができます。e<code>ach</code>はcustom属性に保存され、コンポーネントが存在する限り(又は、プログラム上で削除されなければ)なくなりません。</para></sect3></sect2></sect1><sect1><title>ロードオンデマンド</title>
<para>デフォルトで、ZKはZUMLページ中で定義されたものを元にして、ページが読み込まれるときにコンポーネントを作成します。しかし、コンポーネントの部分的な作成は確認できる(visible)まで遅らせることができます。この特徴はロードオンデマンドと呼ばれています。これによって、初期段階でinvisibleコンポーネントがたくさんある場合、パフォーマンスが向上します。</para><sect2><title>
<code>fulfill</code>属性によるロードオンデマンド</title>
<para>子コンポーネント作成を遅らせる最も簡単な方法は<code>fulfill</code>属性を使うことです。例えば、以下のコード断片の<code>comboitem</code>コンポーネントは、<code>combobox</code>コンポーネントが<code>onOpen</code>イベントを受け取り、<code>comboitem</code>が参照可能になるまで、作成されることはありません。</para>
<programlisting>&lt;combobox fulfill="onOpen"&gt;&#13;          &lt;comboitem label="First Option"/&gt;    &#13;&lt;/combobox&gt;&#13;</programlisting>
<para>つまり、ZUML要素に<code>fulfill</code>属性が指定されたら、<code>fulfill</code>属性に指定された値を受信するまで、その子要素は処理されません。</para>
<para>子要素の作成を開始させるトリガの目標が他のコンポーネントの場合、以下に示すようにターゲットコンポーネントの識別子を指定します。</para>
<programlisting>&lt;button id="btn" label="show" onClick="content.visible = true"/&gt;&#13;&lt;div id="content" fulfill="btn.onClick"&gt;&#13;          Any content created automaticall when btn is clicked    &#13;
&lt;/div&gt;</programlisting>
<para>コンポーネントが違うIDスペースに属している場合、以下のようにイベント名の後にパスを指定します。</para>
<programlisting>&lt;button id="btn" label="show" onClick="content.visible = true"/&gt;&#13;&lt;window id="content" fulfill="../btn.onClick"&gt;&#13;          Any content created automaticall when btn is clicked    &#13;&lt;/window&gt;</programlisting></sect2><sect2><title>イベントリスナを使用したロードオンデマンド</title>
<para>手動で子要素を作成するか、または、動的にそれらを変更する必要がある場合、子要素が参照可能(visible)になったというイベントを確認してからイベントリスナの中で処理することができます。例えば、</para>
<programlisting>&lt;combobox id="combo" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&lt;![CDATA[&#13;          void prepare() {    &#13;                    if (event.isOpen() &amp;&amp; combo.getItemCount() == 0) {        &#13;                              combo.appendItem("First Option");            &#13;                    }        &#13;          }    &#13;
]]&gt;&lt;/zscript&gt;</programlisting></sect2></sect1><sect1><title>暗黙オブジェクト</title>
<para>ZUMLページ中に埋め込まれたスクリプトがあるので、暗黙オブジェクトを使用すれば効率的にコンポーネントを参照することができます。<code>zscript</code>要素に囲まれるJavaコードとイベントリスナを指定するための属性はこれらのオブジェクトを使用できます。また、EL表記でも使うことができます。 </para>
<para>例えば、<code>self</code>は処理されているコンポーネントを表す<code>org.zkoss.zk.ui.Component</code>のインスタンスです。以下の例で、<code>self</code>によってイベントリスナ内のコンポーネントを識別します。</para>
<programlisting>&lt;button label="Try" onClick="alert(self.label)"/&gt;&#13;</programlisting>
<para>同様にして、現イベント<code>event</code>はイベントリスナによって処理されています。このようにして、上のプログラムは以下と同様の働きをします。</para>
<programlisting>&lt;button label="Try" onClick="alert(event.target.label)"/&gt;&#13;</programlisting><sect2><title>暗黙オブジェクト一覧</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Object Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>self</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Component</code>
</para>
<para>コンポーネント自身</para>
</entry>
</row>
<row>
<entry>
<para>
<code>spaceOwner</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.IdSpace</code>
</para>
<para>このコンポーネントのスペース所有者。<code>Self.spaceOwner</code>と同じ.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>page</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Page</code>
</para>
<para>ページ。<code>SELF.PAGE</code>と同じ </para>
</entry>
</row>
<row>
<entry>
<para>
<code>desktop</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Desktop</code>
</para>
<para>デスクトップ。<code>Self.desktop</code>と同じ</para>
</entry>
</row>
<row>
<entry>
<para>
<code>session</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.Session</code>
</para>
<para>セッション</para>
</entry>
</row>
<row>
<entry>
<para>
<code>application</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.WebApp</code>
</para>
<para>ウェブアプリケーション</para>
</entry>
</row>
<row>
<entry>
<para>
<code>componentScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>コンポーネント中で定義された属性のマップ。<code>Org.zkoss.zk.ui.Component</code>インターフェース中の<code>getAttribute</code>メソッドと同じ働きです</para>
</entry>
</row>
<row>
<entry>
<para>
<code>spaceScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>このコンポーネントを含んでいるIDスペースの中で定義された属性のマップ </para>
</entry>
</row>
<row>
<entry>
<para>
<code>pageScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>ページ中で定義された属性のマップ。<code>org.zkoss.zk.ui.Page</code>インターフェース中の<code>getAttributes</code>メソッドと同じ働きです</para>
</entry>
</row>
<row>
<entry>
<para>
<code>desktopScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>デスクトップ上で定義された属性のマップ。<code>org.zkoss.zk.ui.Desktop</code>インターフェース中の<code>getAttributes</code>メソッドと同じ働きです </para>
</entry>
</row>
<row>
<entry>
<para>
<code>sessionScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>セッション中で定義された属性のマップ。<code>org.zkoss.zk.ui.Session</code>インターフェース中で<code>getAttributes</code>と同じ働きです </para>
</entry>
</row>
<row>
<entry>
<para>
<code>applicationScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>ウェブアプリケーション中で定義された属性のマップ。<code>org.zkoss.zk.ui.WebApp</code>インターフェース中の<code>getAttributes</code>メソッドと同じ働きです.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>requestScope</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>リクエスト中で定義された属性のマップ。<code>org.zkoss.zk.ui.Execution</code>中の<code>getAttributes</code>メソッドと同じ働きです </para>
</entry>
</row>
<row>
<entry>
<para>
<code>arg</code>
</para>
</entry>
<entry>
<para>
<code>java.util.Map</code>
</para>
<para>
<code>org.zkoss.zk.ui.Executions</code>クラス中で<code>createComponents</code>メソッドへ渡す引数<code>arg</code> 。それが<code>null</code>になることはありません </para>
<para>含まれたページ(<code>createComponents</code>の初め引数)にコンポーネントが作られるときのみに、<code>arg</code>は使用可能です。一方で、<code>onCreate</code>を含む、すべてのイベントは後に処理されます。こうして、<code>onCreate</code>リスナ中の<code>arg</code>を参照したいの場合、<code>org.zkoss.zk.ui.event.CreateEvent</code>クラスの<code>getArg</code>メソッドを使います。<code>Self.desktop.execution.arg</code>と同じ働きがあります </para>
</entry>
</row>
<row>
<entry>
<para>
<code>each</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Object</code>
</para>
<para>ZK繰り返し処理をするとき、繰り返されている最中のものです。繰り返し要素は<code>forEach</code>属性に伴う要素です。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>forEachStatus</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.util.ForEachStatus</code>
</para>
<para>繰り返しのステータス。ZKは繰り返し要素を処理するとき、行われている繰り返し処理に関連している情報を参照可能にします。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>event</code>
</para>
</entry>
<entry>
<para>
<code>org.zkoss.zk.ui.event.Event</code> or derived</para>
<para>現イベント。イベントリスナのみ、参照可能。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>リクエストと実行についての情報</title>
<para>
<code>org.zkoss.ui.Execution</code>インターフェースはリクエストパラメータのような現在の実行情報を提供します。現在の実行情報を得るために、以下に書かれているもののうちの一つを行います。</para>
<itemizedlist>
<listitem>
<para>コンポーネント内の場合は<code>getDesktop().getExecution()</code>を使います。</para>
</listitem>
<listitem>
<para>コンポーネント、ページ、デスクトップを参照できない場合、<code>org.zkoss.zk.ui.ExecutionKurasuno getCurrent</code>メソッドを使用します。</para>
</listitem>
</itemizedlist></sect2></sect1><sect1><title>プロセス命令</title>
<para>XMLプロセス命令はZUMLページの処理方法を説明しています。</para><sect2><title>
<code>page</code> コマンド</title>
<para>
<code>&lt;?page [id="..."] [title="..."] [style="..."] [language="xul/html"] [zscript-language="Java"]?&gt;</code>
</para>
<para>ページの属性を定義します。</para>
<para/>
<para>【ヒント】： XMLドキュメント内のどこでも<code>page</code>コマンドをおくことができますが、最上層にコマンドを置くときのみ、<code>language</code>属性には意味があります。つまり、ルート要素と同じ階層です。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>id</code>
</para>
</entry>
<entry>
<para>[Optional][Default: generated automatically]</para>
<para>ページの識別子を指定して、検索できるようにします。</para>
<para>より詳しくは上級者のための機能の章のページ認識セクションを参照してください。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>title</code>
</para>
</entry>
<entry>
<para>[Optional][Default: none]</para>
<para>ブラウザのタイトルとして表示されるページタイトルを指定します。</para>
<para>
<code>org.zkoss.zk.ui.Page</code>インターフェース中で<code>setTitle</code>メソッドを呼ぶことで動的に変更できます。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>style</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>width:100%</code>]</para>
<para>ページを読み込むCSSスタイルを指定します。指定されていない場合、書式によって決まります。デフォルトでは幅が100％になっています。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>language</code>
</para>
</entry>
<entry>
<para>[Optional][Default: depending on the extension][<code>xul/html</code> | <code>xhtml</code>]</para>
<para>このページの言語を指定します。</para>
<para>現在、<code>xul</code>、<code>html</code>、<code>xhtml</code>が利用できます </para>
</entry>
</row>
<row>
<entry>
<para>
<code>zscript-language</code>
</para>
</entry>
<entry>
<para>[Optional][Default: Java][<code>Java</code> | <code>JavaScript</code> | <code>Ruby</code> | <code>Groovy</code>]</para>
<para>
<code>zscript</code>要素が明確にスクリプト言語を指定していないときのデフォルトのスクリプト言語を指定します。</para>
<para>言語が選択されていなかったら、Javaが採用されます。現在ZKは4つの言語が使用可能です。<code>Java</code>、<code>JavaScript</code>、<code>Ruby</code>、<code>Groovy</code>です。この選択は大文字・小文字を区別しません。</para>
<para>例えば、JavaScriptをデフォルトのスクリプト言語に指定したい場合、以下のようにします。</para>
<programlisting>&lt;?page zscript-language="JavaScript"?&gt;&#13;&#13;&lt;zscript&gt;&#13;          var m = function () {    &#13;                    //...        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>使用可能なスクリプト言語を追加することができます。他のスクリプト言語を使用セクションを参照してください</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title/></sect2><sect2><title>
<code>component </code>コマンド</title>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" macro-uri="</code>
<code>/mypath/my.zul</code>
<code>"</code> <code>[</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" [class="</code>
<code>myPackage.myClass</code>
<code>"] [extends="</code>
<code>existentName</code>
<code>"] [mold-name="</code>
<code>myMoldName</code>
<code>"] [mold-uri="/</code>
<code>myMoldUri</code>
<code>"] [</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>特定のページに新しいコンポーネントを定義します。このコマンドの中で定義されたコンポーネントはこのコマンドを使っているページだけに参照可能です。どのページ中でも、使うことができるコンポーネントを定義するため、拡張機能(ウェブアプリケーションですべてのページのコンポーネントを定義するXMLファイル)を使います。<footnote>
<para>言語拡張については the Component Development Guideをご覧ください。</para>
</footnote>
</para>
<para>マクロによるものとクラスによるものの二つのフォーマットがあります。</para><sect3><title>マクロフォーマット</title>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" macro-uri="</code>
<code>/mypath/my.zul</code>
<code>" [inline="true|</code>
<code>false</code>
<code>"] [class="</code>
<code>myPackage.myClass</code>
<code>"] </code>
<code>[</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>ZUMLページを基にした新しいコンポーネントを定義します。マクロコンポーネントと呼びます。つまり、新しいコンポーネントのインスタンスが作られると、ZUMLページ(<code>macro-uri</code>属性)を基にした子コンポーネントが作られます。より詳しくは、マクロコンポーネント章を参照してください。</para></sect3><sect3><title>クラスフォーマット </title>
<para>
<code>&lt;?component name="</code>
<code>myName</code>
<code>" [class="</code>
<code>myPackage.myClass</code>
<code>"] [extends="</code>
<code>existentName</code>
<code>"] [mold-name="</code>
<code>myMoldName</code>
<code>"] [mold-uri="/</code>
<code>myMoldUri</code>
<code>"] [</code>
<code>prop1</code>
<code>="</code>
<code>value1</code>
<code>"</code>
<code>] [</code>
<code>prop2</code>
<code>="</code>
<code>value2</code>
<code>"]...</code>
<code>?&gt;</code>
</para>
<para>
<code>extends</code>属性が指定されず、クラスに基づいている場合作られた新しいコンポーネントを<code>native component</code>と呼びます。クラスは<code>org.zkoss.zk.ui.Component</code>インターフェースを実装しなければなりません。</para>
<para>新しいコンポーネントを定義するため、<code>class</code>属性を必ずしも指定しなければなりません。そのクラス属性はZKによって使用され、コンポーネントの新しいインスタンスを提供します。</para>
<para>新しいコンポーネントを定義するほか、<code>extends</code>=”<code>existentName</code>”を指定することで存在しているコンポーネントのプロパティを上書きできます。つまり、<code>extends</code>が指定されると、指定されたコンポーネントの定義はデフォルトとして呼び出されて、このコマンドの中で定義されているプロパティのみを上書きします。</para>
<para>例えば、<code>Mywindow</code>をデフォルトのウィンドウ(ZUMLページ中の<code>org.zkoss.zul.Window</code>) の代わりに使用し、<code>mywindow</code>と呼ばれる新しいコンポーネントを定義することを想定します。そうして、以下のように宣言することができます。</para>
<programlisting>&lt;?component name="mywindow" extends="window" class="MyWindow"?&gt;&#13;...&#13;&lt;mywindow&gt;&#13;...&#13;&lt;/mywindow&gt;&#13;</programlisting>
<para>上は以下に書かれているコードと同じ働きをします。</para>
<programlisting>&lt;window use="MyWindow"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>同様にして、以下の定義を使い、<code>OK</code>をデフォルトのラベルとして使用し、青い枠をこのページの中の指定されたすべてのボタンに使います。</para>
<programlisting>&lt;?component name="okbutton" extends="button" label="OK"&#13;  style="border:1px solid blue"?&gt;&#13;</programlisting>
<para>新しいコンポーネントの名前は存在している名前と同じに設定できます。この場合、コンポーネントの指定された種類のインスタンスは存在した定義を隠すように指定した初期プロパティを使います。例えば、以下のコードはデフォルトですべてのボタンに青い枠を持つようにさせています。</para>
<programlisting>&lt;?button name="button" extends="button" style="border:1px solid blue"?&gt;&#13;
&lt;button/&gt; &lt;!-- with blue border --&gt;</programlisting>
<para>詳しくは開発用リファレンスをご覧ください。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>name</code>
</para>
</entry>
<entry>
<para>[Required]</para>
<para>コンポーネント名 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>macro-uri</code>
</para>
</entry>
<entry>
<para>[Required, if the by-macro format is used][EL is not allowed]</para>
<para>マクロフォーマットを使って、ZUMLページのURIを指定します。ZUMLページはコンポーネント作成のテンプレートとして使われます。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>クラスとマクロフォーマットの両方を使い、コンポーネントのインスタンスを例示するためのクラスを指定します。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>ext</code>
<code>ends</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>クラスフォーマットを使い、デフォルト値としてプロパティを使用するコンポーネントの名前を表します。そして、このコマンド内で定義されたプロパティのみをオーバーライドします。</para>
<para>指定されていない場合、存在しているどの定義も無視します。新しいコンポーネントは更新され、このコマンド内で定義されたプロパティを伴って定義されます。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>mold-name</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>default</code>]</para>
<para>クラスフォーマットを使ってスタイル名を指定します。<code>mold-name</code>が指定されている場合、<code>mold-uri</code>も指定されていなければなりません。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>mold-uri</code>
</para>
</entry>
<entry>
<para>[Optional][EL is allowed]</para>
<para>クラスフォーマットを使用し、URIスタイルを指定します。<code>mold-uri</code>が指 定されて、<code>mold-name</code>が指定されていない場合、形式名はデフォルトが使用されます。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>pro</code>
<code>p1</code>
<code>, </code>
<code>prop2</code>
<code>...</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>
<code>by-class</code>と<code>by-macro</code>の両方を使用して、コンポーネントの初期プロパティ(aka.,members)を指定します。</para>
<para>ZUMLによってコンポーネントが作成された場合(aka.,ZUMLページの一部分として、指定された)初期プロパティは自動的に適用されます。</para>
<para>一方、自分自身でコンポーネントを作成した場合(つまり、Javaコードを用いて作成した場合)初期プロパティは適用されません。初期プロパティを使用したい場合、<code>applyProperties</code>メソッドを呼び出します。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>init</code> コマンド</title>
<para>
<code>&lt;?init class="..." [arg0="..."] [arg1="..."] [arg2="..."] [arg3="..."]?&gt;</code>
</para>
<para>
<code>&lt;?init zscript="..." [arg0="..."] [arg1="..."] [arg2="..."] [arg3="..."]?&gt;</code>
</para>
<para>二つのフォーマットがあります。一つ目のフォーマットはクラスを指定して、カスタムアプリケーション初期化を行います。二つ目のフォーマットは<code>zscript</code>ファイルを指定して、カスタムアプリケーション初期化を行います。</para>
<para>ページが処理され、デスクトップに付加される前に初期化は行われます。こうして、初期化中、<code>getDesktop</code>、<code>getID</code>、<code>getTitle</code>メソッドは<code>null</code>を返します。現在使用中のデスクトップを検索するため、<code>org.zkoss.zk.ui.Execution</code>インターフェースを使用します。</para>
<para>
<code>init</code>コマンドの数を指定します。一番目のフォーマットを選択する場合、指定されたクラスは<code>org.zkoss.zk.ui.util.Initator</code>インターフェースを実装します。一度指定されると、クラスのインスタンスが作成されます。<code>doInit</code>メソッドはページを処理するまえに呼び出されます。</para>
<para>なお、<code>doFinally</code>メソッドはページが処理されてから呼び出されます。<code>doCatch</code>メソッドは例外が発生したときに呼び出されます。こうして、このコマンドは初期化を制限しておらず、クリーンアップとエラー処理に使用します。</para>
<para>二つ目のフォーマットを選んだら、<code>zscript</code>ファイルは処理され、タイプが<code>Object[]</code>である引数<code>args</code>と呼ばれる変数として渡されます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>
<code>org.zkoss.zk.ui.util.Initator</code>インターフェースが実装されたクラスの名前</para>
<para>ページ初期段階で<code>doInit</code>メソッドが呼び出されます。(つまり、ページが処理される前) ページが処理された後では、<code>doFinally</code>メソッドが呼び出されます。<code>doCatch</code>メソッドは処理中例外が発生した場合に呼ばれます。 .</para>
</entry>
</row>
<row>
<entry>
<para>
<code>zscript</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>ページ初期段階で処理されるスクリプトファイル。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>arg0, arg1, arg2, arg3,...</code>
</para>
</entry>
<entry>
<para>[Optional]</para>
<para>引数の数を指定できます。１番目のフォーマットが使用されている場合、その数は<code>doInit</code>メソッドに送信され、2番目のフォーマットが使用されている場合、<code>args</code>の値として送信されます。メモ：一番目の引数は<code>arg0</code>、二番目は<code>arg1</code>、以下同様です。 </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code/>
</title></sect2><sect2><title>
<code>variable-resolver </code>コマンド</title>
<para>
<code>&lt;?variable-resolver class="..."?&gt;</code>
</para>
<para>
<code>zscript</code>インタプリタが不明な変数を解析する際に使用される変数リゾルバー(variable-resolver) を指定します。指定されたクラスは<code>org.zkoss.zk.scripting.VariableResolver</code>インターフェースを実装します。</para>
<para>variable-resolverコマンドを使うことで多変数リゾルバーを指定することができます。遅く宣言されるほど、より高い優先度を持ちます。</para>
<para>以下はスプリングフレームワークとともにZKを使用するときの例です。スプリングフレームワークの中で宣言されたJava　Beansを解析することで、それらを直接参照できます。</para>
<programlisting>&lt;?variable-resolver class="org.zkoss.zkplus.spring.DelegatingVariableResolver"?&gt;&#13;</programlisting>
<para>詳しくは <ulink url="http://www.zkoss.org/smalltalks/springdao/sdao.html">Small Talk: </ulink>
<ulink url="http://www.zkoss.org/smalltalks/springdao/sdao.html">ZK with Spring DAO and JDBC, Part II</ulink> をご覧ください。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>class</code>
</para>
</entry>
<entry>
<para>[Required]</para>
<para>クラス名は<code>org.zkoss.zk.scripting.VariableResolver</code>インターフェースを実装します。</para>
<para>指定されたクラスのインスタンスは作成され、ページに追加されます。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>import</code> コマンド</title>
<para>
<code>&lt;?import uri="..."?&gt;</code>
</para>
<para>コンポーネント定義と他のZUMLページ中で定義されたイニシエーターを挿入します。つまり、指定されたページから<code>component</code>と<code>init</code>コマンドを挿入します。<code>Component</code>と<code>init</code>以外のコマンドは混乱を避けるために無視されます。</para>
<para>代表的な使用は一つのZUMLページの中でコンポーネントセットを定義します。そして、他のZUMLページはこのページを挿入し、コンポーネントの定義を共有します</para>
<programlisting>&lt;!-- special.zul: Common Definitions --&gt;&#13;&lt;?init zscript="/WEB-INF/macros/special.zs"?&gt;&#13;&lt;?component name="special" macro-uri="/macros/special.zuml" class="Special"?&gt;&#13;&lt;?component name="another" macro-uri="/WEB-INF/macros/another.zuml"?&gt;&#13;</programlisting>
<para>特別なクラスが<code>WEB-INF/macros/special.zs</code>の中で定義されることを仮定します。</para>
<para>こうして、他のZUMLページは以下のようにコンポーネントの定義を共有することができます。</para>
<programlisting>&lt;?import uri="special.zul"?&gt;&#13;...&#13;&lt;special/&gt;&lt;!-- you can use the component defined in special.zul --&gt;&#13;</programlisting>
<para>他のコマンドと違って、<code>import</code>コマンドは最上層に位置します。つまりルート要素と同じレベルです。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>uri</code>
</para>
</entry>
<entry>
<para>[Required]</para>
<para>他のコマンドと違って、<code>import</code>コマンドは最上層に位置します。つまりルート要素と同じレベルです。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>link</code>と<code>meta</code> コマンド</title>
<para>
<code>&lt;?link [href="uri"] </code>
<code>[</code>
<code>name0</code>
<code>="</code>
<code>value0</code>
<code>"] [</code>
<code>name1</code>
<code>="</code>
<code>value1</code>
<code>"] [</code>
<code>name2</code>
<code>="</code>
<code>value2</code>
<code>"]?&gt;&lt;?meta [</code>
<code>name0</code>
<code>="</code>
<code>value0</code>
<code>"] [</code>
<code>name1</code>
<code>="</code>
<code>value1</code>
<code>"] [</code>
<code>name2</code>
<code>="</code>
<code>value2</code>
<code>"]?&gt;</code>
</para>
<para>HTMLの中にはいわゆるヘッダー要素があります。現在HTML方式のクライアント(いわゆるブラウザ)はそれらを使用することができます。</para>
<para>ディベロッパーはこれらヘッダーコマンドを伴った属性を指定することができます。ZKは<code>href</code>コマンドのURIをエンコードするだけです(<code>Executions</code>クラスの<code>encodeURL</code>メソッドの使用により)。ZKは他のすべての属性を直接クライアントへ発信します。 </para>
<para>これらヘッダーコマンドは主要なZULページにのみ有効です。つまり、他のページ又はサーブレットに含まれているページである場合、ヘッダーコマンドは無視されます。また、ページがzhtmlファイルである場合も無視されます。</para>
<programlisting>&lt;?link rel="alternate" type="application/rss+xml" title="RSS feed"&#13; href="/rssfeed.php"?&gt;&lt;&#13;?link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"?&gt;&#13;&#13;&lt;window title="My App"&gt;&#13;   My content&#13;&lt;/window&gt;&#13;</programlisting></sect2></sect1><sect1><title>ZK 属性</title>
<para>ZK属性はデータメンバを初期化するほか、関連要素を制御します。</para><sect2><title>
<code>use</code> 属性</title>
<para>
<code>for</code>
<code>EachEnd="</code>
<code>a-class-name</code>
<code>"</code>
</para>
<para>コンポーネントを作成するクラスを指定します。以下の例では、<code>MyWindow</code>はデフォルトクラス(<code>org.zkoss.zul.Window</code>) の代わりに使用されます。</para>
<programlisting>&lt;window use="MyWindow"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>if</code> 属性</title>
<para>
<code>if="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>関連要素を処理する状態を指定します。つまり、<code>i</code>
<code>f</code>属性が<code>f</code>
<code>alse</code>と処理された場合、関連要素と、そのすべての子要素は無視されます。</para></sect2><sect2><title>
<code>unless</code> 属性</title>
<para>
<code>unless="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>関連要素を処理しない状態を指定します。つまり、<code>u</code>
<code>nless</code>属性が<code>t</code>
<code>rue</code>と処理された場合、関連要素とその子要素のすべては無視されます。</para></sect2><sect2><title>
<code>forEach</code> 属性</title>
<para>
<code>forEach="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>オブジェクトの集合を表します。そうして、関連要素が集合中のどのオブジェクトに対しても繰り返し処理されます。指定していない、または空の状態では、この属性は無視されます。集合ではないオブジェクトが指定されていたら、一要素の集合が指定されているように、一度だけ、処理をします。</para></sect2><sect2><title>
<code>for</code>
<code>EachBegin</code> 属性</title>
<para>
<code>forEachBegin="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>
<code>forEach</code>属性を使用するときに使います。繰り返し処理が始まるところ（0から始まる）を指定します。指定されていない場合、初めの要素から始まります。つまり0です。</para>
<para>
<code>forEachBegin</code>は要素の数と等しいか、又は要素数より大きい場合、繰り返し処理は行われません。</para>
<para>メモ：配列などに使うとき、<code>forEachStatus.index</code>の値は相対ではなく、絶対的です。例えば、<code>forEachBegin</code>が5の場合、<code>forEachStatus.index</code>の初期値は5になります。</para></sect2><sect2><title>
<code>for</code>
<code>EachEnd</code> 属性</title>
<para>
<code>for</code>
<code>EachEnd="${</code>
<code>an-EL-expr</code>
<code>}"</code>
</para>
<para>
<code>forEach</code>属性を使用するときに使います。繰り返し処理が終わるところ(その指定したものも含まれます)を指定します。指定されていない場合、繰り返し処理は最後の要素で終わります。</para>
<para>
<code>forEachEnd</code>が要素数に等しいか又はより大きい場合、繰り返し処理は最後の要素で終了となります。</para></sect2><sect2><title>
<code>fulfill</code> 属性</title>
<para>
<code>fulfill="</code>
<code>event-name</code>
<code>"fulfill="</code>
<code>target-id</code>
<code>.</code>
<code>event-name</code>
<code>"fulfill="</code>
<code>id1/id2/id3</code>
<code>.</code>
<code>event-name</code>
<code>"fulfill="${</code>
<code>el-expr</code>
<code>}.</code>
<code>event-name</code>
<code>"</code>
</para>
<para>子要素を作成するタイミングを指定します。デフォルトによって、(つまり、<code>fullfill</code>は指定されていない場合)子要素はZUMLページが読み込まれた直後、親コンポーネントが作成された直後に作成されます。</para>
<para>
<code>fullfill</code>属性で状態を指定すれば、子要素の作成を遅らせます。その条件はイベント名と、目標コンポーネント(オプション)又はパス(オプション)から成り立っています。つまり、指定された目標コンポーネントがイベントを受け取るまでに、子要素は処理されません。識別子が指定されていない場合、同じコンポーネントが想定されます。 </para>
<para>EL表記が指定されている場合、コンポーネント、識別子またはパスを送り返さなければなりません。</para>
<para>詳しくはロードオンデマンドセクションをご覧ください。</para></sect2></sect1><sect1><title>ZK 要素</title>
<para>ZK要素はコンポーネント作成のほかにZUMLページをコントロールします。</para><sect2><title>
<code>zk</code> 要素</title>
<para>
<code>&lt;zk&gt;...&lt;/zk&gt;</code>
</para>
<para>特別な要素が他の要素を集めます。本当のコンポーネント(例えば、<code>hbox</code> or <code>div</code>)とは異なり、コンポーネントツリーの一部分ではありません。つまり、コンポーネントではありません。例えば、</para>
<programlisting>&lt;window&gt;&#13;   &lt;zk&gt;&#13;      &lt;textbox/&gt;&#13;      &lt;textbox/&gt;&#13;   &lt;/zk&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>は下と同じ働きをします。</para>
<programlisting>&lt;window&gt;&#13;   &lt;textbox/&gt;&#13;   &lt;textbox/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>では、何のために使うのでしょうか？</para><sect3><title>一ページ内に多数のルート要素が存在したら</title>
<para>XMLのシンタックス制限により、ドキュメントのルートは一つのみ指定することができます。こうして、多数のルートコンポーネントを持つと、<code>zk</code>をドキュメントルートとして使用しなければならず、ルートコンポーネントをグループ化します。</para>
<programlisting>&lt;?page title="Multiple Root"?&gt;&#13;&lt;zk&gt;&#13;          &lt;window title="First"&gt;    &#13;          ...    &#13;          &lt;/window&gt;    &#13;          &lt;window title="Second" if="${param.secondRequired}"&gt;    &#13;          ...    &#13;          &lt;/window&gt;    &#13;&lt;/zk&gt;&#13;</programlisting></sect3><sect3><title>多種類のコンポーネントの繰り返し処理</title>
<para>コンポーネントのようなzk要素は<code>forEach</code>属性に対応できます。こうして、<code>forEach</code>属性を使って、条件によって違ったタイプのコンポーネントを生成します。以下の例では、<code>mycols</code>はオブジェクトの集合であって、いくつかのメンバを持っています：<code>isUseText()</code>
<code>、</code>
<code>isUseData()</code>
<code>、</code>
<code>isUseCombo()</code>です。</para>
<programlisting>&lt;window&gt;&#13;          &lt;zk forEach="${mycols}"&gt;    &#13;                    &lt;textbox if="${each.useText}"/&gt;        &#13;                    &lt;datebox if="${each.useDate}"/&gt;        &#13;                    &lt;combobox if="${each.useCombo}"/&gt;        &#13;          &lt;/zk&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[Optional][Default:<code> true</code>]</para>
<para>処理する条件を定義します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>false</code>]</para>
<para>処理しない条件を定義します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>forEach</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>ignored</code>]</para>
<para>オブジェクトの集合を指定して、ZK要素が集合中のどのオブジェクトに対しても繰り返し処理するようにします。指定されていない、或は、空である場合、属性は無視されます。集合で無いオブジェクトが指定された場合、単要素集合のように、一度だけ処理されます。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>zscript</code> 要素</title>
<para>
<code>&lt;zscript [language="Java"]&gt;</code>
<code>Scripting codes</code>
<code>&lt;/zscript&gt;&lt;zscript src="</code>
<code>uri</code>
<code>" [language="Java"]/&gt;</code>
</para>
<para>例えば、Javaコードといったスクリプトコードを定義します、そうしてページが処理されるときインタープリットされます。スクリプトコードの言語はデフォルトでJavaです(下を見てください) 。<code>language</code>属性を使用することで異なった言語を選ぶことができます。</para>
<para>
<code>zscript</code>要素は上に示したように二つのフォーマットがあります。初めのフォーマットはページ中に直接スクリプトコードを埋め込みます。二つ目のフォーマットはスクリプトコードを含んでいる外部のファイルを参照します。 </para>
<para/>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>src</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>none</code>]</para>
<para>スクリプトコードを含んでいるファイルのURIを指定します。指定されている場合、直接埋め込まれているように、スクリプトコードは読み込まれます。</para>
<para>
<code>src</code>属性はブラウザとローカル依存URIをサポートしています。つまり、<code>～</code>と<code>*</code>を異なったコンテクストパス、ブラウザ、ローカル依存情報に割り当てます。より詳しくは国際化の章を参照してください</para>
<para>メモ：ファイルには直接インタープリットできる選択言語のソースコードが必要です。エンコードはUTF-8でなければなりません。クラスファイルを指定しないように注意しましょう。(Aka.bytecodes) </para>
</entry>
</row>
<row>
<entry>
<para>
<code>language</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>Java</code> or as specified in the <code>page</code> directive][Allowed Values: <code>Java</code> | <code>JavaScript</code> | <code>Ruby</code> | <code>Groovy</code>]</para>
<para>書かれているスクリプトコードの言語を指定します。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>deferred</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>false</code>]</para>
<para>初めの延期されてない言語の<code>zscript</code>コードの処理が必要になるまで、この要素の処理を延期するかどうかをきめられません。以下のHow to Defer the Evalucation セクションを参照してください。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>true</code>]</para>
<para>処理する条件を定義します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>false</code>]</para>
<para>処理しない条件を定義します。</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>処理を遅らせる方法</title>
<para>ZKは初めの<code>zscript</code>コードを処理する前、インタプリタを読み込みます。例えば、以下の例の中で、ユーザーがボタンをクリックするとき、Javaインタプリタは読み込まれます。</para>
<programlisting>&lt;button onClick="alert(&amp;quot;Hi&amp;quot;)"/&gt;&#13;</programlisting>
<para>一方で、<code>zscript</code>要素はページを読み込むときに処理される必要があるので、以下のZUMLページを読み込むとき、インタプリタは読み込まれます。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;   void add() {&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button onClick="add()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>インタプリタの読み込みを遅らせる場合は、<code>deferred</code>オプションに<code>true</code>を指定します。そうすると、ユーザーがボタンをクリックするまでは、インタプリタは読み込まれません。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript deferred="true"&gt;&#13;   void add() {&#13;   }&#13;   &lt;/zscript&gt;&#13;   &lt;button onClick="add()"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>【ヒント】： <code>unless</code>と<code>src</code>と <code>if</code>属性中で指定されたEL表記の処理は遅らせます。</para>
<para>【ヒント】： インタプリタが読み込まれるまでに、コンポーネントがページからはずれたら<code>zscript</code>コードは無視されます。例えば、前の例でウィンドウがページに属していないと判断された場合、延期された<code>zscript</code>はインタープリットされません。 </para></sect3><sect3><title>異なったスクリプト言語を選択する方法 </title>
<para>一つのページで複数のスクリプト言語を使うことができます。</para>
<programlisting>&lt;button onClick="javascript:do_something_in_js()"/&gt;&#13;&lt;zscript language="groovy"&gt;&#13;do_something_in_Groovy();&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>スクリプト言語が指定されていない場合、Javaが想定されます。デフォルトのスクリプト言語を変更したい場合、<code>page</code>属性を以下のように使用します。</para>
<programlisting>&lt;?page zscript-language="Groovy"?&gt;&#13;&#13;&lt;zscript&gt;&#13;def name = "Hello World!";&#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>他のスクリプト言語を使用</title>
<para>ZKはJava, JavaScript,Ruby,Groovyをサポートしていますが、簡単に拡張することができます:</para>
<orderedlist>
<listitem>
<para>
<code>org.zkoss.zk.script</code>
<code>は</code>
<code>org.zkoss.zk.scriping.Interpreter</code>インターフェースを実装するクラスを供給します。ネーム空間を操作する場合、直接実装する代わりに、<code>org.zkoss.zk.scripting.util.GenericInterpreter</code>クラスから得ることができます。また、インタプリタがBSF(Bean Scipring Framwork)をサポートしている場合、<code>org.zkoss.scripting.bsh.BSFInterpreter</code>クラスから得ることができます。</para>
</listitem>
<listitem>
<para>
<code>WEB-INF/zk.xml</code>又は<code>zk/config.xml</code>中でスクリプト言語を宣言します。</para>
</listitem>
</orderedlist>
<programlisting>&lt;zscript-config&gt;&#13;   &lt;zscript-language&gt;&#13;      &lt;language-name&gt;SuperJava&lt;/language-name&gt;&lt;!-- case insensitive --!&gt;&#13;      &lt;interpreter-class&gt;my.MySuperJavaInterpreter&lt;/interpreter-class&gt;&#13;   &lt;/zscript-language&gt;&#13;&lt;/zscript-config&gt;&#13;</programlisting>
<para><code>WEB-INF/zk.xml</code>についての詳細は開発用リファレンスを参照ください。また、<code>zk/config.xml</code>についてはComponent Development Guideを参照してください。</para></sect3></sect2><sect2><title>
<code>attribute</code> 要素</title>
<para>要素を閉じるために使われるXML属性を定義します。要素の中身は属性の値です。<code>name</code>属性は属性名を指定します。属性の値が複雑、又は属性に条件が付いている場合に使うと便利です。 </para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>name</code>
</para>
</entry>
<entry>
<para>[Required]</para>
<para>属性名を指定します。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>trim</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>false</code>]</para>
<para>値の前後にあるホワイトスペースを省略するかを指定します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>none</code>]</para>
<para>処理する条件を指定します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>none</code>]</para>
<para>処理しない条件を指定します。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>
<code>variables</code> 要素</title>
<para>変数のセットを定義します。<code>variables</code>要素が親ページと親コンポーネントを持っていて、ページレベルで宣言されている場合、<code>variables</code>要素は親コンポーネントを持っていれば、 <code>Component </code>の<code>setVariable</code>メソッドと同じ働きをします。</para>
<para>以下に書かれているように、<code>variables</code>はプログラムなしで変数を指定するのに便利です。</para>
<programlisting>&lt;window&gt;&#13;   &lt;variables rich="simple" simple="intuitive"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は下記と同じ働きをします。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;      self.setVariable("rich", "simple", false);&#13;      self.setVariable("simple", "intuitive", false);&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>もちろん、値にEL表記を指定することができます。</para>
<programlisting>&lt;window&gt;&#13;   &lt;window id="w" title="Test"&gt;&#13;<inlinegraphic fileref="img/10000000000000550000003D3AB123E7.png" align="right"/>      &lt;variables title="${w.title}"/&gt;&#13;      1: ${title}&#13;   &lt;/window&gt;&#13;   2: ${title}&#13;&lt;/window&gt;&#13;</programlisting>
<para>コンポーネントの<code>setVariable</code>のように、以下のように現IDスペースにローカル変数を宣言するかどうか決めることができます。指定されていない場合、<code>local=”false”</code>が想定されます。</para>
<programlisting>&lt;variables simple="rich" local="true"/&gt;&#13;</programlisting><sect3><title>
<code>null </code>値</title>
<para>以下の例では<code>var</code>は空の文字列です。</para>
<programlisting>&lt;variables var=""/&gt;&#13;</programlisting>
<para>
<code>null</code>を変数に指定するのに、以下のステートメントを使用します。</para>
<programlisting>&lt;variables var="${null}"/&gt;</programlisting></sect3></sect2><sect2><title>
<code>custom-attributes</code> 要素</title>
<para>カスタム属性のセットを定義します。<code>custom</code>属性は特定の領域と関係するオブジェクトです。使用できる領域はコンポーネント、スペース、ページ、デスクトップ、セッション、アプリケーションです。</para>
<para>以下に示したように、<code>custom-attributes</code>はプログラムなしで<code>custom</code>属性を指定するのに便利です。</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes main.rich="simple" very-simple="intuitive"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は以下と同じ働きをします。</para>
<programlisting>&lt;window&gt;&#13;   &lt;zscript&gt;&#13;      self.setAttribute("main.rich", "simple");&#13;      self.setAttribute("very-simple", "intuitive");&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>さらに、<code>custom</code>属性を割り当てる領域を指定します。</para>
<programlisting>&lt;window id="main" title="Welcome"&gt;&#13;   &lt;custom-attributes scope="desktop" shared="${main.title}"/&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は下記と同様の働きをします。</para>
<programlisting>&lt;window id="main"&gt;&#13;   &lt;zscript&gt;&#13;      desktop.setAttribute("shared", main.title);&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>ここで注意してほしいのは、EL表記はコンポーネントが作成されているときに処理されます。例えば、以下の例で<code>${componentScope.simple}</code>が<code>null</code>と処理されます。どうしてでしょうか？それは<code>&lt;label value="${componentScope.simple}"/&gt;</code>のショートカットです。つまり、ELが処理されるとき、コンポーネント<code>self</code>はウィンドウというより、ラベルです。</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes simple="intuitive"/&gt;&#13;   ${componentScope.simple}&#13;&lt;/window&gt;&#13;</programlisting>
<para>上記は下記と同様の働きをします。</para>
<programlisting>&lt;window&gt;&#13;   &lt;custom-attributes simple="intuitive"/&gt;&#13;   &lt;label value="${componentScope.simple}"/&gt;&lt;!-- self is label not window --&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>【ヒント】： <code>attribute</code>と<code>custom-attributes</code>を混同しないよう注意してください。その二つに関係ありません。<code>Attribute</code>要素は閉じるためのXML属性を定義する一つの方法です。一方、<code>custom-attributes</code>要素は<code>custom</code>属性を特定の領域に割り当てます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Attribute Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>scope</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>com</code>
<code>ponent</code>]</para>
<para>カスタム属性を関連付ける領域を指定する。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>if</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>none</code>]</para>
<para>処理する条件を定義します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>unless</code>
</para>
</entry>
<entry>
<para>[Optional][Default: <code>none</code>]</para>
<para>処理しない条件を定義します。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2></sect1><sect1><title>コンポーネントセットとXMLネーム空間</title>
<para>同ZUMLページ中で二つ以上のコンポーネントセットを同時に使用するために、ZKがXMLネーム空間を使って違うコンポーネットセットを区別します。例えば、XULのネーム空間は<code>http://www.zkoss.org/2005/zul</code>でXHTMLのネーム空間は<code>http://www.w3.org/1999/xhtml</code>です。</para>
<para>一方で、ほとんどのページはそれぞれただ一つのコンポーネントセットを使用します。ページを書くことを容易にするために、ZKが拡張子でデフォルトネーム空間を決めます。例えば、xulとzulはXULネーム空間を意味しています。それゆえ、ディベロッパーはZUMLページと適切な拡張子と関連付けることのみをすればOKです。また、XMLネーム空間に気を使うことは必要ありません。</para><sect2><title>標準的なネーム空間</title>
<para>前に書いたように、どのコンポーネントセットもそれぞれ一つの(唯一の)ネーム空間と関連しています。しかし、ディベロッパーはサードパーティーのコンポーネントを使用したり、発展させたりするかもしれません。ここにZKパッケージにあるネーム空間だけをリストアップします。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Namespace</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>http://www.zkoss.org/2005/zul</code>
</para>
</entry>
<entry>
<para>The namespace of the XUL component set.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>http://www.w3.org/1999/xhtml</code>
</para>
</entry>
<entry>
<para>The namespace of the XHTML component set.</para>
</entry>
</row>
<row>
<entry>
<para>
<code>http://www.zkoss.org/2005/zk</code>
</para>
</entry>
<entry>
<para>ZK namespace. It is the reserved namespace for specifying ZK specific elements and attributes.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>他の名前と重ならない限り、ZUMLページ中でネーム空間を自分で指定できます。ZKはZUMLページの拡張子によって、どのネーム空間を使うかを決めます。<code>.zul</code>と<code>.xul</code>拡張はXULのネーム空間が割り当てられます。<code>html</code>、<code>xhtml</code>、<code>zhtml</code>はXHTMLのネーム空間が割り当てられます。</para>
<para>他のマークアップ言語と混在に使うために、<code>xmlns</code>を使用し、正しいネーム空間を指定しなければいけません。</para>
<programlisting>&lt;window xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;   &lt;h:div&gt;&#13;      &lt;button/&gt;&#13;   &lt;/h:div&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>XHTMLコンポーネント、<code>onClick</code>、<code>onChange</code>属性はZKの属性と競合します。解決するためには、確保されたネーム空間<code>http://www.zkoss.org/2005/zk</code>を以下のように使用しなければなりません。</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/zk/core.dsp.tld" prefix="u" ?&gt;&#13;&#13;&lt;html xmlns:x="http://www.zkoss.org/2005/zul" xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;          &lt;script type="text/javascript"&gt;    &#13;          function woo() { //running at the browser    &#13;          }    &#13;          &lt;/script&gt;    &#13;          &lt;zk:zscript&gt;    &#13;          void addItem() { //running at the server    &#13;          }    &#13;          &lt;/zk:zscript&gt;    &#13;      &lt;x:window title="HTML App"&gt;&#13;               &lt;input type="button" value="Add Item"    &#13;                 onClick="woo()" zk:onClick="addItem()"/&gt;    &#13;      &lt;/x:window&gt;&#13;&lt;/body&gt;&#13;</programlisting>
<para>この例中では、<code>onClick</code>属性はZHTMLの属性です。ブラウザで動作するJavaScriptコードを指定します。一方で、<code>zk:onClick</code>はZKイベントハンドラを指定するために確保された属性です。</para>
<para>ZHTMLは<code>zscript</code>要素を持たないので、プログラマーが<code>zscript</code>要素にネーム空間のプレフィックスzkを使うかどうか決める事ができます。またZKが十分な情報を持っているのでプレフィックスが無くても判断できます。</para>
<para>コンポーネントセットとは異なったものなので<code>window</code>コンポーネントにはXMLネーム空間を指定しなければなりません。</para></sect2></sect1></chapter>
<chapter>
<title>7. ZUMLとXULコンポーネントセット</title>
<para>この章はXULコンポーネントセットを説明しています。他の実装とは異なり、ZKのXULコンポーネントはインターネット上で効率的に使われるため、最適化されています。一部のコンポーネントはXUL標準とは少し異なるかもしれません。便宜上、それらをZULコンポーネントと呼びます。</para><sect1><title>ベーシックコンポーネント</title><sect2><title>ラベル</title>
<para>ラベルはテキストを表します。</para>
<programlisting>&lt;window border="normal"&gt;<inlinegraphic fileref="img/100000000000006E00000019906EC282.png" align="right"/>&#13;          Hello World    &#13;&lt;/window&gt;&#13;</programlisting>
<para>ラベルに属性を指定する場合、以下のようにはっきりと<code>&lt;label&gt;</code> を指定しなければいけません。</para>
<programlisting>&lt;window border="normal"&gt;<inlinegraphic fileref="img/100000000000006E00000019F37FCFA0.png" align="right"/>&#13;          &lt;label style="color: red" value="Hello World"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>【ヒント】：ZUMLはXMLであって、HTMLではありませので、<code>&amp;nbsp</code>
<code>;</code>を受け取りません。しかしながら、代わりに<code>&amp;#160</code>
<code>;</code>を使うことができます。</para><sect3><title>
<code>pre</code>・<code>hyphen</code>・<code>maxlength</code> ・<code>multiline</code> プロパティ</title>
<para>
<code>p</code>
<code>re</code>、<code>hyphen</code>、<code>maxlength</code>プロパティを使い、ラベルの外見を変えることができます。例えば、<code>pre</code>に<code>true</code>
<code>を指定する場合、空白、タブなどのすべてのホワイトスペースは省略されません。</code>
</para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row>
<entry>
<para>
<code>hyphen</code>
</para>
</entry>
<entry>
<para>
<code>pre</code>
</para>
</entry>
<entry>
<para>
<code>maxlenth</code>
</para>
</entry>
<entry>
<para>
<code>説明</code>
</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>positive</code>
</para>
</entry>
<entry>
<para>指定した<code>maxlength</code>を超える文字列は切られる</para>
</entry>
</row>
<row>
<entry>
<para>
<code>true</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>positive</code>
</para>
</entry>
<entry>
<para>単語の長さが<code>maxlength</code>を超えた場合、単語は途中から切られる</para>
</entry>
</row>
<row>
<entry>
<para>
<code>false</code>
</para>
</entry>
<entry>
<para>
<code>true</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>maxlength</code>は無視されます</para>
</entry>
</row>
<row>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>any</code>
</para>
</entry>
<entry>
<para>
<code>0</code>
</para>
</entry>
<entry>
<para>
<code>pyphen</code>は無視されます</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<programlisting>&lt;window border="normal" width="200px"&gt;&#13;&lt;vbox&gt;&#13;          &lt;label value="Hello, World!" maxlength="5"/&gt;    &#13;          &lt;label value="Hello, WorldChampion!" hyphen="true" maxlength="10"/&gt;    &#13;          &lt;label pre="true"&gt;    <inlinegraphic fileref="img/10000000000000D30000007EDF56D0C6.png" align="right"/>&#13;                    &lt;attribute name="value"&gt;aa        &#13;          bb c    &#13;          dd ef&lt;/attribute&gt;    &#13;          &lt;/label&gt;    &#13;&lt;/vbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>multiline</code>プロパティは<code>pre</code>プロパティに似ています。違う点は<code>multiline</code> は各々の行初めにある新しい線と空白のみを保存します。</para></sect3></sect2><sect2><title>ボタン</title>
<para>2種類のボタンがあります。<code>button</code> と<code>toolbarbutton</code>です。外見は違いますが、働きは同じです。<code>button</code> コンポーネントはHTML BUTTONタグを使用します。一方、<code>toolbarbutton</code>コンポーネントはHTML　Aのタグを使います。</para>
<para>
<code>label</code>と<code>image</code>プロパティでラベルとイメージをボタンに指定することができます。二つとも指定された場合、<code>dir</code>
<code>プロ</code>パティでどれを一番前に表示するかを指定できます。<code>orient</code>プロパティはlayoutを横方向、縦方向、どちらかに指定できます。</para>
<programlisting>&lt;button label="Left" image="/img/folder.gif" width="125px"/&gt;<inlinegraphic fileref="img/1000000000000080000000805ADB57EA.png" align="right"/>&#13;&lt;button label="Right" image="/img/folder.gif" dir="reverse" width="125px"/&gt;&#13;&lt;button label="Above" image="/img/folder.gif" orient="vertical" width="125px"/&gt;&#13;&lt;button label="Below" image="/img/folder.gif" orient="vertical" dir="reverse" width="125px"/&gt;&#13;</programlisting>
<para>URLによってイメージを指定することに加えて、<code>setImageContent</code>メソッドを使うことで、動的に生成させたイメージをボタンに指定することができます。詳しくは以下のセクションをご覧ください。</para>
<para>【ヒント】：　<code>setImageContent</code>メソッドは<code>image</code>プロパティを持つすべてのコンポーネントで提供されています。つまり、<code>setImageContent</code>はイメージを動的に生成するときに使われます。一方、ImageはURLが認識できるイメージに使われます。</para><sect3><title>
<code>onClick</code>イベントと<code>href</code>プロパティ</title>
<para>
<code>button</code>と<code>toolbarbutton</code>に動作を加える方法は二つあります。初めは<code>onClick</code>イベントにリスナを指定します。二つ目はURLを<code>href</code>プロパティに指定します。両方共に指定された場合、<code>href</code>プロパティのほうが、優先順位が高いです。つまり、<code>onClick</code>イベントは送信されません。</para>
<programlisting>&lt;button onClick="do_something_in_Java()"/&gt;&#13;&lt;button href="/another_page.zul"/&gt;&#13;</programlisting></sect3><sect3><title>
<code>org.zkoss.zk.ui.Execution</code>インターフェースの<code>sendRedirect</code>メソッド</title>
<para>イベントを処理している時、現デスクトップの処理を停止するかどうかを操作します。そして、<code>sendRedirect</code>メソッドを使って他のページに変えます。つまり、以下二つのボタンの働きは(ユーザーからみれば) 同じです。</para>
<programlisting>&lt;button onClick="Executions.sendRedirect(&amp;quot;another.zul&amp;quot;)"/&gt;&#13;&lt;button href="another.zul"/&gt;&#13;</programlisting>
<para>
<code>onClick</code>イベントはサーバーへ送信され処理されるので、<code>sendRedirect</code>を呼ぶ前にロジックを加えることができます。たとえば、<code>sendRedirect</code>はある条件が満たされた場合のみ、他のページに変えるといったことが可能です。</para>
<para>一方で、<code>href</code>プロパティは完全にクライアント側で処理されます。ユーザーがボタンをクリックするなどクライアント側の操作はアプリケーションには通知されせん。</para></sect3></sect2><sect2><title>ラジオとラジオグループ</title>
<para>ラジオボタンはオン・オフできるコンポーネントです。ラジオボタンは<code>radiogroup</code>と呼ばれるグループ中でグループ化されます。同じグループの中では一つだけのラジオボタンが選択できます。</para>
<programlisting>&lt;radiogroup onCheck="alert(self.selectedItem.label)"&gt;&#13;          &lt;radio label="Apple"/&gt;    &#13;          &lt;radio label="Orange"/&gt;    &#13;          &lt;radio label="Banana"/&gt;    &#13;&lt;/radiogroup&gt;&#13;</programlisting><sect3><title>レイアウト</title>
<para>以下に示したように、<code>radiogroup</code>と<code>radio</code>は組み合わせることができ、レイアウトは自分のしたいようにできます。</para>
<programlisting>&lt;radiogroup onCheck="alert(self.selectedItem.label)"&gt;&#13;   &lt;radio label="Apple"/&gt;&#13;   &lt;radio label="Orange"/&gt;&#13;   &lt;radio label="Banana"/&gt;&#13;&lt;/radiogroup&gt;&#13;</programlisting>
<para>ラジオボタンは一番関係の近い<code>ancestorradiogroup</code>に属しています。以下のように一つのラジオグループを他のものを入れ子することができます。視覚的には重ねているように見えるかもしれませんが、どのグループも独立に操作できます。</para>
<programlisting>&lt;radiogroup&gt;&#13;   &lt;grid&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;&lt;radio label="Apple" selected="true"/&gt; Fruit, music or computer&lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Orange"/&gt;&lt;textbox/&gt;&lt;/row&gt;&#13;      &lt;row&gt;&lt;radio label="Banana"/&gt;&lt;datebox/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;<inlinegraphic fileref="img/100000000000019900000056513BCA33.png" align="right"/>   &lt;/grid&gt;&#13;&lt;/radiogroup&gt;&#13;</programlisting>
</sect3></sect2><sect2><title>イメージ</title>
<para>
<code>image</code> コンポーネントはブラウザ上でイメージを表示します。<code>image</code>コンポーネントにイメージを指定する方法は二つあります。一つ目は<code>src</code>プロパティを使って、イメージが位置されているURIを指定します。この方法はHTMLがサポートしているものに似ています。静的なイメージを表示する場合、URLによって認識できるイメージを表示する場合、このアプローチは便利です。</para>
<programlisting>&lt;image src="/some/my.jpg"/&gt;&#13;</programlisting><sect3><title>地域(言語)依存イメージ</title>
<para>URIを受け取っている他のプロパティを使用しているように、地域依存イメージを<code>“*”</code>で表示します。例えば、異なった地域に異なったイメージを指定するなら、以下のように使用できます。</para>
<programlisting>&lt;image src="/my*.png"&#13;</programlisting>
<para>そのため、ユーザーの一人がデフォルト地域がde_DEに設定されたブラウザで訪れることを想定します。ZKは<code>/my_de_DE.png</code>と呼ばれるイメージファイルを位置しようと試みます。見つからない場合、<code>/my_de.png</code>を探し、最後は/my.pngを試します。</para>
<para>より詳しくは、国際化の章のブラウザとロケール依存URIを参照してください。</para>
<para>二つ目は、<code>setContent</code>メソッドを使用して、イメージコンテンツを<code>image</code>コンポーネントに直接指定できます。指定したと同時に、ブラウザで表示されているイメージが自動的に更新されます。このアプローチはイメージが動的に生成されるときに使うと便利です。</para>
<para>例えば、以下のようにユーザーに指定された位置にマップを生成させます。</para>
<programlisting>Location: &lt;textbox onChange="updateMap(self.value)"/&gt;&#13;Map: &lt;image id="image"/&gt;&#13;&lt;zscript&gt;&#13;          void updateMap(String location) {    &#13;                    if (location.length() &gt; 0)        &#13;                              image.setContent(new MapImage(location));            &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>上の例の中の<code>MapImage</code>は指定された位置を計算し、マップで表示するビジネスロジックと仮定します。</para>
<para>イメージコンポーネントは<code>org.zkoss.image.Image</code>インターフェースの中のコンテンツのみを受け取ります。ツールによって生成させたイメージがこのフォーマットでない場合、<code>org.zkoss.image.AImage</code>クラスを使用して、バイナリデータ配列、又はファイル、又は入力列を包み<code>Image</code>インターフェースに入れましょう。</para>
<para>従来のウェブアプリケーション中で動的に発生したイメージを一時キャッシュすることは難しいです。<code>image</code>コンポーネントを使えば心配する必要はありません。一度イメージコンテンツが指定されると、それは<code>image</code>コンポーネントに属し、<code>image</code>コンポーネントを使わなくなった後、メモリは自動的に開放されます。</para>
<para>【ヒント】：イメージや、オーディオ以外のPDFといったコンテンツを表示する場合、<code>iframe</code>コンポーネントを使用できます。</para></sect3></sect2><sect2><title>イメージマップ</title>
<para>
<code>imagemap</code>コンポーネントは特別なイメージです。<code>i</code>
<code>mage</code>コンポーネントが受け取るすべてのプロパティを受け取ります。しかし、<code>image</code>とは異なっていて、ユーザーがイメージ上でクリックをしたら、<code>onClick</code>イベントとマウス位置の座標は両方サーバーに送り返されます。対照的に、<code>image</code>の場合は<code>onClick</code>イベントは座標を含まないで送信されます。</para>
<para>マウス位置座標は左上の隅を（０，０）として、画面のピクセルを数えます。<code>org.zkoss.zk.ui.event.MouseEvent</code>のインスタンスとして保存されます。一度、アプリケーションが<code>onClick</code>イベントを受け取ると、<code>getX</code>
<code>と</code>
<code>getY</code>メソッドでマウスの位置座標を調べます。</para>
<para>例えば、もしユーザーが左上から208ピクセル右、205ピクセル下という点をクリックしたら、以下の文からイメージが表示されます。</para>
<programlisting>&lt;imagemap src="/img/sun.jpg" onClick="alert(event.x + &amp;quot;, &amp;quot; +event.y)"/&gt;&#13;</programlisting>
<para>
<graphic align="center" fileref="img/10000000000001AC00000155E1243DA6.png">2
			
		</graphic>
</para>
<para>アプリケーションは大抵座標を使用して、ユーザーがクリックした場所を決めます。そして、それにしたがってレスポンスをします。</para><sect3><title>エリア</title>
<para>アプリケーション自体が座標を処理する代わりに、開発者が<code>imagemap</code>コンポーネントの子要素として<code>area</code>コンポーネントを加えることができます。</para>
<programlisting>&lt;imagemap src="/img/sun.jpg" onClick="alert(event.area)"&gt;&#13;    &lt;area id="First" coords="0, 0, 100, 100"/&gt;&#13;    &lt;area id="Second" shape="circle" coords="200, 200, 100"/&gt;&#13;&lt;/imagemap&gt;&#13;</programlisting>
<para>次に、<code>imagemap</code>コンポーネントはロジック名へマウスの位置座標を翻訳します。：ユーザーがクリックしたエリアの識別子。例えば、ユーザーは(150,150)でクリックしたら、以下のように結果を得ます。</para>
<para>
<graphic align="center" fileref="img/10000000000001D200000103800B52A3.png">2
			
		</graphic>
</para></sect3><sect3><title>
<code>Shape</code>プロパティ</title>
<para>エリアコンポーネントは３タイプの形をサポートしています：circle・ polygon ・ rectangle。マウスの座標は左上を(０，０)として、スクリーンのピクセルを数えたものです。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>形</para>
</entry>
<entry>
<para>コーディネイト / 説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>Circle</code>
</para>
</entry>
<entry>
<para>
<code>coords="x, y, r"</code>
</para>
<para>ピクセルの中で中心を<code>ｘ</code>と<code>ｙ</code>で指定して、<code>ｒ</code>を半径とします。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>Polygon</code>
</para>
</entry>
<entry>
<para>
<code>coords="x1, y1, x2, y2, x3, y3..."</code>
</para>
<para>
<code>ｘ</code>と<code>ｙ</code>のペアが多角形(ポリゴン)の頂点を定義します。３角形を定義するのに、少なくとも３点の<code>ｘ</code>と<code>ｙ</code>が必要です。ポリゴンは自動的に閉じます。つまり、領域を閉じるためにリストの終わりで初めの座標をもう一度指定する必要はありません。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>rectangle</code>
</para>
</entry>
<entry>
<para>
<code>coords="x1, y1, x2, y2"</code>
</para>
<para>初めの座標のペアは四角形の角の一つで、他のペアは対角にある反対の角です。四角形は四つの辺の多角形を指定する方法を単純にしたものです。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>一つの<code>area</code>コンポーネント中の座標が他をオーバーラップする場合、初めに設定されたものが優先されます。</para></sect3></sect2><sect2><title>オーディオ</title>
<para>
<code>audio</code>コンポーネントはブラウザでオーディオを流します。<code>image</code>のように、<code>src</code>プロパティを使用し、オーディオリソースのURLを指定します。又は、<code>setContent</code>メソッド使用し、動的に生成したオーディオを指定します。</para>
<para>ブラウザとオーディオのプラグインがそれらの機能により、開発者は<code>play</code>、<code>stop</code>、<code>pause</code>メソッドで、オーディオの動作を操作します。現在はメディアプレーヤーが付いているインターネットエクスプローラーがそのような操作を可能にしています。</para></sect2><sect2><title/></sect2><sect2><title>入力制御
</title>			
<graphic align="center" fileref="img/1000000000000160000000A52BD72F03.png">2		</graphic>

<para>入力制御のセットはXULコンポーネントセット中でサポートされています。:<code>textbox</code>、　<code>intbox</code>、　<code>decimalbox</code>、　<code>doublebox</code>、　<code>datebox</code>、<code>combobox</code>、<code>bandbox</code>。それらによって、ユーザーは異なったタイプのデータを入力できます。</para>
<para/>
<programlisting>&lt;zk&gt;&#13;		&lt;textbox/&gt;    &#13;		&lt;datebox/&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>【ヒント】：<code>combobox</code>と<code>bandbox</code>は特別な入力ボックスです。その二つはここに書いたプロパティを共有しています。後に出てくる<code>c</code>
<code>omboboxes</code>と<code>b</code>
<code>andboxes</code>セクション中でそれら独特な特徴が議論されます。</para><sect3><title>
<code>type</code>プロパティ</title>
<para>
<code>textbox</code>コンポーネントの<code>type</code>プロパティを<code>password</code>に指定することで、ユーザーが何を入力したかは表示されません。</para>
<programlisting>Username: &lt;textbox/&gt;&#13;Password: &lt;textbox type="password"/&gt;&#13;</programlisting></sect3><sect3><title>
<code>format</code> プロパティ</title>
<para>フォーマットフィールドによって、入力制御のフォーマットを選択できます。デフォルトは<code>n</code>
<code>ull</code>です。<code>databox</code>では、デフォルトは<code>yyyy/mm/dd</code>です。<code>intbox</code>と<code>decimal</code>では、デフォルトは何も指定しないです。</para>
<programlisting>&lt;datebox format="MM/dd/yyyy"/&gt;&#13;&lt;decimalbox format="#,##0.##"/&gt;&#13;</programlisting>
<para>他のプロパティのように、以下に書いてあるように、動的にフォーマットを変えることができます。</para>
<programlisting>&lt;datebox id="db"/&gt;&lt;button label="set MM-dd-yyyy" onClick="db.setFormat(&amp;quot;MM-dd-yyyy&amp;quot;)"/&gt;&#13;</programlisting>
<para>マウスを使わずに入力：<code>datebox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>Alt+DOWN</code>はカレンダーをポップアップさせます。 </para>
</listitem>
<listitem>
<para>
<code>LEFT</code>, <code>RIGHT</code>, <code>UP</code>, <code>DOWN</code>でカレンダーから選択された日を変えます。</para>
</listitem>
<listitem>
<para>
<code>ENTER</code>で選択された日を有効にします。(<code>datebox</code>にコピーすることによって)</para>
</listitem>
<listitem>
<para>
<code>Alt+UP </code>またはESCは選択をあきらめ、カレンダーを閉じます。</para>
</listitem>
</itemizedlist></sect3><sect3><title>入力条件</title>
<para>
<code>constraint</code>プロパティの使用によって、入力制御が受け取る値を規制します。<code>Positive</code>、<code>negative</code>、<code>no zero</code>、<code>no empty</code>、<code>no future</code>、<code>no past</code>、<code>no today</code>、<code>regular expression</code>を組み合わせて使用することができます。初めの三つの規制は<code>intbox</code>と<code>decimalbox</code>だけに適用できます。<code>no future</code>、<code>no past</code>、<code>no today</code>の規制は<code>datebox</code>にのみ適用できます。<code>no empty</code>の規制はどのタイプのコンポーネントにも適用できます。<code>regular expressions</code>の規制は<code>textbox</code>、<code>combobox</code>、<code>bandbox</code>のようなストリングを入力するコンポーネントにのみ適用できます。 </para>
<para>二つ以上の規制を指定するために、コンマ(,)を使って以下のように分けます。</para>
<programlisting>&lt;intbox constraint="no negative,no zero"/&gt;&#13;</programlisting>
<para>
<code>regular expression</code>を指定する時に、/を使って以下のように<code>regular expression</code>を閉じます。 </para>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/"/&gt;&#13;</programlisting>
<para>メモ：</para>
<itemizedlist>
<listitem>
<para>上のステートメントはXMLなので、\\でバックスラッシュを表現しないでください。一方で、Javaで書いているなら、バックスラッシュを\\で表現しなければなりません。</para>
</listitem>
</itemizedlist>
<programlisting>new Textbox().setContraint("/.+@.+\\.[a-z]+/");&#13;</programlisting>
<itemizedlist>
<listitem>
<para>カンマで分けることで、別の規制を持つ<code>regular expression</code>と混在に使うことができます。</para>
</listitem>
</itemizedlist>
<para>デフォルトの代わりに、アプリケーション依存のメッセージを表示する場合、規制の後ろにコロンを使って、失敗したときに表示したいメッセージを加えます。</para>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/: e-mail address only"/&gt;&#13;&lt;datebox constraint="no empty, no future: now or never"/&gt;&#13;</programlisting>
<para>メモ：</para>
<orderedlist>
<listitem>
<para>エラーメッセージを指定する場合は最後の要素で指定しコロンで始めます。</para>
</listitem>
<listitem>
<para>多言語をサポートするのに、国際化の章で説明されている l functionを使用します。</para>
</listitem>
</orderedlist>
<programlisting>&lt;textbox constraint="/.+@.+\.[a-z]+/: ${c:l('err.email.required')}"/&gt;&#13;</programlisting></sect3><sect3><title>Custom規制</title>
<para>より複雑な規制をするなら、<code>org.zkoss.zul.Constraint</code>インターフェースを実装するオブジェクトを指定します。</para>
<programlisting>&lt;window title="Custom Constraint"&gt;&#13;          &lt;zscript&gt;&lt;![CDATA[    &#13;Constraint ctt = new Constraint() {&#13;      public void validate(Component comp, Object value) throws WrongValueException {&#13;                    if (value =e= null || ((Integer)value).intValue() &lt; 100)        &#13;                  throw new WrongValueException(comp, "At least 100 must be specified");&#13;          }    &#13;}&#13;          ]]&gt;&lt;/zscript&gt;    &#13;          &lt;intbox constraint="${ctt}"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>Javaクラスに規制を実装することができます。例えば、<code>my.EmailValidator</code>の場合は：</para>
<programlisting>&lt;?taglib uri="/WEB-INF/tld/web/core.dsp.tld" prefix="c"?&gt;&#13;&lt;textbox constraint="${c:new('my.EmailValidator')}"/&gt;&#13;</programlisting><sect4><title>
<code>org.zkoss.zk.ui.WrongValueException</code>
</title>
<para>上の例では<code>org.zkoss.ui.WrongValueException</code>を使用して、エラーを表します。説明したように、エラーを発生させるコンポーネントを初めの引数に指定しなければなりません。そして、二つ目の引数にエラーメッセージを指定します。</para>
<para>どんなときでも、例えば<code>onChange</code>イベントが以下のように受け取られたときに、この例外を使用することができます。</para>
<programlisting>&lt;textbox&gt;<inlinegraphic fileref="img/100000000000010500000030B13C47C7.png" align="right"/>&#13;          &lt;attribute name="onChange"&gt;    &#13;                    if (!self.value.equals("good")) {        &#13;                              self.value = "try again";            &#13;                  throw new WrongValueException(self, "Not a good answer!");&#13;                    }        &#13;          &lt;/attribute&gt;    &#13;&lt;/textbox&gt;&#13;</programlisting></sect4><sect4><title>エラー表示をカスタマイズする</title>
<para>前の例中で示されたデフォルトのエラーボックスの代わりに、規制を伴った<code>org.zkoss.zul.CustomConstraint</code>インターフェースを実装することでカスタムの外見を提供することができます。<code>CustomConstraint</code>インターフェースは<code>showCustomError</code>と呼ばれるメソッドをもち、例外が発生したとき、又はバリデーションが失敗したときに呼び出されます。以下は例です。</para>
<programlisting>&lt;window title="Custom Constraint" border="normal"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;class MyConst implements Constraint, CustomConstraint {&#13;   //Constraint//&#13;   public void validate(Component comp, Object value) {&#13;      if (value == null || ((Integer)value).intValue() &lt; 100)&#13;             throw new WrongValueException(comp, "At least 100 must be specified");&#13;   }&#13;   //CustomConstraint//&#13;   public void showCustomError(Component comp, WrongValueException ex) {&#13;      errmsg.setValue(ex != null ? ex.getMessage(): "");&#13;   }&#13;}&#13;Constraint ctt = new MyConst();&#13;   ]]&gt;&lt;/zscript&gt;&#13;   &lt;hbox&gt;&#13;      Enter a number at least 100:&#13;      &lt;intbox constraint="${ctt}"/&gt;&#13;      &lt;label id="errmsg"/&gt;&#13;   &lt;/hbox&gt;&#13;&lt;/window&gt;&#13;</programlisting><graphic fileref="img/100000000000023D00000039116921E8.png" align="center"/></sect4><sect4><title>応答速度の改善</title>
<para>応答はクライアントでより多く規制を承認(validate)することで改善できます。このためには、<code>Constraint</code> で<code>org.zkoss.zul.ClientConstraint</code> インターフェースを実装しなければなりません。クライアントですべてのバリデーションが行われると、<code>isClientComplete</code>メソッドに<code>true</code>を返します。サーバー側へ送信し、バリデーションを行う必要がなくなります。</para>
<para>
<code>Validate_errobox</code>と呼ばれる要素を使用すれば、クライアントでJavaScriptコードだけで外見をカスタマイズすることができます。例えば、</para>
<programlisting>&lt;script type="text/javascript"&gt;&lt;![CDATA[&#13;   //Running at the browser&#13;   window.Validate_errorbox = function (id, boxid, msg) {&#13;      var html = '&lt;div style="display:none;position:absolute" id="'&#13;             +boxid+'"&gt;'+zk.encodeXML(msg, true)+'&lt;/div&gt;';&#13;      document.body.insertAdjacentHTML("afterbegin", html);&#13;      return $e(boxid);   }&#13;]]&gt;&lt;/script&gt;&#13;</programlisting>
<para>【メモ】<code>:</code>
<code>zscript</code>はサーバーで実行されているコードを示します。一方、<code>script</code>はブラウザで実行されているスクリプトコードを表します。</para>
<para>【メモ】:<code>CustomConstraint</code>が実装されているなら、すべての承認がサーバーで行われるため<code>ClientConstraint</code>は無視されます。つまり、<code>ClientConstraint</code>を使用して、応答を改善する場合、<code>Validate_errobox</code>を上書きすることがエラーメッセージの表示を変更する唯一の方法です。</para></sect4></sect3><sect3><title>
<code>onChange</code>イベント</title>
<para>コンテンツがユーザによって変更された場合、入力制御は<code>onChange</code>イベントでアプリケーションに通知します。</para>
<para>
<code>onChange</code>のイベントリスナが呼び出された時、変数は設定されます。その時に不合理的な値を拒否するのは遅すぎます。さもなければ、適切な値を再設定しなければなりません。より良い方法として、<code>Custom Constraints</code>セクションで説明しているように、規制を使用することをお勧めします。</para></sect3><sect3><title>
<code>onChanging</code>イベント</title>
<para>ユーザーがコンテンツを変更している最中にしても、入力制御は<code>onChanging</code>イベントでアプリケーションを通知します。</para>
<para>
<code>onChanging</code>リスナが呼び出されたとき、値はまだ設定されていません。つまり、<code>value</code>プロパティは古いままです。ユーザーが入力したものを取得するために、以下のようにイベントの<code>value</code>プロパティを参照しなければなりません。</para>
<programlisting>&lt;grid&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;The onChanging textbox: &#13;         &lt;textbox onChanging="copy.value = event.value"/&gt;&lt;/row&gt;&#13;      &lt;row&gt;Instant copy:&#13;         &lt;textbox id="copy" readonly="true"/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&lt;/grid&gt;&#13;</programlisting>
<para>ユーザーがまだ変更を終えていないので、<code>onChanging</code>イベントリスナの中で不合理的な変数を拒否したくても早すぎてできません。より良い方法として、Custom Constraintsセクション中に書かれているように規制を使用することをお勧めします。</para></sect3></sect2><sect2><title>カレンダー
</title>			
<graphic align="center" fileref="img/10000000000001310000009425D8FF0B.png">2		</graphic>

<para>カレンダーは｢フラット｣カレンダーを表示し、ユーザーは日にちを選択することができます。</para>
<programlisting>&#13;&#13;&lt;hbox&gt;&#13;          &lt;calendar id="cal" onChange="in.value = cal.value"/&gt;    &#13;          &lt;datebox id="in" onChange="cal.value = in.value"/&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting><sect3><title>
<code>value</code>プロパティと<code>onChange</code>イベント</title>
<para>入力制御のように、カレンダーは<code>value</code>プロパティを提供しています。開発者は選択した日にちを設定したり、取得したりすることができます。さらに、必要ならば、開発者は<code>onChange</code>イベントントを監視し、直ちに処理することができます。</para></sect3><sect3><title>
<code>compact</code>プロパティ</title>
<para>
<graphic align="center" fileref="img/10000000000000BC0000007A5A0A2B82.png">2
			
		</graphic>カレンダーは二つの異なったレイアウトをサポートしていて、<code>compact</code>プロパティを使用することで、選択できます。</para>
<programlisting>&lt;calendar compact="true"/&gt;&#13;</programlisting>
<para>デフォルト値は現在の地域値(Locale)によります。</para></sect3></sect2><sect2><title>プログレスメーター</title>
<para>プログレスメーターはどのくらいのタスクが完了したかを示すバーです。<code>value</code>プロパティの値は0から100までです。</para>
<programlisting>&lt;progressmeter value="10"/&gt;<inlinegraphic fileref="img/100000000000006C0000000F34868BEC.png" align="right"/>&#13;</programlisting></sect2><sect2><title>スライダー</title>
<para>ユーザーはスライダーをスクロールすることで値を指定できます。</para>
<programlisting>&lt;slider id="slider" onScroll="Audio.setVolume(slider.curpos)"/&gt;<inlinegraphic fileref="img/100000000000006A000000106DB6D54E.png" align="right"/>&#13;</programlisting>
<para>スライダーは０から１００までの値を受け取ります。<code>Maxpos</code>プロパティを変更すれば制限された最大値を変更することができます。</para></sect2><sect2><title>タイマー</title>
<para>タイマーは特定の期間、時間に<code>onTimer</code>イベントをサーバーに送信する参照不可(invisible)のコンポーネントです。 <code>start</code>、<code>stop</code>メソッドによりタイマーを制御できます。</para>
<programlisting>&lt;window title="Timer demo" border="normal"&gt;<inlinegraphic fileref="img/10000000000000E50000003490E811F6.png" align="right"/>&#13;          &lt;label id="now"/&gt;    &#13;          &lt;timer id="timer" delay="1000" repeats="true"    &#13;                    onTimer="now.setValue(new Date().toString())"/&gt;        &#13;          &lt;separator bar="true"/&gt;    &#13;          &lt;button label="Stops timer" onClick="timer.stop()"/&gt;    &#13;          &lt;button label="Starts timer" onClick="timer.start()"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>ページング</title>
<para>ページングコンポーネントは長いコンテンツを多数のページに分けます。例えば、100の項目があるとして、一度に20項目表示するとしたら、以下のようにページングコンポーネントを使用します。</para>
<programlisting>&lt;paging totalSize="100" pageSize="20"/&gt;<inlinegraphic fileref="img/100000000000007A00000013F689AD21.png" align="right"/>&#13;</programlisting>
<para>ユーザーがhyperlinksをクリックした時、<code>onPaging</code>イベントと<code>org.zkoss.zul.event.PagingEvent</code> のインスタンスはページングコンポーネントに送信されます。100項目のうちのどの項目を見せるかを決めるために、リスナをページングコンポーネントに付加します。</para>
<programlisting>&lt;paging id="paging"/&gt;&#13;&lt;zscript&gt;&#13;          List result = new SearchEngine().find("ZK");    &#13;                    //assume SearchEngine.find() will return a list of items.        &#13;          paging.setTotalSize(result.size());    &#13;          paging.addEventListener("onPaging", new EventListener() {    &#13;                    public void onEvent(Event event) {        &#13;                              int pgno = event.getPaginal().getActivePage();            &#13;                              int ofs = pgno * event.getPaginal().getPageSize();            &#13;                              new Viewer().redraw(result, ofs, ofs + event.getPaginal().getPageSize() - 1);            &#13;                                //assume redraw(List result, int b, int e) will display        &#13;                                        //from the b-th item to the e-th item                &#13;                    }        &#13;          });    &#13;&lt;/zscript&gt;&#13;</programlisting><sect3><title>リストボックスとグリッドを使用したページング</title>
<para>
<code>listbox</code>と<code>grid</code>コンポーネントはページングをサポートしているので、視覚的レイアウトを持ちたくない限り、又ページングコンポーネントを使用して多数の<code>listbox</code>と<code>grid</code>を操作しない限り、上記のようにはっきりとページングコンポーネントを指定する必要はありません。</para>
<para>より詳しくはグリッドセクションを参照してください。</para></sect3></sect2></sect1><sect1><title>ウィンドウズ</title>
<para>HTML DIVタグのようなウィンドウはコンポーネントをグループ化します。他のコンポーネントとは違い、ウィンドウは以下の性質を持ちます。</para>
<orderedlist>
<listitem>
<para>ウィンドウはIDスペースの所有者です。ウィンドウの中に含まれているどのコンポーネント(ウィンドウも)も、識別子が指定されている場合、<code>getFellow</code>メソッドにより検索することができます。</para>
</listitem>
<listitem>
<para>ウィンドウはオーバーラップ、ポップアップ、埋め込みができます。</para>
</listitem>
<listitem>
<para>ウィンドウはモダールダイアログになることができます。</para>
</listitem>
</orderedlist><sect2><title>タイトルとキャプション</title>
<para>ウィンドウはタイトルとキャプションとボーダーを持つことができます。タイトルは<code>title</code>プロパティによって指定されます。キャプションは<code>caption</code>と呼ばれる子コンポーネントを宣言することで指定されます。すべての<code>caption</code>コンポーネントの子要素はタイトルの横に表示されます。</para>
<programlisting>&lt;window title="Demo" border="normal" width="350px"&gt;&#13;          &lt;caption&gt;    &#13;                    &lt;toolbarbutton label="More"/&gt;        &#13;                    &lt;toolbarbutton label="Help"/&gt;        &#13;          &lt;/caption&gt;    &#13;          &lt;toolbar&gt;    &#13;                    &lt;toolbarbutton label="Save"/&gt;        &#13;                    &lt;toolbarbutton label="Cancel"/&gt;        &#13;          &lt;/toolbar&gt;    &#13;          What is your favorite framework?    &#13;          &lt;radiogroup&gt;    <inlinegraphic fileref="img/10000000000001640000004CEB4969A9.png" align="right"/>&#13;                    &lt;radio label="ZK"/&gt;        &#13;                    &lt;radio label="JSF"/&gt;        &#13;          &lt;/radiogroup&gt;    &#13;    &lt;/window&gt;    &#13;</programlisting>
<para>キャプションにラベルとイメージを指定することができ、外見は以下のようになります。</para>
<programlisting>&lt;window id="win" title="Main" border="normal" width="200px"&gt;<inlinegraphic fileref="img/10000000000000CD00000042FABAB4CE.png" align="right"/>&#13;          &lt;caption image="/img/coffee.gif" label="Hi there!"/&gt;    &#13;          &lt;checkbox label="Hello, World!"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>
<code>closable</code>プロパティ</title>
<para>
<code>closable</code>プロパティにTrueを指定することで、閉じるボタンがウィンドウに表示され、ユーザーはボタンをクリックすると、ウィンドウが閉じます。閉じるボタンをクリックすると、直ちに<code>onClose</code>イベントがウィンドウに送られます。Windowの<code>onClose</code>メソッドによって処理されます。処理が終わったら、デフォルトで<code>onClose</code>は自身をウィンドウから切り離します。</para>
<para>オーバーライドしたりすることもできます。又は、リスナを登録して、デフォルト動作を変更することができます。例えば、閉じるのではなく、隠すようにすることができます。 </para>
<programlisting>&lt;window closable="true" title="Detach on Close" border="normal" width="200px"&#13;onClose="self.visible = false; event.stopPropagation();"&gt;&#13;          In this example, this window hides itself when the close button is clicked.    &#13;&lt;/window&gt;<inlinegraphic fileref="img/10000000000000CE000000546D42136E.png" align="right"/>&#13;</programlisting>
<para>
<code>event.stopPropagation()</code>は<code>Window.onClose()</code>の呼び出しを防ぐために呼び出されます。</para>
<para>【ヒント】：ウィンドウがポップアップなら、ユーザーがウィンドウの外をクリックするか、またはESCを押したときに、ポップアップが閉じられ、open=falseと一緒に<code>onOpen</code>イベントはウィンドウに送信されます。少し複雑ですが、<code>onClose</code>はサーバーに送信され、ウィンドウを外すか、隠すかをサーバーに確認します。デフォルトではウィンドウは外れます。また、アプリケーションはそれをオーバーライドでき、上に説明しているように、何でもしたいようにできます。一方で、<code>onOpen</code>は通知です。クライアントがウィンドウを隠したことをアプリケーションに通知するために送信されます。アプリケーションは隠されることを回避することはできません。また、外れることを変更することはできません。</para></sect2><sect2><title>
<code>sizable</code>プロパティ</title>
<para>ユーザーがウィンドウサイズを変更できるようにする場合、以下のように<code>sizable</code>プロパティに<code>true</code>を指定します。許可されると直ちに、ユーザーはボーダー(枠)をドラッグすることでウィンドウのサイズを変更することができます。</para>
<programlisting>&lt;window id="win" title="Sizable Window" border="normal" width="200px" sizable="true"&gt;&#13;          This is a sizable window.    &#13;          &lt;button label="Change Sizable" onClick="win.sizable = !win.sizable"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting><sect3><title>
<code>onSize</code>イベント</title>
<para>ユーザーがウィンドウサイズを変更すると、<code>onSize</code>イベントは<code>org.zkoss.zul.event.SizeEvent</code>のインスタンスと共に送られます。ここで注意してほしいのは、<code>onSize</code>イベントが送信される前にウィンドウのサイズは変更されます。つまり、<code>onSize</code>イベントは普段無視される通知として送信されるわけです。またイベントリスナ中で実行たいことはなんでもできます。</para>
<para>メモ： ユーザーが上、又は左のボーダーをドラッグしたら、位置が変更されるので<code>onMove</code>イベントも送信されます。</para></sect3></sect2><sect2><title>スタイルクラス(sclass)</title>
<para>ZKはウィンドウに対して４つの異なったスタイルクラスをサポートしています。<code>Embedded</code>、<code>overlapped</code>、<code>popup</code>、<code>wndcyan</code>です。また追加することもできます。</para>
<para>デフォルトでは、<code>sclass</code>のプロパティはウィンドウモードと同じです。つまり、異なったモード中では、ウィンドウは異なって表示されます。表示を変更するために、以下の例中で示されているように<code>sclass</code>のプロパティに変数を単純に指定します。</para>
<programlisting>&lt;hbox&gt;&#13;   &lt;window title="Embedded Style" border="normal" width="200px"&gt;&#13;      Hello, Embedded!&#13;   &lt;/window&gt;&#13;   &lt;window title="Cyan Style" sclass="wndcyan" border="normal" width="200px"&gt;&#13;      Hello, Cyan!&#13;   &lt;/window&gt;&#13;   &lt;window title="Popup Style" sclass="popup" border="normal" width="200px"&gt;&#13;      Hello, Popup!&#13;   &lt;/window&gt;&#13;   &lt;window title="Modal Style" sclass="modal" border="normal" width="200px"&gt;&#13;      Hello, Modal!&#13;   &lt;/window&gt;&#13;&lt;/hbox&gt;&#13;</programlisting><graphic align="center" fileref="img/100000000000033B0000003395A4C925.png">2
			
		</graphic></sect2><sect2><title>

<code>contentStyle</code>プロパティ</title>
<para>
<code>contentStyle</code>プロパティを指定することでウィンドウのコンテンツブロックの外見と印象を変更することができます。</para>
<programlisting>&lt;window title="My Window" border="normal" width="200px" contentStyle="background:yellow"&gt;<inlinegraphic fileref="img/10000000000000CB0000003292CB8174.png" align="right"/>&#13;          Hello, World!    &#13;&lt;/window&gt;&#13;</programlisting><sect3><title>スクロール可能なウィンドウ</title>
<para>
<code>contentType</code>の代表的な使用方法は以下のようにスクロール可能なウィンドウにすることです。</para>
<programlisting>&lt;window id="win" title="Hi" width="150px" height="100px" contentStyle="overflow:auto" border="normal"&gt;&#13;This is a long line to spead over several lines, and more content to display.&#13;Finally, the scrollbar becomes visible.<inlinegraphic fileref="img/100000000000009C0000006819656516.png" align="right"/>&#13;This is another line.&#13;&lt;/window&gt;&#13;&#13;</programlisting></sect3></sect2><sect2><title>ボーダー</title>
<para>
<code>border</code>プロパティはウィンドウにボーダーを表示するかどうか指定します。デフォルトスタイルシートは<code>normal</code>と<code>none</code>のみをサポートしています。デフォルト値は<code>none</code>です。 </para>
<para>また、スタイルクラスを追加することも可能です。例えば、</para>
<programlisting>&lt;zk&gt;&#13;          &lt;style&gt;    &#13;          div.wc-embedded-dash {    &#13;          padding: 2px; border: 3px dashed #aab;    &#13;          }    &#13;          &lt;/style&gt;    &#13;          &lt;window title="My Window" border="dash" width="200px"&gt;    &#13;          Hello, World!    <inlinegraphic fileref="img/10000000000000CD000000339BF9C5F9.png" align="right"/>&#13;          &lt;/window&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>
<code>wc-embedded-dash</code>はウィンドウ内側のボックスのスタイルを定義しています。スタイルクラスは頭に<code>wc</code>
<footnote>
<para>wc for window content, while wt for window title.</para>
</footnote>をつけて名前付けられます。<code>sclass</code>プロパティと<code>border</code>プロパティはともにダッシュ(-)で分けられています。この例では、<code>sclass</code>は指定されていないからデフォルトの値が<code>embedded</code>(このウィンドウが埋め込み式であるから)になっています。</para></sect2><sect2><title/></sect2><sect2><title>オーバーラップ、ポップアップ、モーダル、ハイライト、埋め込み</title>
<para>ウィンドウは４つの異なったモードのうちの一つモードで表示されます。オーバーラップ、ポップアップ、モーダル、ハイライト、埋め込みです。デフォルトでは埋め込みモードが使用されます。モードを変更したいときは、以下のように<code>doOverlapped</code>、<code>doPopup</code>、<code>doModal</code>、<code>doHighlighted</code>、<code>doEmbedded</code>メソッドを使用します。</para>
<programlisting>&lt;zk&gt;&#13;          &lt;window id="win" title="Hi!" border="normal" width="200px"&gt;    &#13;                    &lt;caption&gt;        &#13;                  &lt;toolbarbutton label="Close" onClick="win.setVisible(false)"/&gt;&#13;                    &lt;/caption&gt;        &#13;                    &lt;checkbox label="Hello, Wolrd!"/&gt;        &#13;          &lt;/window&gt;    &#13;        &#13;          &lt;button label="Overlap" onClick="win.doOverlapped();"/&gt;    &#13;          &lt;button label="Popup" onClick="win.doPopup();"/&gt;    &#13;          &lt;button label="Modal" onClick="win.doModal();"/&gt;    &#13;          &lt;button label="Embed" onClick="win.doEmbedded();"/&gt;    &#13;          &lt;button label="Highlighted" onClick="win.doHighlighed();"/&gt;    &#13;&lt;/zk&gt;&#13;</programlisting><sect3><title>埋め込み</title>
<para>埋め込みウィンドウは他のコンポーネントと一緒にテキスト間(インラインで)に位置させます。このモードでは位置がブラウザによって決められるので、位置を変更することはできません。</para></sect3><sect3><title>オーバーラップ</title>
<para>オーバーラップウィンドウは他のコンポーネントを重ねます。ユーザーはドラッグすることができ、開発者は<code>setLeft</code>と<code>setTop</code>メソッドによって位置を決めることができます。</para>
<para>
<code>doOverlapped</code>に加えて、以下のように<code>mode</code>プロパティを使用することができます。</para>
<programlisting>&lt;window title="My Overlapped" width="300px" mode="overlapped"&gt;&#13;&lt;/window&gt;&#13;</programlisting></sect3><sect3><title>ポップアップ</title>
<para>ユーザーがポップアップウィンドウとその子ウィンドウを除いた他のどのコンポーネントをクリックし、自動的にウィンドウが閉じられていしまう場合を除いて、ポップアップウィンドウはオーバーラップウィンドウと同じ働きをします。名前のとおり、ウィンドウのポップアップを実装するために設計されています。</para></sect3><sect3><title>モーダル</title>
<para>モーダルウィンドウ(aka.,モーダルダイアログ)は<code>endModal</code>、 <code>doEmbedded</code>、 <code>doOverlapped</code>、 <code>doHighlighted</code>、 <code>doPopup</code>メソッドのうちの一つが呼び出されて実行が中断されている場合を除いてオーバーラップウィンドウと同様の働きをします。</para>
<para>実行中断に加えて、モーダルウィンドウに所属していないコンポーネントを使用不可にします。</para>
<para>モーダルウィンドウは自動的にブラウザの中心に位置されます。位置変更はできません。</para></sect3><sect3><title>ハイライト</title>
<para>ハイライトウィンドウは視覚的な効果がモーダルウィンドウと同じであること以外はオーバーラップウィンドウと同じです。つまり、ハイライトウィンドウはブラウザの中心に位置され、ハイライトウィンドウに属していないコンポーネントは一時的に無効になります。</para>
<para>しかし、実行の中断はしません。オーバーラップウィンドウのように、モードが変更されると実行は次のステートメントへ継続されます。例えば、<code>f1()</code>は<code>win1</code>が閉じた後にのみ呼び出されます。一方で、<code>g()</code>は<code>win2</code>がハイライトされたすぐ後に呼び出されます。</para>
<programlisting>win1.doModal(); //the execution is suspended until win1 is closed&#13;f1();&#13;&#13;win2.doHighlighted(); //the execution won't be suspended&#13;g1()&#13;</programlisting>
<para>イベントプロセススレッドを中断したくない、使用したくない場合、モーダルウィンドウではなくハイライトウィンドウを使いましょう。上級者のための機能のサーブレットを使用してイベントを処理セクションを参照してください。</para></sect3><sect3><title>モーダルウィンドウとイベントリスナ</title>
<para>他のモードとは違い、イベントリスナの中ではウィンドウをモーダルモードにしか指定できません。つまり、イベントリスナ中で<code>doModal()</code>又は<code>setModal(“modal”)</code>を呼び出すことができます。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;window id="wnd" title="My Modal" visible="false" width="300px"&gt;&#13;      &lt;button label="close" onClick="wnd.visible = false"/&gt;&#13;   &lt;/window&gt;&#13;   &lt;button label="do it" onClick="wnd.doModal()"/&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>コンポーネント作成段階中<footnote>
<para>コンポーネントのライフサイクルをご覧ください。</para>
</footnote>で以下に書かれたプログラムを実行する場合、間違っています。</para>
<programlisting>//t1.zul&#13;&lt;window title="My Modal" width="300px" closable="true" mode="modal"&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>直接参照する場合、以下の結果<footnote>
<para>Tomcatを使用することと想定されます。.</para>
</footnote>が得られます。</para>
<para>
<graphic align="center" fileref="img/10000000000005110000034A677D3288.png">2
			
		</graphic>
</para>
<para>以下のコードは同じ結果を出します。</para>
<programlisting>//t2.zul&#13;&lt;window title="My Modal" width="300px" closable="true"&gt;&#13;          &lt;zscript&gt;    &#13;                    self.doModal();        &#13;          &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>ページ読み込み中にモーダルウィンドウの作成が必要なら、以下のように<code>onModal</code>イベントをポストできます。</para>
<programlisting>//t3.zul&#13;&lt;window title="My Modal" width="300px" closable="true"&gt;&#13;          &lt;zscript&gt;    &#13;          Events.postEvent("onModal", self, null);    &#13;          &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>【メモ】:<code>t1.zul</code>がウィンドウモードを直接モーダルに設定していても(上に示したように)以下のコードは正確に実行されます。どうしてでしょうか？それは(<code>onClick</code>用の)イベントリスナの中で実行されるからです。</para>
<programlisting>&lt;button label="do it"&gt;&#13;          &lt;attribute name="onClick"&gt;    &#13;          Executions.createComponents("t1.zul", null, null);    &#13;                    //it loads t1.zul in this event listener for onClick        &#13;          &lt;/attribute&gt;    &#13;&lt;/button&gt;&#13;</programlisting></sect3></sect2><sect2><title>
<code>position</code>プロパティ</title>
<para>
<code>left</code>と<code>top</code>プロパティに加えて、<code>position</code>プロパティの使用によって、<code>overlapped</code>/<code>popup</code>/<code>modal</code>ウィンドウの位置を操作することができます。例えば、下記コードは右下の角へウィンドウを位置させています。</para>
<programlisting>&lt;window width="300px" mode="overlapped" position="right,bottom"&gt;&#13;...&#13;</programlisting>
<para>
<code>position</code>プロパティの変数はコンマ(,)で区切ることで以下の定数を指定します。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>定数</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>Center</code>
</para>
</entry>
<entry>
<para>ウィンドウの中央。左又は右が指定されている場合、縦方向の中間を意味します。もし上と下が指定されていたら、横方向の中間を意味します。右も左も上も下も<code>n</code>
<code>one</code>ならば、ウィンドウの中心を意味します。</para>
<para>左と上のプロパティは無視されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>Left</code>
</para>
</entry>
<entry>
<para>ウィンドウの左縁</para>
<para>
<code>left</code>プロパティは無視されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>right</code>
</para>
</entry>
<entry>
<para>ウィンドウの右縁</para>
<para>
<code>left</code>プロパティは無視されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>Top</code>
</para>
</entry>
<entry>
<para>ウィンドウの上端</para>
<para>
<code>top</code>プロパティは無視されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>bottom</code>
</para>
</entry>
<entry>
<para>ウィンドウの下端</para>
<para>
<code>top</code>プロパティは無視されます。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>デフォルトでは値は<code>null</code>です。つまり、<code>overlapped</code>と<code>popup</code>ウィンドウは<code>left</code>と<code>top</code>プロパティによって指定されます。一方で、モーダルウィンドウは<code>center</code>に位置します。</para></sect2><sect2><title/></sect2><sect2><title>コモンダイアログ</title>
<para>XULコンポーネントセットは以下のコモンダイアログをサポートして、いくつかのコモンタスクを簡単にします。</para><sect3><title>メッセージボックス</title>
<para>
<code>org.zkoss.zul.Messagebox </code>クラスはメッセージボックスを表示するユーティリティのセットを提供します。代表的な動作として、エラーが発生した時にユーザーに知らせるか、又は決定をうながすのに使用されます。</para>
<programlisting>if (Messagebox.show("Remove this file?", "Remove?", Messagebox.YES | Messagebox.NO,&#13; Messagebox.QUESTION) == Messagebox.YES) {&#13;   ...//remove the file&#13;}&#13;</programlisting>
<para>ユーザーにエラーを知らせるのは一般的ですので、<code>alert</code>と呼ばれるグローバルファンクションが<code>zscript</code>に追加されました。<code>a</code>
<code>lert</code>ファンクションは<code>Messagebox</code>クラスの<code>show</code>メソッドのショートカットです。つまり、以下の二つのステートメントは同様の働きをします。</para>
<programlisting>alert("Wrong");&#13;Messagebox.show("Wrong");&#13;</programlisting>
<para>
<code>Messagebox</code>はモーダルウィンドウです。つまり、イベントリスナの中でのみ実行可能という同様の規制を共有しています。このため、以下のコードは実行されません。詳しくはModal Windows and Event Listeners セクションを参照してください。</para>
<programlisting>&lt;window title="Messagebox not allowed in paging loading"&gt;&#13;          &lt;zscript&gt;    &#13;          //failed since show cannot be called in paging loading    &#13;          if (Messagebox.show("Redirect?", "Redirect?",    &#13;          Messagebox.YES | Messagebox.NO, Messagebox.QUESTION) == Messagebox.YES)    &#13;                    Executions.sendRedirect("another.zul");        &#13;          &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect3><sect3><title>ファイルアップロードダイアログ</title>
<para>
<code>org.zkoss.zul.Fileupload</code>クラスはクライアントからサーバーへファイルをアップロードするときに使うユーティリティセットを提供します。<code>get</code>メソッドが呼び出されるとファイルアップロードダイアログはブラウザで表示され、アップロードするファイルを指定することをユーザーに確認します。ファイルがアップロードされるまで、又は取り消しボタンが押されるまで応答はしません。</para>
<programlisting>&lt;window title="Fileupload Demo" border="normal"&gt;&#13;          &lt;image id="image"/&gt;    &#13;          &lt;button label="Upload"&gt;    &#13;                    &lt;attribute name="onClick"&gt;{        &#13;                              Object media = Fileupload.get();            &#13;                              if (media instanceof org.zkoss.image.Image)            &#13;                                        image.setContent(media);                &#13;                              else if (media != null)            &#13;                                        Messagebox.show("Not an image: "+media, "Error",                &#13;                                                  Messagebox.OK, Messagebox.ERROR);                    &#13;                    }&lt;/attribute&gt;        &#13;          &lt;/button&gt;    &#13;&lt;/window&gt;&#13;</programlisting><para><graphic fileref="img/10000000000002C800000125B9E0AAC1.png" align="center"/></para><sect4><title>同時多数アップロード</title>
<para>同時に多数のファイルをアップロードすることを可能にする場合、以下のようにファイルアップロード可能最大個数を指定できます。</para>
<programlisting>&lt;window title="fileupload demo" border="normal"&gt;&#13;          &lt;button label="Upload"&gt;    &#13;                    &lt;attribute name="onClick"&gt;&lt;![CDATA[{        &#13;          Object media = Fileupload.get(5);    &#13;          if (media != null)    &#13;                    for (int j = 0; j &lt; media.length; ++j) {        &#13;                              if (media[j] instanceof org.zkoss.image.Image) {            &#13;                                        Image image = new Image();                &#13;                                        image.setContent(media[j]);                &#13;                                        image.setParent(pics);                &#13;                              } else if (media[j] != null) {            &#13;                                Messagebox.show("Not an image: "+media[j], "Error",        &#13;                                                  Messagebox.OK, Messagebox.ERROR);                    <inlinegraphic fileref="img/100000000000016B000000EAA87608DF.png" align="right"/>&#13;                              }            &#13;                    }        &#13;                    }]]&gt;&lt;/attribute&gt;        &#13;          &lt;/button&gt;    &#13;          &lt;vbox id="pics"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect4></sect3><sect3><title>
<code>fileupload</code> コンポーネント</title>
<para>
<code>fileupload</code>コンポーネントはモーダルダイアログではありません。むしろ、一つのコンポーネントです。他のコンポーネントとともにインラインで配置されます。</para>
<para>【メモ】:ダイアログをアップロードするファイルを開く静的な<code>get</code>メソッドを提供するのに加えて、<code>org.zkoss.zul.Fkileupload</code>自身がコンポーネントです。いわゆる<code>fileupload</code>コンポーネントです。</para>
<para>
例えば、</para>
<programlisting>&lt;image id="img"/&gt;&#13;Upload your hot shot:&#13;&lt;fileupload onUpload="img.setContent(event.media)"/&gt;&#13;</programlisting><sect4><title>
<graphic align="center" fileref="img/10000000000001130000004F6BCA5979.png">2
			
		</graphic><code>onUpload</code>イベント</title>
<para>Upload ボタンが押されると、<code>onUpload</code>イベントが<code>org.zkoss.zk.ui.event.UploadEvent</code> イベントのインスタンスとともに送信されます。<code>getMedia</code>又は<code>getMedias</code>メソッドを使用してアップロードファイルのコンテンツを取得することができます。</para>
<para>
<code>getMedia</code>と<code>getMedias</code>は<code>n</code>
<code>ull</code>を返して、ファイルが指定されていないけれども、アップロードボタンが押されたことを示します。</para></sect4><sect4><title>
<code>onClose</code>イベント</title>
<para>
<code>onUpload</code>に加えて、<code>onClose</code>イベントが送信され、Uploadボタン又は取り消しボタンが押されたことを通知します。<code>onClose</code>イベントはデフォルトでは<code>fileupload</code>コンポーネントを無効にします。つまり、すべての領域はクリアされ、再描画されます。</para></sect4></sect3><sect3><title>ファイルダウンロードダイアログ</title>
<para>
<code>org.zkoss.zul.Filedownload</code>クラスはサーバーからクライアントにファイルをダウンロードするときに使うユーティリティセットを提供します。ブラウザウィンドウの中でファイルを表示する<code>iframe</code>コンポーネントとは違い、<code>save</code>メソッドの一つが呼び出される時、ファイルダウンロードダイアログはブラウザで表示されます。ユーザーはそれを利用してファイルを保存するディレクトリーを指定します。</para>
<programlisting>&lt;button label="Download download.html"&gt;&#13;   &lt;attribute name="onClick"&gt;{&#13;   java.io.InputStream is =&#13; desktop.getWebApp().getResourceAsStream("/test/download.html");&#13;   if (is != null)&#13;      Filedownload.save(is, "text/html", "download.html");&#13;   else&#13;      alert("/test/download.html not found");&#13;   }&lt;/attribute&gt;&#13;&lt;/button&gt;&#13;&#13;</programlisting>
<para><graphic fileref="img/10000000000002AF000001BB582C2DD7.png" align="center"/></para>
</sect3></sect2></sect1><sect1><title>ボックスモデル</title>
<para>コンポーネント:<code>vbox</code>、<code>hbox</code>、<code>box</code>
</para>
<para>XULのボックスモデルはディスプレイをいくつかのボックスに分けます。ボックスの中のコンポーネントは自動的に縦、又は横方向で並びます。ボックスとセパレーターを合わせることで、視覚表現のレイアウトを制御します。</para>
<para>ボックスは横又は縦方向のうちの一方向に子コンポーネントを配置します。横方向ボックスは水平にコンポーネントを並べます。縦方向ボックスは縦に並べます。HTMLテーブルの一行又は一列のボックスを想像してください。</para>
<para>いくつかの例は以下に示されています。</para>
<programlisting>&lt;zk&gt;<inlinegraphic fileref="img/10000000000000A700000055120D8AF5.png" align="right"/>&#13;          &lt;vbox&gt;    &#13;                    &lt;button label="Button 1"/&gt;        &#13;                    &lt;button label="Button 2"/&gt;        &#13;          &lt;/vbox&gt;    &#13;          &lt;hbox&gt;    &#13;                    &lt;button label="Button 3"/&gt;        &#13;                    &lt;button label="Button 4"/&gt;        &#13;          &lt;/hbox&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>
<code>hbox</code>コンポーネントは縦方向に箱を作成します。どのコンポーネントも<code>hbox</code>の中では一列中に配置されます。<code>vbox</code>コンポーネントは縦方向にボックスを作成します。追加されたコンポーネントは次々と下に新しい行として並べられていきます。</para>
<para>水平方向をデフォルトとしている一般のボックスコンポーネントがあります。振る舞いは<code>hbox</code>と同様です。しかし、ボックスの方向を操作する<code>orient</code>プロパティを使用できます。このプロパティを<code>horizontal</code>に設定し、水平方向のボックスを作成することができます。またプロパティを<code>vertical</code>に設定することで縦方向のボックスを作成できます。</para>
<para>このため、以下の２行は同様の動作をします。</para>
<programlisting>&lt;vbox&gt;&#13;&lt;box orient="vertical"&gt;&#13;</programlisting>
<para>ボックスコンポーネントを含め、ボックスの中にたくさんのコンポーネントを追加することができます。水平方向のボックスでは、どの追加コンポーネントも前回追加されたもののすぐ右側に位置されます。コンポーネントは囲まれてはいないので、コンポーネントを加えたら加えた分だけウィンドウは広がっていきます。同様にして、縦ボックスに追加されたどの要素も前回追加されたものの下に配置されます。</para><sect2><title>
<code>spacing</code>プロパティ</title>
<para>ボックスコントロールの子要素の中の間隔をコントロールできます。例えば、以下の例は5emを上と下マージン両方に入れます。こうして、テキストボックスとデートボックスの間は10emになります。</para>
<programlisting>&lt;vbox spacing="5em"&gt;&#13;          &lt;textbox/&gt;    &#13;          &lt;datebox/&gt;    &#13;&lt;/vbox&gt;&#13;</programlisting>
<para>以下の例では、ゼロ間隔を使用することで面白いレイアウトを表示します。</para>
<programlisting>&lt;window title="Box Layout Demo" border="normal"&gt;&#13;          &lt;hbox spacing="0"&gt;    <inlinegraphic fileref="img/100000000000009300000077C9A14E08.png" align="right"/>&#13;                    &lt;window border="normal"&gt;0&lt;/window&gt;        &#13;                    &lt;vbox spacing="0"&gt;        &#13;                              &lt;hbox spacing="0"&gt;            &#13;                            &lt;window border="normal"&gt;1&lt;/window&gt;    &#13;                                    &lt;window border="normal"&gt;2&lt;/window&gt;            &#13;                                        &lt;vbox spacing="0"&gt;                &#13;                                                  &lt;window border="normal"&gt;3&lt;/window&gt;                    &#13;                                                  &lt;window border="normal"&gt;4&lt;/window&gt;                    &#13;                                        &lt;/vbox&gt;                &#13;                              &lt;/hbox&gt;            &#13;                              &lt;hbox spacing="0"&gt;            &#13;                                        &lt;vbox spacing="0"&gt;                &#13;                                                  &lt;window border="normal"&gt;5&lt;/window&gt;                     &#13;                                                  &lt;window border="normal"&gt;6&lt;/window&gt;                    &#13;                                        &lt;/vbox&gt;                &#13;                                        &lt;window border="normal"&gt;7&lt;/window&gt;                &#13;                                        &lt;window border="normal"&gt;8&lt;/window&gt;                &#13;                                        &lt;window border="normal"&gt;9&lt;/window&gt;                &#13;                              &lt;/hbox&gt;            &#13;                    &lt;/vbox&gt;        &#13;          &lt;/hbox&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>
<code>width</code>と<code>heights</code>プロパティ</title>
<para>以下のように<code>widths</code>プロパティを使用して、<code>hbox</code>のそれぞれのセルに<code>width</code>を指定できます。</para>
<programlisting>&lt;hbox width="100%" widths="10%,20%,30%,40%"&gt;&lt;label value="10%"/&gt;&lt;label value="20%"/&gt;&lt;label value="30%"/&gt;&lt;label value="40%"/&gt;&lt;/hbox&gt;&#13;</programlisting>
<para>変数はカンマで区切られた<code>widths</code>のリストです。変数が見つからなかったら、<code>width</code>は対応するセルへ生成されることはなく、表示される<code>width</code>はブラウザしだいです。</para>
<para>同様にして、<code>heights</code>プロパティと一緒に<code>vbox</code>のどのセルに対しても<code>heights</code>を指定できます。<code>orient</code>プロパティによってボックスの方向を縦にも横にもできるので、これら二つのプロパティは実質同じです。</para></sect2><sect2><title/></sect2><sect2><title>スプリッター</title>
<para>コンポーネント:<code>splitter</code>
</para>
<para>セクションのサイズが変更可能な二つのウィンドウセクションを表示しするときが何度かあると思います。スプリッターと呼ばれるコンポーネントを使用することでこの機能は実現されます。サイズ変更可能な二つのセクションの間に小さいバーは作成されます。 </para>
<para>
<graphic align="center" fileref="img/1000000000000328000000CFDFDC132B.png">2
			
		</graphic>スプリッターはボックスの中に置かなければなりません。横ボックス(<code>hbox</code>)の中にスプリッターが位置されているとき、横方向にサイズ変更が可能です。縦ボックス(<code>vbox</code>)の中にスプリッターが位置されているとき縦方向にサイズ変更が可能です。例えば、</para>
<para>コードは以下のようです。</para>
<programlisting>&lt;hbox spacing="0" style="border: 1px solid grey" width="100%"&gt;&#13;          &lt;vbox height="200px"&gt;    &#13;                    Column 1-1: The left-top box. To know whether a splitter        &#13;                    is collapsed, you can listen to the onOpen event.        &#13;                    &lt;splitter collapse="after"/&gt;        &#13;                    Column 1-2: You can enforce to open or collapse programming        &#13;                    by calling setOpen method.        &#13;          &lt;/vbox&gt;    &#13;          &lt;splitter collapse="before"/&gt;    &#13;          Column 2: Whether a splitter allows users to open or collapse    &#13;          depending on the collapse attribue.    &#13;&lt;/hbox&gt;&#13;</programlisting><sect3><title>
<code>collapse</code>プロパティ</title>
<para>グリッピー(ボタン)がクリックされたときスプリッターで分けられた両側のうち、どちらが折りたたまれる(隠される)か指定します。このプロパティが指定されていない場合、スプリッターは折りたたみを行いません。(grippyは表示されることもありません)</para>
<para>使用できる値と意味は以下に説明します。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>変数</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>none</para>
</entry>
<entry>
<para>折りたたみはしません。</para>
</entry>
</row>
<row>
<entry>
<para>before</para>
</entry>
<entry>
<para>グリッピーがクリックされたとき、同じ親コンポーネント中のスプリッタより一つ前の要素は折りたたまれます。つまりwidthとheightは0です。</para>
</entry>
</row>
<row>
<entry>
<para>after</para>
</entry>
<entry>
<para>グリッピーがクリックされたとき、同じ親コンポーネント中のスプリッタより一つ後の要素は折りたたまれます。つまりwidthとheightは0です。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>
<code>Open</code>プロパティ</title>
<para>スプリッターが折りたたまれたかどうか知るために、<code>open</code>プロパティの値をチェックします。(つまり、<code>isOpen</code>メソッド)プログラムで開く、又は折りたたむために、<code>open</code>プロパティの値を設定します(つまり、<code>setOpen</code>メソッド)。</para></sect3><sect3><title>
<code>onOpen</code>イベント</title>
<para>スプリッターがユーザーによって折りたたまれる、又は、開かれるとき、<code>onOpen</code>イベントがアプリケーションに送られます。 </para></sect3></sect2></sect1><sect1><title>タブボックス</title>
<para>コンポーネント: <code>tabbox</code>, <code>tabs</code>, <code>tab</code>
<code>,</code> <code>tabpanels</code>, <code>tabpanel</code>.</para>
<para>ユーザーインターフェースをシンプルにするため、開発者はタブボックスでコンポーネントをいくつかのグループに分けて、毎回一つのグループを表示させることができます。一度に一グループだけ参照することができます(aka.,パネル)。隠されているグループのタブがクリックされると、前面になり、クリック前に前面だったグループは後ろに隠されます。</para>
<para>タブボックスの一般的なシンタックスは以下のようです。</para>
<programlisting>&lt;tabbox&gt;<inlinegraphic fileref="img/10000000000000750000003EB9D9EBDA.png" align="right"/>&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="First"/&gt;        &#13;                    &lt;tab label="Second"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>tabbox</code>
<code>:</code>タブとタブパネルを含んでいる外側のボックス</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabs</code>
<code>:</code>
<code>タブのコンテナー。つまり、タブコンポーネントの集合</code>
<code> </code>
</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tab</code>:特定なタブ。タブをクリックするとタブパネルを前面に表示します。ラベルとイメージをそこに張ることができます。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabpanels</code>: タブパネルのコンテナー、つまり<code>tabpane</code>
<code>l</code>コンポーネントのコレクション。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>tabpanel</code>: 単タブパネルの内容。コンテンツをタブパネルの中のコンポーネントグループに割り当てます。初めの<code>tabpanel</code>は初めのタブに対応し、二番目の<code>tabpanel</code>は二番目のタブに対応しています。以下同様に三番目、四番目と続きます。 </para>
</listitem>
</itemizedlist>
<para>現在選ばれたタブコンポーネントに<code>t</code>
<code>rue</code>指定の追加<code>selected</code>プロパティが与えられます。これは現在選ばれたタブに異なった外観を持たせ、選ばれたように見えます。一度に、ただ一つのタブがこのプロパティに対して<code>t</code>
<code>rue</code>を持つことができます。</para>
<para>Javaコードによって選択されたタブを変更する方法は二つあります。それらは以下に示されたものと同様な働きをします。</para>
<programlisting>tab1.setSelected(true);&#13;tabbox.setSelectedTab(tab1);&#13;</programlisting>
<para>また、直接選択されたプロパティに<code>t</code>
<code>rue</code>を指定できます。</para>
<programlisting>&lt;tab label="My Tab" selected="true"/&gt;&#13;</programlisting>
<para>タブが一つも選択されていない場合、一番初めのタブが自動的に選ばれます。</para><sect2><title>多重タブボックス</title>
<para>タブパネルには他のタブボックスなどを含むことができます。</para>
<programlisting>&lt;tabbox&gt;<inlinegraphic fileref="img/10000000000000BF000000771BCF5F3B.png" align="right"/>&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="First"/&gt;        &#13;                    &lt;tab label="Second"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;        &#13;                    The first panel.        &#13;                    &lt;tabbox&gt;        &#13;                              &lt;tabs&gt;            &#13;                                        &lt;tab label="Nested 1"/&gt;                &#13;                                        &lt;tab label="Nested 2"/&gt;                &#13;                                        &lt;tab label="Nested 3"/&gt;                &#13;                              &lt;/tabs&gt;            &#13;                              &lt;tabpanels&gt;            &#13;                                        &lt;tabpanel&gt;The first nested panel&lt;/tabpanel&gt;                &#13;                                        &lt;tabpanel&gt;The second nested panel&lt;/tabpanel&gt;                &#13;                                        &lt;tabpanel&gt;The third nested panel&lt;/tabpanel&gt;                &#13;                              &lt;/tabpanels&gt;            &#13;                    &lt;/tabbox&gt;        &#13;                    &lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>アコーディオンタブボックス</title>
<para>タブボックスは二つの型をサポートしています:<code>default</code>と<code>accordion</code>(上下式)です。アコーディオン型は以下のようになっています。</para>
<programlisting>&lt;tabbox mold="accordion"&gt;<inlinegraphic fileref="img/100000000000007800000057AB443B27.png" align="right"/>&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="First"/&gt;        &#13;                    &lt;tab label="Second"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;The first panel.&lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;The second panel&lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>
<code/>
</title></sect2><sect2><title>
<code>orient</code>プロパティ</title>
<para>開発者は<code>orient</code>プロパティの使用してタブの配置を変更することができます。デフォルトでは横方向です。縦方向に変更することができます。その効果は以下のようです。</para>
<programlisting>&lt;tabbox width="400px" orient="vertical"&gt;<inlinegraphic fileref="img/1000000000000167000000AD8ECB7048.png" align="right"/>&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="A"/&gt;        &#13;                    &lt;tab label="B"/&gt;        &#13;                    &lt;tab label="C"/&gt;        &#13;                    &lt;tab label="D"/&gt;        &#13;                    &lt;tab label="E"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;            &lt;tabpanel&gt;This is panel A&lt;/tabpanel&gt;&#13;                    &lt;tabpanel&gt;This is panel B&lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;This is panel C&lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;This is panel D&lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;This is panel E&lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>
<code>closable</code>プロパティ</title>
<para>
<code>closable</code>プロパティを設定することで、タブに閉じるボタンが表示されます。そのため、ボタンをクリックすることで、ユーザーはタブと対応しているタブパネルを閉じることができます。ユーザーが閉じるボタンを押すと、<code>onClose</code>イベントがタブに送られます。タブの<code>onClose</code>メソッドによって処理されます。デフォルトでは<code>onClose</code>はタブそれ自身と対応しているタブパネルを外します。</para>
<para>【ヒント】：ウィンドウの <code>closable</code> 属性を参考にしてください。</para></sect2><sect2><title>タブパネルのロードオンデマンド</title>
<para>他の多くのコンポーネント同様、参照可能な(前面に表示されている)ときのみタブパネルのコンテンツを読み込むことができます。最も簡単な方法は<code>fulfill</code>属性を使用して、タブパネルの子コンポーネントの作成を遅らせます。</para>
<programlisting>&lt;tabbox&gt;&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="Preload" selected="true"/&gt;        &#13;                    &lt;tab id="tab2" label="OnDemand"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;        &#13;          This panel is pre-loaded since no fulfill specified    &#13;                    &lt;/tabpanel&gt;        &#13;                    &lt;tabpanel fulfill="tab2.onSelect"&gt;        &#13;          This panel is loaded only tab2 receives the onSelect event    &#13;                    &lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting>
<para>子コンポーネントを手動で作成するか、又はパネルを動的にうまく処理する場合、以下に説明したように、パネルが選択された時に<code>onSelect</code>イベントを監視して、パネルのコンテンツを実行します。</para>
<programlisting>&lt;tabbox id="tabbox" width="400" mold="accordion"&gt;&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="Preload"/&gt;        &#13;                    &lt;tab label="OnDemand" onSelect="load(self.linkedPanel)"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;        &#13;          This panel is pre-loaded.    &#13;                    &lt;/tabpanel&gt;        &#13;                    &lt;tabpanel&gt;        &#13;                    &lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;          &lt;zscript&gt;&lt;![CDATA[    &#13;          void load(Tabpanel panel) {    &#13;                    if (panel != null &amp;&amp; panel.getChildren().isEmpty())        &#13;                              new Label("Second panel is loaded").setParent(panel);            &#13;          }    &#13;          ]]&gt;&lt;/zscript&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect2></sect1><sect1><title>グリッド</title>
<para>コンポーネント: <code>grid</code>, <code>columns</code>, <code>column</code>, <code>rows</code>, <code>row</code>.</para>
<para>グリッドはテーブルのように列の中に並べられたコンポーネントを含んでいます。グリッド中で二種類のコンポーネントを宣言します。一つは行でヘッダーと行の属性を定義します。もうひとつは列でコンテンツを提供します。</para>
<para>列セットを宣言するために、<code>grid</code>の子要素である<code>rows</code>コンポーネントを使用します。中でどの列に対しても使用されている<code>row</code>コンポーネントを追加するべきです。<code>row</code>要素中で<code>row</code>中に配置したいコンテンツを配置します。どの子要素も特定の列の行です。</para>
<para>同様にして、<code>columns</code>コンポーネントを使用して、グリッドの子要素として<code>columns</code>を宣言します。どの列のコンテンツも所有している<code>row</code>とは異なり、<code>column</code>はwidth、alignmentといった一般的な属性とオプションのヘッダー(ラベル・イメージ)を宣言します。</para>
<programlisting>&lt;grid&gt;<inlinegraphic fileref="img/100000000000017D0000004DD592B1C3.png" align="right"/>&#13;          &lt;columns&gt;    &#13;                    &lt;column label="Type"/&gt;        &#13;                    &lt;column label="Content"/&gt;        &#13;          &lt;/columns&gt;    &#13;          &lt;rows&gt;    &#13;                    &lt;row&gt;        &#13;                              &lt;label value="File:"/&gt;            &#13;                              &lt;textbox width="99%"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Type:"/&gt;            &#13;                              &lt;hbox&gt;            &#13;                                        &lt;listbox rows="1" mold="select"&gt;                &#13;                                                  &lt;listitem label="Java Files,(*.java)"/&gt;                    &#13;                                                  &lt;listitem label="All Files,(*.*)"/&gt;                    &#13;                                        &lt;/listbox&gt;                &#13;                                        &lt;button label="Browse..."/&gt;                &#13;                              &lt;/hbox&gt;            &#13;                    &lt;/row&gt;        &#13;          &lt;/rows&gt;    &#13;&lt;/grid&gt;&#13;</programlisting><sect2><title>スクロール可能なグリッド</title>
<para>
<graphic align="center" fileref="img/10000000000001FC0000009FFC9DC218.png">2
			
		</graphic>
<code>height</code>プロパティを指定したら、スペースが十分広くなくてすべてのデータが表示できない場合、グリッドはスクロール可能になります。</para>
<programlisting>&lt;grid width="500px" height="130px"&gt;&#13;   &lt;columns&gt;&#13;<inlinegraphic fileref="img/7-5-1.png" align="right"/>      &lt;column label="Head 1"/&gt;&#13;      &lt;column label="Head 2" align="center"/&gt;&#13;      &lt;column label="Head 3" align="right"/&gt;&#13;   &lt;/columns&gt;   &lt;rows&gt;&#13;      &lt;row&gt;&#13;         &lt;listbox mold="select"&gt;&#13;            &lt;listitem label="Faster"/&gt;&#13;            &lt;listitem label="Fast"/&gt;&#13;            &lt;listitem label="Average"/&gt;&#13;         &lt;/listbox&gt;&#13;         &lt;datebox/&gt;&#13;         &lt;textbox rows="2"/&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;checkbox checked="true" label="Option 1"/&gt;&#13;         &lt;checkbox label="Option 2"/&gt;&#13;         &lt;radiogroup&gt;&#13;            &lt;radio label="Apple"/&gt;&#13;            &lt;radio label="Orange" checked="true"/&gt;&#13;            &lt;radio label="Lemon"/&gt;&#13;         &lt;/radiogroup&gt;&#13;      &lt;/row&gt;&#13;      &lt;row&gt;&#13;         &lt;checkbox checked="true" label="Option 1"/&gt;&#13;         &lt;checkbox label="Option 2"/&gt;&#13;         &lt;radiogroup orient="vertical"&gt;&#13;            &lt;radio label="Apple"/&gt;&#13;            &lt;radio label="Orange" checked="true"/&gt;&#13;            &lt;radio label="Lemon"/&gt;&#13;         &lt;/radiogroup&gt;&#13;      &lt;/row&gt;&#13;   &lt;/rows&gt;&lt;/grid&gt;&#13;</programlisting>
</sect2><sect2><title>サイズ変更可能な行</title>
<para>行の幅を変更できるようにするなら、以下のように<code>sizable</code> プロパティを<code>t</code>
<code>rue</code>に指定します。<code>tru</code>
<code>e</code>に指定したら、ユーザーは隣接した <code>column</code> コンポーネント中のボーダーをドラッグして行の幅を変更できます。</para>
<programlisting>&lt;window&gt;&#13;          &lt;grid&gt;    &#13;                    &lt;columns id="cs" sizable="true"&gt;        &#13;                              &lt;column label="AA"/&gt;            &#13;                              &lt;column label="BB"/&gt;            &#13;                              &lt;column label="CC"/&gt;            &#13;                    &lt;/columns&gt;        &#13;                    &lt;rows&gt;        &#13;                              &lt;row&gt;            &#13;                                        &lt;label value="AA01"/&gt;                &#13;                                        &lt;label value="BB01"/&gt;                &#13;                                        &lt;label value="CC01"/&gt;                &#13;                              &lt;/row&gt;            &#13;                              &lt;row&gt;            &#13;                                        &lt;label value="AA01"/&gt;                &#13;                                        &lt;label value="BB01"/&gt;                &#13;                                        &lt;label value="CC01"/&gt;                &#13;                              &lt;/row&gt;            &#13;                              &lt;row&gt;            &#13;                                        &lt;label value="AA01"/&gt;                &#13;                                        &lt;label value="BB01"/&gt;                &#13;                                        &lt;label value="CC01"/&gt;                &#13;                              &lt;/row&gt;            &#13;                    &lt;/rows&gt;        &#13;          &lt;/grid&gt;    &#13;      &lt;checkbox label="sizeable" checked="true" onCheck="cs.sizeable = self.checked"/&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect3><title>
<code>onColSize</code>イベント</title>
<para>ユーザーがwidthのサイズを変更すると、<code>onColSize</code>イベントは<code>org.zkoss.zul.event.ColSizeEvent</code>とともに送信されます。行のwidthは<code>onColSize</code>イベントが送られる前に調整されます。つまり、イベントは無視できる通知として送信されます。また、イベントリスナの中で追加したい動作を追加できます。</para></sect3></sect2><sect2><title>ページングとグリッド</title>
<para>グリッドの中の長いコンテンツをコントロールする方法は二つあります。スクロールとページングです。スクロールは前のセクションで話したように、<code>height</code>プロパティを指定することで使用可能になります。ページングは<code>paging</code>をモールド(<code>mold</code>)プロパティに指定することで使用可能です。ページングが一度使用可能になると、グリッドはコンテンツを分けていくつかのページにします。以下に説明したように一つのページに表示します。</para>
<programlisting>&lt;grid width="300px" mold="paging" pageSize="4"&gt;<inlinegraphic fileref="img/1000000000000133000000737A37B110.png" align="right"/>&#13;          &lt;columns&gt;    &#13;                    &lt;column label="Left"/&gt;        &#13;                    &lt;column label="Right"/&gt;        &#13;          &lt;/columns&gt;    &#13;          &lt;rows&gt;    &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 1.1"/&gt;&lt;label value="Item 1.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 2.1"/&gt;&lt;label value="Item 2.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 3.1"/&gt;&lt;label value="Item 3.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 4.1"/&gt;&lt;label value="Item 4.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 5.1"/&gt;&lt;label value="Item 5.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 6.1"/&gt;&lt;label value="Item 6.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item 7.1"/&gt;&lt;label value="Item 7.2"/&gt;            &#13;                    &lt;/row&gt;        &#13;          &lt;/rows&gt;    &#13;&lt;/grid&gt;&#13;</programlisting>
<para>ページングモールドが設定されると、グリッドはグリッドの子要素としてページングコンポーネントのインスタンスを作成します。それはページングを制御します。</para><sect3><title>
<code>pageSize</code>プロパティ</title>
<para>一度、ページングモールドが設定されると、<code>pageSize</code>プロパティを使用して一度に指定できる列の数を指定します(つまりページサイズ)。デフォルトでは20です。</para></sect3><sect3><title>
<code>paginal</code>プロパティ</title>
<para>ページングコンポーネントを異なった位置におく場合、又は一つのページングコンポーネントを使用して、二つ以上のグリッドをコントロールする場合、<code>paginal</code>プロパティをはっきりと指定します。確実に設定されていない場合はページングプロパティと同じです。</para>
<programlisting>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &lt;vbox&gt;&lt;paging id="pg" pageSize="4"/&gt;&lt;hbox&gt;      &lt;grid width="300px" mold="paging" paginal="${pg}"&gt;            &lt;columns&gt;                  &lt;column label="Left"/&gt;&lt;column label="Right"/&gt;            &lt;/columns&gt;            &lt;rows&gt;                  &lt;row&gt;                        &lt;label value="Item 1.1"/&gt;&lt;label value="Item 1.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 2.1"/&gt;&lt;label value="Item 2.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 3.1"/&gt;&lt;label value="Item 3.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 4.1"/&gt;&lt;label value="Item 4.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 5.1"/&gt;&lt;label value="Item 5.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 6.1"/&gt;&lt;label value="Item 6.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item 7.1"/&gt;&lt;label value="Item 7.2"/&gt;                  &lt;/row&gt;            &lt;/rows&gt;      &lt;/grid&gt;      &lt;grid width="300px" mold="paging" paginal="${pg}"&gt;            &lt;columns&gt;                  &lt;column label="Left"/&gt;&lt;column label="Right"/&gt;            &lt;/columns&gt;            &lt;rows&gt;                  &lt;row&gt;                        &lt;label value="Item A.1"/&gt;&lt;label value="Item A.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item B.1"/&gt;&lt;label value="Item B.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item C.1"/&gt;&lt;label value="Item C.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item D.1"/&gt;&lt;label value="Item D.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item E.1"/&gt;&lt;label value="Item E.2"/&gt;                  &lt;/row&gt;                  &lt;row&gt;                        &lt;label value="Item F.1"/&gt;&lt;label value="Item F.2"/&gt;                  &lt;/row&gt;            &lt;/rows&gt;      &lt;/grid&gt;&lt;/hbox&gt;&lt;/vbox&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <inlinegraphic fileref="img/100000000000026C00000066A82ED1BB.png" align="right"/>&#13;</programlisting></sect3><sect3><title>
<code>paging</code>プロパティ</title>
<para>それは読み出し専用のプロパティで、子ページングコンポーネントを表しています。その子ページングコンポーネントは自動的に生成され、ページングを処理します。<code>p</code>
<code>aginal</code>プロパティによって、外部のページングを指定した場合、それは<code>null</code>です。ほとんどの場合では、<code>paging</code> より<code>paginal</code>を使うと便利です。</para></sect3><sect3><title>
<code>onPaging</code>イベントとメソッド</title>
<para>ユーザーがページングコンポーネントのページ番号をクリックしたら、<code>onPaging</code>イベントはグリッドに送信されます。デフォルトで、そのメソッドは<code>rows</code>のコンテンツを無効にし、つまり、再度書き込みます。</para>
<para>creat-on-demand要素を実装する場合、<code>onPaging</code>イベントに対してイベントリスナをグリッドに追加できます。</para>
<programlisting>grid.addEventListener(org.zkoss.zul.event.ZulEvents.ON_PAGING, new MyListener());&#13;</programlisting></sect3></sect2><sect2><title/></sect2><sect2><title>並び替え</title>
<para>グリッドは列のソーティング(並び替え)をサポートしています。特定の行を昇順にするために、行の<code>sortAscending</code>プロパティに<code>java.util.Comparator</code>のインスタンスを指定します。同様にして、降順にする<code>sortDescending</code>プロパティにコンペアレーターを指定します。</para>
<para>以下に説明しているように、グリッド中の適当な２列を比較するのに、コンペアレーターを初めに実装します。<code>sortAscending</code>と<code>sortDescending</code>プロパティにそのインスタンスを指定します。<code>compare</code>メソッドは二つの<code>org.zkoss.zul.Row</code>のインスタンスと共に呼び出されます。</para>
<programlisting>&lt;zk&gt;&#13;          &lt;zscript&gt;    &#13;                    class MyRowComparator implements Comparator {        &#13;                              public MyRowComparator(boolean ascending) {            &#13;                              ...            &#13;                              }            &#13;                              public int compare(Object o1, Object o2) {            &#13;                                        Row r1 = (Row)o1, r2 = (Row)o2;                &#13;                                        ....                &#13;                              }            &#13;                    }        &#13;                    Comparator asc = new MyRowComparator(true);        &#13;                    Comparator dsc = new MyRowComparator(false);        &#13;          &lt;/zscript&gt;    &#13;          &lt;grid&gt;    &#13;                    &lt;columns&gt;        &#13;                              &lt;column sortAscending="${asc}" sortDescending="${dsc}"/&gt;            &#13;...&#13;</programlisting><sect3><title>
<code>sortDirection</code>プロパティ</title>
<para>
<code>sortDirection</code>プロパティはクライアントで特定の行の順番を示すためのアイコンを表示させるかどうかをコントロールします。列がグリッドに加えられる前に並び替えるなら、確実にこのプロパティを設定すべきです。</para>
<programlisting>&lt;column sortDirection="ascending"/&gt;&#13;</programlisting>
<para>同じ行にコンペアレーターを指定する限り、グリッドによって自動的に保存されます。</para></sect3><sect3><title>
<code>onSort</code>イベント</title>
<para>一行に少なくとも一つのコンペアレーターを指定してユーザーがそれらをクリックした場合、<code>onSort</code>イベントはサーバーに送られます。<code>c</code>
<code>olumn</code>コンポーネントはリスナを実装して自動的に指定されたコンペアレーターを元にして列をソートします。</para>
<para>手動でそれを制御する場合、<code>onSort</code>イベントを行うために、自身のリスナを行に追加することができます。デフォルトリスナに<code>sort</code>メソッドを呼び出させないために、イベントを受け取るたびに<code>stopPropagation</code>メソッドを呼び出さなければなりません。代わりに以下に示すように、<code>sort</code>メソッドをオーバーライドできます。</para></sect3><sect3><title>
<code/>
</title></sect3><sect3><title>
<code>sort</code>メソッド</title>
<para>
<code>sort</code>メソッドはデフォルトの<code>onSort</code>イベントリスナの元々実装されているものです。Javaコードによって列をソートする場合はとても便利です。例えば、適切な順番になっていない列を追加した後に、このメソッドを呼び出します。</para>
<programlisting>Row row = new Row();&#13;row.setParent(rows);&#13;row.appendChild(...);&#13;...&#13;if (!"natural".column.getSortDirection())&#13;          column.sort("ascending".equals(column.getSortDirection()));    &#13;</programlisting>
<para>デフォルトのソートアルゴリズムはquick-sortです(<code>org.zkoss.zk.ui.Components</code>クラスの中の<code>sort</code>メソッドを使用します)。自身の実装でオーバーライドできます。</para>
<para>【メモ】:<code>sort</code>メソッドは並び替えの方向のチェックを行います(<code>getSortDirection</code>の呼び出します)。方向が異なっている場合のみ、列をソートします。ソートを行うために、以下のようにします。</para>
<programlisting>column.setSortDirection("natural");&#13;sort(myorder);&#13;</programlisting>
<para>上のコードは以下のものと同様の働きをします。</para>
<programlisting>sort(myorder, true);&#13;</programlisting></sect3></sect2><sect2><title>ライブデータ</title>
<para>リストボックスのように、グリッドはライブデータをサポートします。ライブデータを使うと、開発者はビューからデータを分けることができます。つまり、開発者はグリッドを直接処理することよりむしろ、<code>org.zkoss.zul.ListModel</code>インターフェースを実装し、データを提供するだけが必要になります。その利点は二つあります。</para>
<itemizedlist>
<listitem>
<para>簡単に異なったビューで同じデータセットを示すことができます。</para>
</listitem>
<listitem>
<para>グリッドはデータを参照可能な(visible)場合にのみクライアントに送信します。データ量が大きい場合にネットワークの通信量が増えることを防ぎます。</para>
</listitem>
</itemizedlist>
<para>ライブデータを使用するには三つのステップがあります。</para>
<orderedlist>
<listitem>
<para>
<code>ListModel</code>の形のデータを準備します。ZKではオブジェクト群を表すための<code>org.zkoss.zul.SimpleListModel</code>と呼ばれる具体的な実装があります。</para>
</listitem>
<listitem>
<para>データ列をグリッドにレンダリングするために<code>org.zkoss.zul.RowRenderer</code>インターフェースを実装します。</para>
</listitem>
<listitem>
<para>データを<code>model</code>プロパティの中に指定します。必要な場合は<code>rowRenderer</code>プロパティ中にレンダ装置を指定します。</para>
</listitem>
</orderedlist>
<para>また、ステップ2は、以下の二項目に分かれています。</para>
<itemizedlist>
<listitem>
<para>これを指定するかどうかは選択できます。指定されていない場合、デフォルトのレンダ装置は初めの行にデータをレンダリングします。</para>
</listitem>
<listitem>
<para>異なったビューの中に同じデータを表示するには異なったレンダ装置を実装します。</para>
</listitem>
</itemizedlist>
<para>以下の例中では、<code>strset</code>と呼ばれるリストモデルを準備し、<code>model</code>プロパティを使って、グリッドに指定します。そうしてグリッドは残りの作業を行ってくれます。</para>
<programlisting>    &lt;window title="Live Grid" border="normal"&gt;&#13;   &lt;zscript&gt;&#13;      String[] data = new String[30];&#13;<inlinegraphic fileref="img/100000000000006900000083A11BBF49.png" align="right"/>      for(int j=0; j &amp;lt; data.length; ++j) {&#13;         data[j] = "option "+j;&#13;      }&#13;      ListModel strset = new SimpleListModel(data);&#13;   &lt;/zscript&gt;&#13;   &lt;grid width="100px" height="100px" model="${strset}"&gt;&#13;      &lt;columns&gt;&#13;         &lt;column label="options"/&gt;&#13;      &lt;/columns&gt;&#13;   &lt;/grid&gt;&lt;/window&gt;&#13;</programlisting>
<sect3><title>ライブデータを使用したソート</title>
<para>ライブデータが使用されているグリッドを並び替えられるようにするなら、<code>org.zkoss.zul.ListModel</code>のほかに、<code>org.zkoss.zul.ListModelExt</code>のインターフェースを実装しなければなりません。</para>
<programlisting>class MyListModel implements ListModel, ListModelExt {&#13;          public void sort(Comparator cmpr, boolean ascending) {    &#13;                    //do the real sorting        &#13;                    //notify the grid (or listbox) that data is changed by use of ListDataEvent        &#13;          }    &#13;}&#13;</programlisting>
<para>ユーザーがグリッドにソートを要求するとき、グリッドはデータソートのための<code>ListModelExt</code>の<code>sort</code>メソッドを呼び出します。つまり、ソーティングはグリッドよりもリストモデルによってソートが行われます。</para>
<para>ソートの後に、リストモデルは(<code>addListDataListener</code> メソッドにより)グリッドに指定された<code>org.zkoss.zul.event.ListDataListener</code>の<code>onChange</code>メソッドを呼び出し、グリッドに通知します。ほとんどの場合、すべてのデータは変更されます。そうしてリストモデルは以下のイベントを送信します。</para>
<programlisting>new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1) &#13;</programlisting></sect3></sect2><sect2><title>特別なプロパティ</title><sect3><title>
<code>spans</code>プロパティ</title>
<para>コンマによって分けられた整数のリストで、一つのセルにいくつの行を設定するかを制御できます。リスト中の初めの数字は初めのセルが一つに囲んでいる行の数を表します。二つ目の数字は二番目の行の数を表します。３番目４番目…は以下同様です。数字を指定しない場合、１が入ります。</para>
<para>例えば、</para>
<programlisting>&lt;grid&gt;&#13;          &lt;columns&gt;    &#13;                    &lt;column label="Left" align="left"/&gt;&lt;column label="Center" align="center"/&gt;        &#13;                    &lt;column label="Right" align="right"/&gt;&lt;column label="Column 4"/&gt;        &#13;                    &lt;column label="Column 5"/&gt;&lt;column label="Column 6"/&gt;        &#13;          &lt;/columns&gt;    &#13;          &lt;rows&gt;    &#13;                    &lt;row&gt;        &#13;                              &lt;label value="Item A.1"/&gt;&lt;label value="Item A.2"/&gt;            &#13;                              &lt;label value="Item A.3"/&gt;&lt;label value="Item A.4"/&gt;            &#13;                              &lt;label value="Item A.5"/&gt;&lt;label value="Item A.6"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row spans="1,2,2"&gt;        &#13;                              &lt;label value="Item B.1"/&gt;&lt;label value="Item B.2"/&gt;            &#13;                              &lt;label value="Item B.4"/&gt;&lt;label value="Item B.6"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row spans="3"&gt;        &#13;                              &lt;label value="Item C.1"/&gt;&lt;label value="Item C.4"/&gt;            &#13;                              &lt;label value="Item C.5"/&gt;&lt;label value="Item C.6"/&gt;            &#13;                    &lt;/row&gt;        &#13;                    &lt;row spans=",,2,2"&gt;        &#13;                              &lt;label value="Item D.1"/&gt;&lt;label value="Item D.2"/&gt;            &#13;                              &lt;label value="Item D.3"/&gt;&lt;label value="Item D.5"/&gt;            &#13;                    &lt;/row&gt;        &#13;          &lt;/rows&gt;    &#13;&lt;/grid&gt;&#13;</programlisting></sect3></sect2></sect1>
<graphic align="center" fileref="img/100000000000031500000070C388AAA9.png"></graphic><sect1><sect2><title>セパレータとスペース</title>
<para>コンポーネント: <code>separator</code> , <code>space</code>.</para>
<para>セパレータは二つのコンポーネントの間にスペースを挿入します。セパレータの型を決めるにはいくつかの方法があります。</para>
<orderedlist>
<listitem>
<para>
<code>orient</code>プロパティを使用して、縦、又は横セパレータを指定します。デフォルトでは横セパレータです。一方で、縦のセパレータは白いスペースに挿入されます。さらに、<code>space</code>はデフォルト方向が縦で、セパレータの変形です。</para>
</listitem>
<listitem>
<para>
<code>bar</code>プロパティを使用して、コンポーネントの間に横又は縦の線を表示するかどうかを操作します。</para>
</listitem>
<listitem>
<para>
スペーシングプロパティを使用して、スペースのサイズを設定します。</para>
</listitem>
</orderedlist>
<programlisting>&lt;window&gt;&#13;          line 1 by separator    &#13;          &lt;separator/&gt;    &#13;          line 2 by separator    &#13;          &lt;separator/&gt;    &#13;          line 3 by separator&lt;space bar="true"/&gt;another piece    &#13;          &lt;separator spacing="20px"/&gt;    &#13;<inlinegraphic align="right" fileref="img/10000000000001170000007AB8B71E54.png"/>line 4 by separator&lt;space bar="true" spacing="20px"/&gt;another piece    &#13;&lt;/window&gt;&#13;</programlisting></sect2><sect2><title>グループボックス</title>
<para>コンポーネント: <code>groupbox</code>.</para>
<para>グループボックスはコンポーネントをグループ化します。一グループまとまっていることを示すため、ボーダーをコンポーネントの周りに表示します。</para>
<para>グループボックスのトップにまたがるラベルは<code>caption</code>コンポーネントを使用することで作成されます。HTMLのキャプション要素に似ています。</para>
<para>ウィンドウとは違い、グループボックスはIDスペースの所有者ではありません。また、オーバーラップにもポップアップにもなりません。</para>
<programlisting>&lt;groupbox width="250px"&gt;<inlinegraphic fileref="img/100000000000015B000000394024E796.png" align="right"/>&#13;          &lt;caption label="Fruits"/&gt;    &#13;          &lt;radiogroup&gt;    &#13;                    &lt;radio label="Apple"/&gt;        &#13;                    &lt;radio label="Orange"/&gt;        &#13;                    &lt;radio label="Banana"/&gt;        &#13;          &lt;/radiogroup&gt;    &#13;&lt;/groupbox&gt;&#13;</programlisting>
<para>デフォルトに加えて、グループボックスは三番目の型をサポートしています。三番目の型が使われると、simple-tabのタブボックスと同様の働きをします。初めに<code>open</code>プロパティによってコンテンツが参照可能かどうかを決定します。同様にして、<code>onOpen</code>イベントを受信したときにグループボックスのコンテンツを作成できます。</para>
<programlisting>&lt;groupbox mold="3d" open="true" width="250px"&gt;&#13;          &lt;caption label="fruits"/&gt;    <inlinegraphic fileref="img/10000000000000FA000000416860D242.png" align="right"/>&#13;          &lt;radiogroup&gt;    &#13;                    &lt;radio label="Apple"/&gt;        &#13;                    &lt;radio label="Orange"/&gt;        &#13;                    &lt;radio label="Banana"/&gt;        &#13;          &lt;/radiogroup&gt;    &#13;&lt;/groupbox&gt;&#13;</programlisting><sect3><title>
<code>contentStyle</code>プロパティとスクロール可能なグループボックス</title>
<para>
<code>contentStyle</code>プロパティはグループボックスのコンテンツブロックにCSSスタイルを指定します。このため、以下のように<code>overflow:auto</code>(<code>overflow:auto</code>)を指定することでグループボックスをスクロール可能にします。</para>
<programlisting>&lt;groupbox mold="3d" width="150px" contentStyle="height:50px;overflow:auto"&gt;&#13;          &lt;caption label="fruits"/&gt;    &#13;          &lt;radiogroup onCheck="fruit.value = self.selectedItem.label" orient="vertical"&gt;    &#13;                    &lt;radio label="Apple"/&gt;        <inlinegraphic fileref="img/10000000000000960000005F20FC9CD7.png" align="right"/>&#13;                    &lt;radio label="Orange"/&gt;        &#13;                    &lt;radio label="Banana"/&gt;        &#13;          &lt;/radiogroup&gt;    &#13;&lt;/groupbox&gt;&#13;</programlisting>
<para>【メモ】: デフォルトが使われているなら、<code>contentStyle</code>プロパティは無視されます。</para>
<para>
<code>contentStyle</code>プロパティ中で<code>height</code>はコンテンツブロック(キャプションは除く)のheightを意味します。こうして<code>groupbox</code>を外した場合(つまり、コンテンツブロックが参照可能ではない場合)グループブロックの高さは縮み、キャプションのみ残ります。一方で、(heightプロパティを使用して)グループボックス全体のheightを指定する場合は、グループボックスが解除されたとき、コンテンツブロックのみが消え、height全体がそのまま残ります。</para></sect3></sect2><sect2><title/></sect2><sect2><title>ツールバー</title>
<para>コンポーネント: <code>toolbar</code> , <code>toolbarbutton</code>.</para>
<para>ツールバーはツールバーボタンのようなボタンのシリーズを配置します。ツールバーボタンはツールバーなしで使用できます。また、ツールバーはツールボタンなしでも使用できます。しかし、ツールボタンがツールバー内に配置されるとき、見た目が変わります。</para>
<para>ツールバーは二つの方向があります。横方向と縦方向です。それはボタンがどの方向に配置されるかを設定します。</para>
<programlisting>&lt;toolbar&gt;<inlinegraphic fileref="img/100000000000011100000014F49FBE5E.png" align="right"/>&#13;          &lt;toolbarbutton label="button1"/&gt;    &#13;          &lt;toolbarbutton label="button2"/&gt;    &#13;&lt;/toolbar&gt;&#13;</programlisting></sect2></sect1><sect1><title>メニューバー</title>
<para>コンポーネント: <code>menubar</code>, <code>menupopup</code>, <code>menu</code>, <code>menuitem</code>, <code>menuseparator</code>.</para>
<para>メニューバーはメニュー項目とサブメニューのコレクションを含んでいます。サブメニューはメニュー項目と他のサブメニューを含んでいます。これらの項目からユーザーが選んで実行できるメニューツリーが構成されます。</para>
<para>メニューバーの例は以下です。</para>
<programlisting>&lt;menubar&gt;<inlinegraphic fileref="img/10000000000001570000003F0A980060.png" align="right"/>&#13;          &lt;menu label="File"&gt;    &#13;                    &lt;menupopup&gt;        &#13;                              &lt;menuitem label="New"/&gt;            &#13;                              &lt;menuitem label="Open"/&gt;            &#13;                              &lt;menuseparator/&gt;            &#13;                              &lt;menuitem label="Exit"/&gt;            &#13;                    &lt;/menupopup&gt;        &#13;          &lt;/menu&gt;    &#13;          &lt;menu label="Help"&gt;    &#13;                    &lt;menupopup&gt;        &#13;                              &lt;menuitem label="Index"/&gt;            &#13;                              &lt;menu label="About"&gt;            &#13;                                        &lt;menupopup&gt;                &#13;                                                  &lt;menuitem label="About ZK"/&gt;                    &#13;                                                  &lt;menuitem label="About Potix"/&gt;                    &#13;                                        &lt;/menupopup&gt;                &#13;                              &lt;/menu&gt;            &#13;                    &lt;/menupopup&gt;        &#13;          &lt;/menu&gt;    &#13;&lt;/menubar&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>menubar</code>:メニュー項目(<code>menuitem</code>)とメニュー(<code>menu</code>)のコレクションの最上段のコンテナーです。 </para>
</listitem>
<listitem>
<para>
<code>menu</code>: ポップアップメニューのコンテナー。親部分で表示されるラベルを定義します。ユーザーがクリックするとポップアップメニュが表示されます。</para>
</listitem>
<listitem>
<para>
<code>menupopup</code>: メニュー項目(<code>menuitem</code>)とメニュー(<code>menu</code>)のコレクションのコンテナー(<code>menuitem</code>)。メニューの子です。<code>m</code>
<code>enu</code>のラベルがクリックされると表示されます。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>menuitem</code>: メニューの個別コマンド。メニューバーの中やポップアップメニューの中に表示されます。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>menuseparator</code>:メニュー中のセパレーターバー。ポップアップメニュー中に表示されます。 </para>
</listitem>
</itemizedlist><sect2><title>メニューコマンドの実行</title>
<para>メニューコマンドはメニュー項目に関連しています。コマンドを使用する方法は二つあります。<code>onClick</code>イベントと<code>href</code>プロパティです。<code>onClick</code>イベントのためにイベントリスナがメニュー項目に追加されると、項目がクリックされたときリスナが呼び出されます。</para>
<programlisting>&lt;menuitem onClick="draft.save()"/&gt;&#13;</programlisting>
<para>一方で、<code>href</code>プロパティにハイパーリンクを指定して、メニュー項目がクリックされたときに特定のURLへ移動させることができます。</para>
<programlisting>&lt;menuitem href="/edit"/&gt;&#13;&lt;menuitem href="http://zk1.sourceforge.net"/&gt;&#13;</programlisting>
<para>イベントリスナと<code>href</code>の両方が指定されると、実行されます。しかしながら、イベントリスナがサーバー内で動作すると、ブラウザは現在のURLから指定されたものへ既に変わっている可能性があります。そのため、イベントリスナから生成したすべての返信は無視されます。</para></sect2><sect2><title>チェックボックスとしてのメニュー項目の使用</title>
<para>メニュー項目はチェックボックスのように使用することができます。<code>c</code>
<code>hecked</code>プロパティはメニュー項目がチェックされたかどうかを表します。チェックされた場合、チェック項目はメニュー項目の前に表示されます。</para>
<para>
<code>c</code>
<code>hecked</code>プロパティをプログラムすることに加えて、<code>autocheck</code>プロパティに<code>true</code>を指定します。そのため、ユーザーがメニュー項目をクリックすると、その<code>checked</code>プロパティにチェックマークが保存されます。</para>
<programlisting>&lt;menuitem label="" autocheck="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>autodrop</code>プロパティ</title>
<para>デフォルトではユーザーがクリックするとポップアップメニューが開かれます。プログラマーがマウスがその上を移動すると自動的にポップアップメニューが開かれるように変更することもできます。この設定は<code>autodrop</code>プロパティを<code>t</code>
<code>rue</code>にすることで可能です。</para>
<programlisting>&lt;menubar autodrop="true"&gt;&#13;          ...    &#13;&lt;/menubar&gt;&#13;</programlisting></sect2><sect2><title>
<code>onOpen</code>イベント</title>
<para>
<code>menupopup</code>が表示される直前(又は隠れる直前)<code>onOpen</code>イベントは通知するため<code>menupopup</code>に送信されます。複雑なアプリケーション用に、<code>onOpen</code>イベントを受け取るまで、<code>menupopup</code>のコンテンツ作成を遅らせるか、又は動的にコンテンツをうまく処理します。詳しくは、ZKユーザーインターフェースマークアップ言語章のロードオンデマンドセクションを参照ください。</para></sect2><sect2><title>その他のメニュー機能</title>
<para>
<code>box</code>のように、<code>orient</code>プロパティを使用して、メニューの方向を操作できます。デフォルトでは横方向です。</para>
<para>他のコンポーネントのように、プロパティ、サブメーメニューの作成を含めて、メニューを動的に変更することができます。<code>zkdemo</code>中の<code>test</code>ディレクトリの下の<code>menu.zul</code>を参照してください。</para></sect2></sect1><sect1><title>コンテキストメニュー</title>
<para>コンポーネント: <code>popup</code>, <code>menupopup</code>.</para>
<para>XULコンポーネントのコンテクストプロパティに<code>popup</code>や<code>menupopup</code>コンポーネントのIDを指定できます。そうすることで、<code>popup</code>や<code>menupopup</code>コンポーネントはユーザーが右クリックするときに開かれます。</para>
<para>以下に記述したように、コンテキストメニューはただ単にIDをコンテキストプロパティに指定することで使用可能になります。また、多数のコンポーネントに同じIDを指定することができます。</para>
<programlisting>&lt;label value="Right Click Me!" context="editPopup"/&gt;&#13;&lt;separator bar="true"/&gt;&lt;label value="Right Click Me!" onRightClick="alert(self.value)"/&gt;&#13;&lt;menupopup id="editPopup"&gt;<inlinegraphic fileref="img/100000000000017500000052E60F488A.png" align="right"/>&#13;      &lt;menuitem label="Undo"/&gt;&#13;      &lt;menuitem label="Redo"/&gt;&#13;      &lt;menu label="Sort"&gt;&#13;                    &lt;menupopup&gt;        &#13;                       &lt;menuitem label="Sort by Name" autocheck="true"/&gt;    &#13;                       &lt;menuitem label="Sort by Date" autocheck="true"/&gt;    &#13;                    &lt;/menupopup&gt;        &#13;      &lt;/menu&gt;&#13;&lt;/menupopup&gt;&#13;</programlisting>
<para>そのIDと関連しているコンポーネントを右クリックするまで<code>menupopup</code>は参照可能ではありません。</para>
<para>【秘訣】: ブラウザのデフォルトのコンテキストメニューを使用不可にしする場合、存在しないIDをコンテキストプロパティに指定します。</para>
<para>
<code>popup</code>コンポーネントは<code>menupopup</code>より一般的な<code>popup</code>です。<code>popup</code>の中にどのタイプのコンポーネントも置くことができます。例えば、</para>
<programlisting>&lt;label value="Right Click Me!" context="any"/&gt;&#13;&#13;&lt;popup id="any" width="300px"&gt;&#13;          &lt;vbox&gt;    &#13;                    It can be anything.        &#13;                    &lt;toolbarbutton label="ZK" href="http://zk1.sourceforge.net"/&gt;        &#13;          &lt;/vbox&gt;    &#13;&lt;/popup&gt;&#13;</programlisting><sect2><title>カスタマイズ可能な<code>Tooltip</code>とポップアップメニュー</title>
<para>コンポーネントをユーザーが右クリックしたときポップアップを開ける他に、ZKはいくつかの状況でポップアップを開くことができます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>プロパティ</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>context</code>
</para>
</entry>
<entry>
<para>コンテキストプロパティを伴ったコンポーネントをユーザーが右クリックしたとき、<code>popup</code>又は<code>menupopup</code>コンポーネントは指定されたidと共に表示されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>tooltip</code>
</para>
</entry>
<entry>
<para>ユーザーがマウスポインタを動かして<code>tooltip</code>プロパティを伴うコンポーネントの上を通り過ぎたとき、<code>popup</code>又は<code>menupopup</code>コンポーネントが指定された<code>id</code>共に表示されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>popup</code>
</para>
</entry>
<entry>
<para>ユーザーが<code>popup</code>プロパティを伴ったコンポーネントをクリックしたとき、<code>popup</code>又は<code>menupopup</code>コンポーネントは指定されたidと共に表示されます。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>たとえば、</para>
<programlisting>&lt;window title="Context Menu and Right Click" border="normal" width="360px"&gt;&#13;   &lt;label value="Move Mouse Over Me!" tooltip="editPopup"/&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;label value="Tooptip for Another Popup" tooltip="any"/&gt;&#13;   &lt;separator bar="true"/&gt;&#13;   &lt;label value="Click Me!" popup="editPopup"/&gt;&#13;   &lt;menupopup id="editPopup"&gt;&#13;        &lt;menuitem label="Undo"/&gt;&#13;       &lt;menuitem label="Redo"/&gt;&#13;        &lt;menu label="Sort"&gt;&#13;         &lt;menupopup&gt;&#13;              &lt;menuitem label="Sort by Name" autocheck="true"/&gt;&#13;              &lt;menuitem label="Sort by Date" autocheck="true"/&gt;&#13;         &lt;/menupopup&gt;&#13;        &lt;/menu&gt;   &lt;/menupopup&gt;&#13;   &lt;popup id="any" width="300px"&gt;&#13;      &lt;vbox&gt;&#13;         ZK simply rich.         &#13;&lt;toolbarbutton label="ZK your killer Web application now!" href="http://zk1.sourceforge.net"/&gt;&#13;      &lt;/vbox&gt;&#13;   &lt;/popup&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>同じページ中である限り、<code>popup</code>、<code>tooltip</code>、<code>context</code>プロパティの中で識別子を指定することができます。つまり、IDスペースによって制限されていません。</para></sect2><sect2><title>
<code>onOpen</code>イベント</title>
<para>コンテキストメニュ、<code>tooltip</code>又はポップアップが表示される直前(又は隠れる直前)<code>onOpen</code>イベントがコンテキスト<code>tooltip</code>又はポップアップメニューに通知するため送信されます。イベントは<code>org.zkoss.zk.ui.event.OpenEvent</code>クラスのインスタンスです。また、<code>getReference</code>メソッドを呼び出すことで、コンテキストメニュー、<code>tooltip</code>、ポップアップを呼び出すコンポーネントを取得することができます。</para>
<para>パフォーマンスを改善するために、コンテキストが参照可能になるまでコンテキストの作成を遅らせることができます。</para>
<para>コンテキストの作成を遅らせる最も簡単な方法は以下のように<code>fulfill</code>属性を使用することです。</para>
<programlisting>&lt;popup id="any" width="300px" fulfill="onOpen"&gt;&#13;      &lt;button label="Hi"/&gt;&lt;!-- whatever content --&gt;&#13;&lt;/popup&gt;&#13;</programlisting>
<para>こうして、コンテキスト(Hiボタン)はページが読み込まれたとき作成されません。その代わり、<code>onOpen</code>イベントが初めて受信したときにコンテキストは作成されます。</para>
<para>Javaでコンテキストを動的にうまく処理するなら、以下のように<code>onOpen</code>イベントを監視することができます。</para>
<programlisting>&lt;popup id="any" width="300px"&gt;&#13;          &lt;attribute name="onOpen"&gt;    &#13;          if (event.isOpen()) {    &#13;                    if (self.getChildren().isEmpty()) {        &#13;                              new Button("Hi").seParent(self);            &#13;                              ...            &#13;                    }        &#13;                    if (event.getReference() instanceof Textbox) {        &#13;                              //you can do component-dependent manipulation here            &#13;                              ...            &#13;                    }        &#13;          }    &#13;          &lt;/attribute&gt;&lt;/popup&gt;    &#13;</programlisting></sect2></sect1><sect1><title>リストボックス</title>
<para>コンポーネント: <code>listbox</code>, <code>listitem</code>, <code>listcell</code>, <code>listhead</code>, <code>listheader</code>.</para>
<para>リストボックスはリスト中で項目を表示します。ユーザーはリストから項目を選択することができます。</para>
<para>最も簡単なフォーマットは以下のようです。それは１行・１選択のリストボックスです。</para>
<programlisting>&lt;listbox&gt;<inlinegraphic fileref="img/100000000000007A0000002F3C489432.png" align="right"/>&#13;          &lt;listitem label="Butter Pecan"/&gt;    &#13;          &lt;listitem label="Chocolate Chip"/&gt;    &#13;          &lt;listitem label="Raspberry Ripple"/&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting>
<para>リストボックスには二つのモードがあります:<code>default</code>と<code>select</code>です。<code>s</code>
<code>elect</code>が使用されているなら、HTMLの<code>SELECT</code>タグが変わりに生成されます。</para>
<programlisting>&lt;listbox mold="select"&gt;...&lt;/listbox&gt;<inlinegraphic fileref="img/1000000000000085000000343B08C7D1.png" align="right"/>&#13;</programlisting>
<para>【注意】: モードが<code>select</code>で、<code>rows</code>が１、そして、項目が一つもマーク(選択)されていないなら、ブラウザは１番目の項目が選ばれた場合と同様に<code>listbox</code>に1番目の項目を表示します。ユーザーが始めの項目を選んでしまったら、<code>onSelect</code>イベントは送信されません。混乱を避けるために開発者は少なくとも一項目、つまり<code>mold=select</code>と<code>rows=1</code>を選択すべきです。</para>
<para>ラベルのほかに、アプリケーション依存の値を<code>setValue</code>メソッドを使用して項目ごとに指定できます。</para>
<para>マウスを使わずに入力：<code>listbox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>UP</code>と<code>DOWN</code>で選択項目を上下します。</para>
</listitem>
<listitem>
<para>
<code>PgUp</code>と<code>PgDn</code>は一ページ単位で選択を移動します。</para>
</listitem>
<listitem>
<para>
<code>HOME</code>は選択を初めの項目に移動し、<code>END</code>は最後の項目へ移動します。</para>
</listitem>
<listitem>
<para>
<code>Ctrl+UP</code>と<code>Ctrl+DOWN</code>は選択を変更することなく、フォーカスをリスト項目一個分上下します。</para>
</listitem>
<listitem>
<para>
<code>SPACE</code>はフォーカスしている項目に決定します。</para>
</listitem>
</itemizedlist><sect2><title>多数行のリストボックス</title>
<para>リストボックスは多数行をサポートします。ユーザーが項目を選択するとき、列全体が選ばれます。 </para>
<para>多数行リストを指定するのに、リスト項目ごと(列)の行のように<code>listcell</code>コンポーネントを指定する必要があります。 </para>
<programlisting>&lt;listbox width="200px"&gt;&#13;          &lt;listitem&gt;    <inlinegraphic fileref="img/10000000000000D10000002C2459185A.png" align="right"/>&#13;                    &lt;listcell label="George"/&gt;        &#13;                    &lt;listcell label="House Painter"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Mary Ellen"/&gt;        &#13;                    &lt;listcell label="Candle Maker"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Roger"/&gt;        &#13;                    &lt;listcell label="Swashbuckler"/&gt;        &#13;          &lt;/listitem&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>行のヘッダー</title>
<para>
<code>listhead</code>と<code>listheader</code>を使うことで行のヘッダーを以下のように指定します<footnote>
<para>この機能はlisthead 、listheaderを使用するかについて、XULとは少し異なります。</para>
</footnote>。ラベルに加えて、<code>image</code>プロパティを使用することでヘッダーとしてイメージを指定できます。</para>
<programlisting>&lt;listbox width="200px"&gt;<inlinegraphic fileref="img/10000000000000D00000003725942D16.png" align="right"/>&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="Name"/&gt;        &#13;                    &lt;listheader label="Occupation"/&gt;        &#13;          &lt;/listhead&gt;    &#13;...&#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>行のフッター</title>
<para>
<code>listfoot</code>と<code>lisfooter</code>を以下のように使用することで行のフッターを指定できます。<code>l</code>
<code>isthead</code>と<code>listfoot</code>の順番は問題になりません。<code>listhead</code>のインスタンスはリストボックスへ追加されます。それは一番目の子要素でなければなりません。また、<code>listfoot</code>インスタンスの場合は、最後の子要素でなければなりません。</para>
<programlisting>&lt;listbox width="200px"&gt;<inlinegraphic fileref="img/10000000000000D00000006D18232918.png" align="right"/>&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="Population"/&gt;        &#13;                    &lt;listheader align="right" label="%"/&gt;        &#13;          &lt;/listhead&gt;    &#13;          &lt;listitem id="a" value="A"&gt;    &#13;                    &lt;listcell label="A. Graduate"/&gt;        &#13;                    &lt;listcell label="20%"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem id="b" value="B"&gt;    &#13;                    &lt;listcell label="B. College"/&gt;        &#13;                    &lt;listcell label="23%"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem id="c" value="C"&gt;    &#13;                    &lt;listcell label="C. High School"/&gt;        &#13;                    &lt;listcell label="40%"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem id="d" value="D"&gt;    &#13;                    &lt;listcell label="D. Others"/&gt;        &#13;                    &lt;listcell label="17%"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listfoot&gt;    &#13;                    &lt;listfooter label="More or less"/&gt;        &#13;                    &lt;listfooter label="100%"/&gt;        &#13;          &lt;/listfoot&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>ドロップダウンリスト</title>
<para>
<code>select</code>型と一つの列を指定することでドロップダウンリストを作成することができます。ドロップダウンリストへ多数行は使用できません。</para>
<programlisting>&lt;listbox mold="select" rows="1"&gt;<inlinegraphic fileref="img/1000000000000049000000488DCF4463.png" align="right"/>&#13;          &lt;listitem label="Car"/&gt;    &#13;          &lt;listitem label="Taxi"/&gt;    &#13;          &lt;listitem label="Bus" selected="true"/&gt;    &#13;          &lt;listitem label="Train"/&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting></sect2><sect2><title>複数選択</title>
<para>ユーザーがリスト項目をクリックしたとき、項目全体が選択されます。そして、<code>onSelect</code>イベントはサーバーに送り返されて、アプリケーションに通知します。リストボックスが<code>multiple</code>プロパティに<code>t</code>
<code>rue</code>を設定することで多数の選択が可能になります。デフォルトの値は<code>false</code>です。</para></sect2><sect2><title>スクロール可能なリストボックス</title>
<para>
<code>rows</code>プロパティ又は<code>height</code>プロパティを指定し、リスト項目がその長さを超えれば、リストボックスはスクロール可能になります。</para>
<programlisting>&lt;listbox width="250px" rows="4"&gt;&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="Name" sort="auto"/&gt;        &#13;                    &lt;listheader label="Gender" sort="auto"/&gt;        <inlinegraphic fileref="img/10000000000001010000005ED2DEF030.png" align="right"/>&#13;          &lt;/listhead&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Mary"/&gt;        &#13;                    &lt;listcell label="FEMALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="John"/&gt;        &#13;                    &lt;listcell label="MALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Jane"/&gt;        &#13;                    &lt;listcell label="FEMALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Henry"/&gt;        &#13;                    &lt;listcell label="MALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem&gt;    &#13;                    &lt;listcell label="Michelle"/&gt;        &#13;                    &lt;listcell label="FEMALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting><sect3><title>
<code>rows</code>プロパティ</title>
<para>
<code>rows</code>プロパティは参照可能なrows(列)の数を設定します。ゼロに設定することより、リストボックスはそれ自身のサイズを変更し、可能な限り項目数に対応します。</para></sect3></sect2><sect2><title>サイズ変更可能なリストヘッダー</title>
<para>
<code>columns</code>のように、<code>listhead</code>の<code>sizable</code>プロパティを<code>t</code>
<code>rue</code>に設定することでリストヘッダの幅を変更可能にします。同様にして、<code>onColSize</code>イベントはユーザーが幅をサイズ変更したときに送信されます。</para></sect2><sect2><title>ページングを伴ったリストボックス</title>
<para>グリッドのように、多数ページを使用し、ページングの型を指定することで、長いコンテンツをリストボックスに表示します。同様にして、ページごとにいくつの項目を表示するか、ページ選択時の動作をカスタマイズするかどうかを決定できます。より詳しくは、Gridsセクションを参照してください。</para></sect2><sect2><title>ソーティング</title>
<para>リストボックスは直接リスト項目をソーティングすることをサポートします。特定の行のソーティングを可能にする方法はいくつかあります。一番簡単な方法は以下のように<code>auto</code>にリストヘッダーの<code>sort</code>プロパティを設定することです。リストヘッダーに関連している行は指定された行のリストセルごとのラベルを基にしてソート可能です。</para>
<programlisting>&lt;zk&gt;&#13;          &lt;listbox width="200px"&gt;    &#13;                    &lt;listhead&gt;        &#13;                              &lt;listheader label="name" sort="auto"/&gt;            &#13;                              &lt;listheader label="gender" sort="auto"/&gt;            <inlinegraphic fileref="img/10000000000000CF0000005D419F9D95.png" align="right"/>&#13;                    &lt;/listhead&gt;        &#13;                    &lt;listitem&gt;        &#13;                              &lt;listcell label="Mary"/&gt;            &#13;                              &lt;listcell label="FEMALE"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem&gt;        &#13;                              &lt;listcell label="John"/&gt;            &#13;                              &lt;listcell label="MALE"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem&gt;        &#13;                              &lt;listcell label="Jane"/&gt;            &#13;                              &lt;listcell label="FEMALE"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem&gt;        &#13;                              &lt;listcell label="Henry"/&gt;            &#13;                              &lt;listcell label="MALE"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                  &lt;/listbox&gt;            &#13;&lt;/zk&gt;&#13;</programlisting><sect3><title>
<code>sortAscending</code>と<code>sortDescending</code>プロパティ</title>
<para>異なった方法でリスト項目をソートするなら、<code>java.util.Comparator</code>インスタンスを<code>sortAscending</code>、<code>sortDescending</code>プロパティの両方又はどちらかに指定します。一度指定すると、リスト項目は<code>ascending</code>、<code>descending</code>の両方か、又はどちらかに指定したコンペアレーターを使用して記憶されます。</para>
<para>
<code>a</code>
<code>uto</code>を伴った<code>sort</code>プロパティの起動は自動的に<code>sortAscending</code>と<code>sortDescending</code>に二つのコンペアレーターを指定します。それに他のコンペアレーターを指定することでオーバーライドできます。</para>
<para>例えば、リストセルのラベルではなくて、リスト項目の値を基にしてソートすることを想定します。以下のように、<code>listitemComparator</code>のインスタンスをこれらのプロパティに指定します。</para>
<programlisting>&lt;zscript&gt;&#13;          Comparator asc = new ListitemComarator(-1, true, true);    &#13;          Comparator dsc = new ListitemComarator(-1, false, true);    &#13;&lt;/zscript&gt;&#13;&lt;listbox&gt;&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader sortAscending="${asc}" sortDescending="${dsc}"/&gt;        &#13;...&#13;</programlisting></sect3><sect3><title>
<code>sortDirection</code>プロパティ</title>
<para>
<code>sortDirection</code>プロパティはクライアントで特定の行の列の項目を表示するかどうかを決めます。リスト項目がリストボックスに追加される前に記録されるなら、このプロパティを確実に設定すべきです。</para>
<programlisting>&lt;listheader sortDirection="ascending"/&gt;&#13;</programlisting>
<para>そのため、リストヘッダーにコンペアレーターを指定する限り、リストボックスに自動的に保存されます。</para></sect3><sect3><title>
<code>onSort</code>イベント</title>
<para>リストヘッダーに少なくとも一つコンペアレーターを指定するとき、ユーザーがクリックした場合、<code>onSort</code>イベントがサーバーへ送信されます。リストヘッダーはリスナを実装して、ソーティングを自動的に操作します。</para>
<para>手動で制御するなら、<code>onSort</code>イベントが送信されるときのためにリストヘッダーにリスナを追加できます。デフォルトリスナに<code>sort</code>メソッドを呼び出させないために、イベントが受信されたときのために<code>stopPropagation</code>メソッドを呼び出さなければなりません。代わりに、以下に示すように<code>sort</code>メソッドをオーバーライドできます。</para></sect3><sect3><title>
<code>sort</code>メソッド</title>
<para>
<code>sort</code>メソッドはデフォルトの<code>onSort</code>イベントリスナ用の実装です。Javaコードでリスト項目をソートしたい場合に便利です。例えば、項目が追加された後に（適切な順番で無い場合を想定します)このメソッドを呼び出します。</para>
<programlisting>new Listem("New Stuff").setParent(listbox);&#13;if (!"natural".header.getSortDirection())&#13;          header.sort("ascending".equals(header.getSortDirection()));    &#13;</programlisting>
<para>デフォルトのソーティングアルゴリズムはquick-sortです(<code>org.zkoss.zk.ui.Components</code>クラスの<code>sort</code>メソッドを使用します)。自身の実装でオーバーライドまたは前のセクションで説明したように<code>onSort</code>イベントを監視することができます。</para>
<para>【ヒント】： 多量なライブデータのソーティングはパフォーマンスを著しく低下させるかもしれません。<code>onSort</code>イベント、又は<code>sort</code>メソッドを中断し、効率的に処理させるほうがいいでしょう。以下のSort Live Dataセクションをご覧ください。</para></sect3></sect2><sect2><title>特別なプロパティ</title><sect3><title>
<code>checkmark</code>プロパティ</title>
<para>
<code>checkmark</code>プロパティはそれぞれの項目の前にあるcheckbox又はradioボタン表示させるかどうかを決めます。</para>
<para>
<graphic align="center" fileref="img/10000000000001C20000005540C9B7A9.png">2
			
		</graphic>以下の例中で、左のリストボックスから右のリストボックスへと項目を移動させたとき、どのようにcheckboxが自動的に追加されるかわかると思います。checkboxは右から左へ移動するときに外れます。</para>
<programlisting>&lt;hbox&gt;&#13;          &lt;listbox id="src" rows="0" multiple="true" width="200px"&gt;    &#13;                    &lt;listhead&gt;        &#13;                              &lt;listheader label="Population"/&gt;            &#13;                              &lt;listheader label="Percentage"/&gt;            &#13;                    &lt;/listhead&gt;        &#13;                    &lt;listitem id="a" value="A"&gt;        &#13;                              &lt;listcell label="A. Graduate"/&gt;            &#13;                              &lt;listcell label="20%"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem id="b" value="B"&gt;        &#13;                              &lt;listcell label="B. College"/&gt;            &#13;                              &lt;listcell label="23%"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem id="c" value="C"&gt;        &#13;                              &lt;listcell label="C. High School"/&gt;            &#13;                              &lt;listcell label="40%"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;                    &lt;listitem id="d" value="D"&gt;        &#13;                              &lt;listcell label="D. Others"/&gt;            &#13;                              &lt;listcell label="17%"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;          &lt;/listbox&gt;    &#13;          &lt;vbox&gt;    &#13;                    &lt;button label="=&amp;gt;" onClick="move(src, dst)"/&gt;        &#13;                    &lt;button label="&amp;lt;=" onClick="move(dst, src)"/&gt;        &#13;          &lt;/vbox&gt;    &#13;          &lt;listbox id="dst" checkmark="true" rows="0" multiple="true" width="200px"&gt;    &#13;                    &lt;listhead&gt;        &#13;                              &lt;listheader label="Population"/&gt;            &#13;                              &lt;listheader label="Percentage"/&gt;            &#13;                    &lt;/listhead&gt;        &#13;                    &lt;listitem id="e" value="E"&gt;        &#13;                              &lt;listcell label="E. Supermen"/&gt;            &#13;                              &lt;listcell label="21%"/&gt;            &#13;                    &lt;/listitem&gt;        &#13;          &lt;/listbox&gt;    &#13;          &lt;zscript&gt;    &#13;void move(Listbox src, Listbox dst) {&#13;          Listitem s = src.getSelectedItem();    &#13;          if (s == null)    &#13;                    Messagebox.show("Select an item first");        &#13;          else    &#13;<inlinegraphic align="right" fileref="img/10000000000000CD0000006D96B78742.png"/>                    s.setParent(dst);        &#13;}&#13;          &lt;/zscript&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting>
<para>
右に表示されているように、<code>multiple</code>プロパティが<code>false</code>なら、radioボタンが代わりに表示されます。</para></sect3><sect3><title>
<code>vflex</code>プロパティ</title>
<para>
<code>vflex</code>プロパティは与えられたスペースに合うように縦方向の伸縮を調節します。いわゆる縦方向の柔軟性です。例えば、リストがブラウザウィンドウ中ではあまりに大きいばあい、ブラウザウィンドウ中で、高さを縮ませてリスト全体を参照できるようにします。</para>
<para>このプロパティは<code>rows</code>プロパティが指定されていた場合無視されます。</para></sect3><sect3><title>
<code>maxlength</code>プロパティ</title>
<para>
<code>maxlength</code>プロパティはブラウザにて表示する最大の文字数を定義します。このプロパティを設定することで、リストボックスを狭くできます。</para></sect3></sect2><sect2><title>ライブデータ</title>
<para>グリッド<footnote>
<para>Swing (<code>javax.swing.ListModel</code>)のコンセプトと類似しています。</para>
</footnote>のようにリストボックスはライブデータをサポートしています。ライブデータを使うと、開発者はビューからデータを分けます。つまり開発者の仕事は、直接リストボックスを処理することより、むしろ<code>org.zkoss.zul.ListModel</code>インターフェースを実装することによる、データ供給だけが必要となります。利点は２つあります。</para>
<itemizedlist>
<listitem>
<para>簡単に異なったビューで同じデータセットを表示することができます。</para>
</listitem>
<listitem>
<para>グリッドはデータを参照可能な(visible)場合にのみクライアントに送信します。データ量が大きい場合にネットワークの通信量が増えることを防ぎます。</para>
</listitem>
</itemizedlist>
<para>ライブデータを使用する三つのステップがあります。</para>
<orderedlist>
<listitem>
<para>
<code>ListModel</code>のフォーム中でデータを準備します。ZKではオブジェクト群を表示するために<code>org.zkoss.zul.SimpleListModel</code>と呼ばれる具体的な実装があります。</para>
</listitem>
<listitem>
<para>データの項目をレンダリングしリストボックスのリスト項目へ表示するために<code>org.zkoss.zul.ListitemRenderer</code>インターフェースを実装します。</para>
</listitem>
<listitem>
<para>
<code>model</code>プロパティ中にデータを指定します。選択的に、<code>itemRenderer</code>プロパティにレンダ装置を指定します。</para>
</listitem>
</orderedlist>
<para>また、ステップ2は、以下の二項目に分かれています。</para>
<itemizedlist>
<listitem>
<para>これは指定するか選択できます、指定されていないなら、デフォルトのレンダー装置はデータを読み込み、最初の行へ入れます。</para>
</listitem>
<listitem>
<para>異なったビューの中では同じデータをあらわすのに、異なったレンダ装置を実装できます。</para>
</listitem>
</itemizedlist>
<para>
以下の例では<code>strset</code>と呼ばれるリストモデルを準備します<code>model</code>プロパティを通してそれをリストボックスに指定します。そのため、リストボックスは残りの作業を全部代わりに実行してくれます。</para>
<programlisting>&lt;window title="Livedata Demo" border="normal"&gt;&#13;<inlinegraphic fileref="img/1000000000000132000000E3AE1693E7.png" align="right"/>   &lt;zscript&gt;&#13;      String[] data = new String[30];&#13;      for(int j=0; j &amp;lt; data.length; ++j) {&#13;         data[j] = "option "+j;&#13;      }&#13;      ListModel strset = new SimpleListModel(data);&#13;   &lt;/zscript&gt;&#13;   &lt;listbox width="200px" rows="10" model="${strset}"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Load on demend"/&gt;&#13;      &lt;/listhead&gt;&#13;   &lt;/listbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<sect3><title>ライブデータを使用したソーティング</title>
<para>ライブデータが使用できるリストボックスをソート可能にするなら、<code>org.zkoss.zul.ListModel</code>に加えて、<code>org.zkoss.zul.ListModelExt</code>インターフェースを実装しなければなりません。</para>
<programlisting>class MyListModel implements ListModel, ListModelExt {&#13;          public void sort(Comparator cmpr, boolean ascending) {    &#13;                    //do the real sorting        &#13;                    //notify the listbox (or grid) that data is changed by use of ListDataEvent        &#13;          }    &#13;}&#13;</programlisting>
<para>ユーザーがリストボックスにソート要求するとき、リストボックスは<code>ListModelExt</code>の<code>sort</code>メソッドを呼び出し、データをソートします。リストボックスよりむしろ、リストモデルによってソーティングは行われます。</para>
<para>ソート後は、(<code>addListDataListener</code>メソッドにより) リストボックスに記憶された<code>org.zkoss.zul.event.ListDataListener</code>インスタンスの<code>onChange</code>メソッドを呼び出すことより、リストモデルはリストボックスに通知します。ほとんどの場合全データはたいてい変更され、リストモデルは以下のイベントを送信します。</para>
<programlisting>new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1)&#13;</programlisting>
<para>メモ：<code>ListModel</code>と<code>ListModelExt</code>の実装は視覚表現に依存しません。つまり、グリッド、リストボックス、<code>ListModel</code>をサポートしている他のコンポーネントと共にそれらは使用されます。</para>
<para>つまり、柔軟性を高めるにはコンポーネントを使用することは想定すべきではないです。むしろ、<code>ListDataEvent</code>を使用して通信します。</para></sect3></sect2><sect2><title>ボタンを含むリストボックス</title>
<para>理論ではリストセルは以下に示すように、他のどのコンポーネントも含むことができます。</para>
<programlisting>&lt;listbox width="250px"&gt;&#13;<inlinegraphic fileref="img/1000000000000101000000597E6A0365.png" align="right"/>   &lt;listhead&gt;&#13;      &lt;listheader label="Population"/&gt;&#13;      &lt;listheader label="Percentage"/&gt;&#13;   &lt;/listhead&gt;&#13;   &lt;listitem value="A"&gt;&#13;      &lt;listcell&gt;&lt;textbox value="A. Graduate"/&gt;&lt;/listcell&gt;&#13;      &lt;listcell label="20%"/&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="B"&gt;&#13;      &lt;listcell&gt;&lt;checkbox label="B. College"/&gt;&lt;/listcell&gt;&#13;      &lt;listcell&gt;&lt;button label="23%"/&gt;&lt;/listcell&gt;&#13;   &lt;/listitem&gt;&#13;   &lt;listitem value="C"&gt;&#13;      &lt;listcell label="C. High School"/&gt;&#13;      &lt;listcell&gt;&lt;textbox cols="8" value="40%"/&gt;&lt;/listcell&gt;&#13;   &lt;/listitem&gt;&#13;&lt;/listbox&gt;&#13;</programlisting>
<para>【メモ】:</para>
<orderedlist>
<listitem>
<para>グリッドがより適切の場合では、リストボックスの使用を避けましょう。リストボックスとグリッドの外見は似ていますが、リストボックスは選択できる項目をあらわすときのみに使用するべきです。</para>
</listitem>
<listitem>
<para>リストボックスが編集可能な<code>textbox</code>、<code>checkbox</code>といったコンポーネントを含んでいる場合、ユーザーは混乱します。たとえば選択されていない項目に入力されたテキストの意味がわからなくなります。</para>
</listitem>
<listitem>
<para>ブラウザの制限によって、ユーザーはテキストボックス中の文字列を選択できない場合があります。</para>
</listitem>
</orderedlist></sect2></sect1><sect1><title>ツリーコントロール</title>
<para>コンポーネント:<code> tree</code>, <code>treechildren</code>, <code>treeitem</code>,<code> treerow</code>, <code>treecell</code>, <code>treecols</code>, <code>treecol</code>.</para>
<para>ツリーは二つの部分からなります。行のセットそして、ツリー自身。行のセットは<code>treecol</code>コンポーネントの数字によって定義されます。行ごとに一つです。行ごとにツリーのトップにヘッダーが表示されます。二つ目の部分、ツリー自身、はツリー内に現れるデータを含み、<code>treechildren</code>コンポーネントによって作成されます。</para>
<para>ツリーコントロールの例は以下のようです。</para>
<programlisting>&lt;tree id="tree" rows="5"&gt;&#13;<inlinegraphic fileref="img/10000000000001E5000000727EE351E4.png" align="right"/>          &lt;treecols&gt;    &#13;                    &lt;treecol label="Name"/&gt;        &#13;                    &lt;treecol label="Description"/&gt;        &#13;          &lt;/treecols&gt;    &#13;          &lt;treechildren&gt;    &#13;                    &lt;treeitem&gt;        &#13;                              &lt;treerow&gt;            &#13;                                        &lt;treecell label="Item 1"/&gt;                &#13;                                        &lt;treecell label="Item 1 description"/&gt;                &#13;                              &lt;/treerow&gt;            &#13;                    &lt;/treeitem&gt;        &#13;                    &lt;treeitem&gt;        &#13;                              &lt;treerow&gt;            &#13;                                        &lt;treecell label="Item 2"/&gt;                &#13;                                        &lt;treecell label="Item 2 description"/&gt;                &#13;                              &lt;/treerow&gt;            &#13;                              &lt;treechildren&gt;            &#13;                                        &lt;treeitem&gt;                &#13;                                                  &lt;treerow&gt;                    &#13;                                                            &lt;treecell label="Item 2.1"/&gt;                        &#13;                                                  &lt;/treerow&gt;                    &#13;                                                  &lt;treechildren&gt;                    &#13;                                                            &lt;treeitem&gt;                        &#13;                                                                  &lt;treerow&gt;                            &#13;                                                  &lt;treecell label="Item 2.1.1"/&gt;&#13;                                                                  &lt;/treerow&gt;                            &#13;                                                            &lt;/treeitem&gt;                        &#13;                                                            &lt;treeitem&gt;                        &#13;                                                                  &lt;treerow&gt;                            &#13;                                                  &lt;treecell label="Item 2.1.2"/&gt;&#13;                                                                  &lt;/treerow&gt;                            &#13;                                                            &lt;/treeitem&gt;                        &#13;                                                  &lt;/treechildren&gt;                    &#13;                                        &lt;/treeitem&gt;                &#13;                                        &lt;treeitem&gt;                &#13;                                                  &lt;treerow&gt;                    &#13;                                                            &lt;treecell label="Item 2.2"/&gt;                        &#13;                                    &lt;treecell label="Item 2.2 is something who cares"/&gt;&#13;                                                  &lt;/treerow&gt;                    &#13;                                        &lt;/treeitem&gt;                &#13;                              &lt;/treechildren&gt;            &#13;                    &lt;/treeitem&gt;        &#13;                    &lt;treeitem label="Item 3"/&gt;        &#13;          &lt;/treechildren&gt;    &#13;&lt;/tree&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>tree</code>: これはツリーコントロールの外側のコンポーネントです。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treecols</code>:このコンポーネントは<code>treecol</code>コンポーネントのプレースホルダーです。 </para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treecol</code>:これはツリーの行を宣言します。この行を使用することで、行ヘッダーのような追加情報を指定できます。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>treechildren</code>: これは<code>treeitem</code>コンポーネントの集合を持つツリーの本体をもっています。</para>
</listitem>
<listitem>
<para>
<code>treeitem</code>:このコンポーネントは列データ(<code>treerow</code>) を持っていて、また オプションで<code>treechildren</code>を持っています。</para>
<orderedlist>
<listitem>
<para>コンポーネントが<code>treechildren</code>を持っていない場合、それはリーフノードで子項目を受け取ることはありません。</para>
</listitem>
<listitem>
<para>
<code>t</code>
<code>reechildren</code>を含んでいる場合、それは他の項目を持っているブランチノードかもれしれません。</para>
</listitem>
<listitem>
<para>ブランチノードには、列の初めに+/-ボタンが表示されます。そのため、ユーザーが+/-ボタンをクリックすることで項目を開閉できます。</para>
</listitem>
</orderedlist>
</listitem>
<listitem>
<para>
<code>treerow</code>: <code>treeitem</code>コンポーネントの中に単独の列がおかれます。</para>
</listitem>
<listitem>
<para>
<code>treecell</code>:ツリー列の中にある一つのセルこの要素は<code>treerow</code>コンポーネントの中に入ります。 </para>
</listitem>
</itemizedlist>
<para>マウスを使わずに入力： <code>tree</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>UP</code>と<code>DOWN</code>はツリー項目の選択を上下へ移動させます。</para>
</listitem>
<listitem>
<para>
<code>PgUp</code>と<code>PgDn</code>は選択を一ページ分上下させます。</para>
</listitem>
<listitem>
<para>
<code>HOME</code>は選択を初めの項目に移動させます。<code>END</code>は逆に最後の項目に移動させます。</para>
</listitem>
<listitem>
<para>
<code>RIGHT</code>はツリー項目を開きますそして、<code>LEFT</code>はツリー項目を閉じます。</para>
</listitem>
<listitem>
<para>
<code>Ctrl+UP</code>と<code>Ctrl+DOWN</code>は選択を変えることなくフォーカスを上下に移動させます。</para>
</listitem>
<listitem>
<para>
<code>SPACE</code>はフォーカス項目を選択します。</para>
</listitem>
</itemizedlist><sect2><title>
<code>Open</code>プロパティと<code>onOpen</code>イベント</title>
<para>どのツリー項目も子項目を表示するかどうかを決める<code>open</code>プロパティを所持しています。デフォルト値は<code>true</code>です。このプロパティを<code>false</code>に設定して、ツリーを部分的に見えなくさせることができます。</para>
<programlisting>&lt;treeitem open="false"&gt;&#13;</programlisting>
<para>ユーザーが+/-ボタンをクリックしたとき、ツリーを開き、子要素を表示します。<code>onOpen</code>イベントはそれからサーバーに送信されてアプリケーションに通知します。</para>
<para>複雑なアプリケーションには、動的なコンテンツの処理又はツリー項目コンテンツの作成を延期できます。ZKユーザーインターフェースマークアップ言語の章のロードオンデマンドセクションを参照してください。</para></sect2><sect2><title>複数選択</title>
<para>ユーザーがツリー項目をクリックするとき、すべての項目が選択され<code>onSelect</code>イベントがサーバーに返信され、アプリケーションに通知します。<code>m</code>
<code>ultiple</code>プロパティを<code>t</code>
<code>rue</code>に設定することで、ツリーコントロールで複数選択可能かどうか決定できます。デフォルト値は<code>false</code>です。</para></sect2><sect2><title>
ページング</title>
<para>
<code>pageSize</code>プロパティはすぐにツリー項目数を操作します。デフォルトでは、10です。つまり、右の図で示すようにどの階層に対しても、<inlinegraphic align="right" fileref="img/100000000000008A000001112B40E516.png"/>最大で10個のツリー項目がクライアントで表示されます。</para>
<para>ユーザーは<inlinegraphic fileref="img/10000000000000130000000FE7D92F3A.png"/>をクリックしてより多くのツリー項目を見ます。(つまり、<code>pageSize</code>を拡大します。)又は、<inlinegraphic fileref="img/10000000000000110000000F1F00F397.png"/>か<inlinegraphic fileref="img/10000000000000110000000F4116A8F6.png"/>をクリックすることで上下にスクロールします。 </para>
<para>すべてのツリー項目を表示させる場合は、単純に<code>pageSize</code>を-1に設定してください。しかしながら、ツリーコントロールが多すぎる場合は、お勧めしません。ブラウザがあまりに遅すぎて巨大な項目数を処理できません。</para>
<para>ツリーコントロールの<code>pageSize</code>プロパティに加えて、<code>treechildren</code>インスタンス中の<code>pageSize</code> プロパティの値を大きくすることで、<code>treechildren</code>インスタンスごとのページサイズを変えることができます。</para><sect3><title>
<code>onPaging</code>と<code>onPageSize</code>イベント</title>
<para>ユーザーが<inlinegraphic fileref="img/10000000000000110000000F1F00F397.png"/>か<inlinegraphic fileref="img/10000000000000110000000F4116A8F6.png"/>をクリックして上下にページをスクロールした時、<code>onPaging</code>イベントは<code>org.zkoss.zul.event.PagingEvent</code>インスタンスと共に送信されます。同様にして、ユーザーが<inlinegraphic fileref="img/10000000000000130000000FE7D92F3A.png"/>をクリックした時、<code>onPageSize</code>イベントは<code>org.zkoss.zul.event.PageSize</code>インスタンスと共に送信されます。</para></sect3></sect2><sect2><title>特別なプロパティ</title><sect3><title>
<code>rows</code>プロパティ</title>
<para>
<code>rows</code>プロパティは参照可能な<code>rows</code>の数を決定します。それをゼロに設定することで、ツリーコントロールはそれ自身のサイズを変更して可能なかぎりの項目を表示します。</para></sect3><sect3><title>
<code>checkmark</code>プロパティ</title>
<para>
<code>Checkmark</code>プロパティはツリー項目の前のcheckboxかraidoボタンを表示するかどうかを決定します。</para>
<para>
<graphic align="center" fileref="img/10000000000001980000007BBA791396.png">2
			
		</graphic>
</para></sect3><sect3><title>
<code>vflex</code>プロパティ</title>
<para>
<code>v</code>
<code>flex</code>プロパティは与えられたスペースに合うように縦に伸び縮みするかどうかを決定します。いわゆる、縦の柔軟性です。例えば、ツリーが大きすぎてブラウザウィンドウに合わない場合、ブラウザウィンドウですべてのツリーが見えるように高さを縮めて表示します。</para>
<para>
<code>rows</code>プロパティが指定されているなら、プロパティは無視されます。</para></sect3><sect3><title>
<code>maxlength</code>プロパティ</title>
<para>
<code>maxlength</code>プロパティはブラウザで表示できる文字列を定義します。このプロパティを設定することで、幅が狭いツリーコントロールを作成することができます。</para></sect3><sect3><title>サイズ変更可能な行</title>
<para>行のように、<code>treecols</code>の<code>sizable</code>プロパティを<code>true</code>に設定することで、ユーザーがツリーヘッダーの幅を変更できます。同様にして、ユーザーが幅を変更したとき、<code>onColSize</code>イベントが送信されます。</para></sect3></sect2><sect2><title>ツリーコントロールへのCreate-on-Open</title>
<para>下に説明したように、<code>onOpen</code>イベントを監視することができます。ツリー項目の子項目を読み込みます。同様にして、グループボックスに対して、creat-on-openができます。</para>
<programlisting>&lt;tree width="200px"&gt;&#13;          &lt;treecols&gt;    &#13;                    &lt;treecol label="Subject"/&gt;        &#13;                    &lt;treecol label="From"/&gt;        &#13;          &lt;/treecols&gt;    &#13;          &lt;treechildren&gt;    &#13;                    &lt;treeitem open="false" onOpen="load()"&gt;        &#13;                              &lt;treerow&gt;            &#13;                                        &lt;treecell label="Intel Snares XML"/&gt;                &#13;                                        &lt;treecell label="David Needle"/&gt;                &#13;                              &lt;/treerow&gt;            &#13;                              &lt;treechildren/&gt;            &#13;                    &lt;/treeitem&gt;        &#13;          &lt;/treechildren&gt;    &#13;          &lt;zscript&gt;    &#13;          void load() {    &#13;                    Treechildren tc = self.getTreechildren();        &#13;                    if (tc.getChildren().isEmpty()) {        &#13;                              Treeitem ti = new Treeitem();            &#13;                              ti.setLabel("New added");            &#13;                              ti.setParent(tc);            &#13;                    }        &#13;          }    &#13;          &lt;/zscript&gt;    &#13;&lt;/tree&gt;&#13;</programlisting></sect2></sect1><sect1><title>コンボボックス</title>
<para>コンポーネント: <code>combobox</code>, <code>comboitem</code>
</para>
<para>コンボボックスは特別なテキストボックスでドロップダウンリストを埋め込むことができます。コンボボックスを使うと、手動でテキスト入力できることに加えて、ユーザーはドロップダウンリストから選択できるようになります。</para>
<programlisting>&lt;combobox&gt;<inlinegraphic fileref="img/10000000000000B50000004419304D81.png" align="right"/>&#13;          &lt;comboitem label="Simple and Rich"/&gt;    &#13;          &lt;comboitem label="Cool!"/&gt;    &#13;          &lt;comboitem label="Ajax and RIA"/&gt;    &#13;&lt;/combobox&gt;&#13;</programlisting>
<para>マウスなしの入力：<code>combobox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>Alt+DOWN</code>：リストをポップアップします。</para>
</listitem>
<listitem>
<para>
<code>Alt+UP</code> か<code> ESC</code> ：リストを閉じます。</para>
</listitem>
<listitem>
<para>
<code>UP</code> と <code>DOWN</code> ：リスト中で選択している項目を変更します。</para>
</listitem>
</itemizedlist><sect2><title>
<code>autodrop</code>プロパティ</title>
<para>デフォルトでは、ユーザーが<inlinegraphic fileref="img/100000000000000F00000015A76D2BBC.png"/>をクリックするまたは<code>Alt+DOWN</code>をクリックするまで、ドロップダウンリストは開かれません。しかし、<code>autodrop</code>プロパティを<code>true</code>に設定でき、そのため、ユーザーが文字列をタイプするとすぐに、ドロップダウンリストが開かれます。これは初心者ユーザーには役立ちますが、経験者とってはじゃまになるかもしれません。</para>
<programlisting>&lt;combobox autodrop="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>description</code>プロパティ</title>
<para>コンボに説明を加え、わかりやすくすることができます。さらに、コンボ項目にイメージを指定することもできます。</para>
<programlisting>&lt;combobox&gt;&#13;          &lt;comboitem label="Simple and Rich" image="/img/coffee.gif"    &#13;          description="The simplest way to make Web applications rich"/&gt;    &#13;          &lt;comboitem label="Cool!" image="/img/corner.gif"    &#13;          description="The coolest technology"/&gt;    &#13;          &lt;comboitem label="Ajax and RIA" image="/img/cubfirs.gif"    &#13;          description="Rich Internet Application by Ajax"/&gt;    &#13;&lt;/combobox&gt;&#13;</programlisting>
<para>コンボボックスは他のコンポーネントのようにイメージをサポートし、<code>setImageContent</code>メソッドを見て動的に生成されたイメージのコンテンツを<code>comboitem</code>コンポーネントに指定できます。より詳しくはImageセクションを参照してください。<graphic align="center" fileref="img/10000000000001210000007CA44D783C.png">2
</graphic></para></sect2><sect2><title>
<code>onOpen</code>イベント</title>
<para>ユーザーがドロップダウンリストを開くとき、<code>onOpen</code>イベントはアプリケーションに送られます。コンボ項目作成を遅らせるために、<code>fulfill</code>属性を以下のように使うことができます。</para>
<programlisting>&lt;combobox fulfill="onOpen"&gt;<inlinegraphic fileref="img/10000000000000B50000004419304D81.png" align="right"/>&#13;          &lt;comboitem label="Simple and Rich"/&gt;    &#13;          &lt;comboitem label="Cool!"/&gt;    &#13;          &lt;comboitem label="Ajax and RIA"/&gt;    &#13;&lt;/combobox&gt;&#13;</programlisting>
<para>代わりに、<code>onOpen</code>イベントを監視することができ、そのため、ドロップダウンリストを準備して、以下に示したように、リスナ中で動的に変更することができます。 </para>
<programlisting>&lt;combobox id="combo" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&#13;          void prepare() {    &#13;                    if (event.isOpen() &amp;amp;&amp;amp; combo.getItemCount() == 0) {        &#13;                              combo.appendItem("Simple and Rich");            &#13;                              combo.appendItem("Cool!");            &#13;                              combo.appendItem("Ajax and RIA");            &#13;                    }        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>
<code>appendItem</code>メソッドはコンボ項目を作成し、親要素をコンボボックスに指定するのと同等の働きがあります。</para></sect2><sect2><title>
<code>onChanging</code>イベント</title>
<para>コンボボックスはまたテキストボックスであるので、リスナを加える場合、<code>onChanging</code>イベントは送信されます。このイベントを監視することで、Google Suggests<footnote>
<para>http://www.google.com/webhp?complete=1&amp;hl=en</para>
</footnote>がしているように、ドロップダウンリストを処理します。この機能はオートコンプリートと呼ばれます。</para>
<para>以下に説明したように、ユーザーが入力しているものに基づいて、ドロップダウンリストを埋めることができます。</para>
<programlisting>&lt;combobox id="combo" autodrop="true" onChanging="suggest()"/&gt;&#13;&lt;zscript&gt;&#13;          void suggest() {    &#13;                    combo.getItems().clear();        &#13;                    if (event.value.startsWith("A")) {        &#13;                              combo.appendItem("Ace");            &#13;                              combo.appendItem("Ajax");            &#13;                              combo.appendItem("Apple");            &#13;                    } else if (event.value.startsWith("B")) {        &#13;                              combo.appendItem("Best");            &#13;                              combo.appendItem("Blog");            &#13;                    }        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para/>
<para>
<code>onChanging</code>イベントが受信されたとき、コンボボックスのコンテンツはまだ変更されていません。このため、コンボボックスの<code>value</code>プロパティを使用できません。それよりも、イベント(<code>org.zkoss.zk.ui.event.InputEvent</code>)の<code>value</code>プロパティを使うべきです。 </para></sect2></sect1><sect1><title>バンドボックス</title>
<para>コンポーネント: <code>bandbox</code>, <code>bandpopup</code>.</para>
<para>バンドボックスは特別なテキストボックスで、カスタマイズ可能なポップアップウィンドウが内蔵されています(aka.,a dropdown window)。コンボボックスのように、バンドボックスは入力ボックスとポップアップウィンドウから構成されています。ユーザーが<code>Alt+DOWN</code>を押すか、<inlinegraphic fileref="img/10000000000000150000001699487861.png"/>ボタンをクリックすると、ポップアップウィンドウが自動的に開きます。</para>
<para>コンボボックスとは違って、バンドボックスのポップアップウィンドウはなんにでもなれます。それは開発者を柔軟にしています。代表的な使い方はサーチダイアログとして、ポップアップウィンドウを表示しています。</para>
<programlisting>&lt;bandbox id="bd"&gt;&#13;      &lt;bandpopup&gt;&lt;vbox&gt;&#13;      &lt;hbox&gt;Search &lt;textbox/&gt;&lt;/hbox&gt;&#13;      &lt;listbox width="200px"      onSelect="bd.value=self.selectedItem.label; bd.closeDropdown();"&gt;&#13;         &lt;listhead&gt;&#13;            &lt;listheader label="Name"/&gt;&#13;<inlinegraphic fileref="img/10000000000000E80000008E1E66A663.png" align="right"/>            &lt;listheader label="Description"/&gt;&#13;         &lt;/listhead&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="John"/&gt;&#13;            &lt;listcell label="CEO"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Joe"/&gt;&#13;            &lt;listcell label="Engineer"/&gt;&#13;         &lt;/listitem&gt;&#13;         &lt;listitem&gt;&#13;            &lt;listcell label="Mary"/&gt;&#13;            &lt;listcell label="Supervisor"/&gt;&#13;         &lt;/listitem&gt;&#13;      &lt;/listbox&gt;&lt;/vbox&gt;&#13;      &lt;/bandpopup&gt;&#13;   &lt;/bandbox&gt;&#13;</programlisting>
<para>マウスなしの入力：<code>bandbox</code>
</para>
<itemizedlist>
<listitem>
<para>
<code>Alt+DOWN</code> :リストをポップアップします。</para>
</listitem>
<listitem>
<para>
<code>Alt+UP</code> か<code>ESC</code>:リストを閉じます。</para>
</listitem>
<listitem>
<para>
<code>UP</code> と<code>DOWN</code>:リストから項目選択を変更する。</para>
</listitem>
</itemizedlist><sect2><title>
<code>closeDropdown</code>メソッド</title>
<para>ポップアップウィンドウはいろいろなコンポーネントを含んでいます。ここで開発者の責任は、項目の一つが選択されたら、その値をコピーして、ポップアップを閉じます。</para>
<para>上の例中で選択した項目ラベルをバンドボックスにコピーし、以下のステートメントによってポップアップを閉じます。</para>
<programlisting>&lt;listbox width="200px"     onSelect="bd.value=self.selectedItem.label; bd.closeDropdown();"&gt;&#13;</programlisting></sect2><sect2><title>
<code>autodrop</code>プロパティ</title>
<para>デフォルトでは、 <inlinegraphic fileref="img/10000000000000150000001699487861.png"/>ボタンをクリックする、または、<code>Alt＋Down</code>を押すまで、ポップアップウィンドウは開かれません。しかし、<code>autodrop</code>プロパティに<code>t</code>
<code>rue</code>を指定すると、ポップアップはユーザーが文字列をタイプするとすぐに開かれます。これは初心者のユーザーにはとても役立ちますが、経験者にはじゃまなだけかもしれません。</para>
<programlisting>&lt;bandbox autodrop="true"/&gt;&#13;</programlisting></sect2><sect2><title>
<code>onOpen</code>イベント</title>
<para>ユーザーがポップアップウィンドウを開くと、<code>onOpen</code>イベントはアプリケーションに送信されます。以下に示すように<code>onOpen</code>値を伴う<code>fullfill</code>属性を使うことで、ポップアップウィンドウ作成を遅らせることができます。</para>
<programlisting>&lt;bandbox fulfill="onOpen"&gt;&#13;          &lt;bandpopup&gt;    &#13;          ...    &#13;          &lt;/bandpopup&gt;    &#13;&lt;/bandbox&gt;&#13;</programlisting>
<para>代わりに、以下に示すように、<code>onOpen</code>イベントを監視することで、Javaでポップアップウィンドウを作成できます。 </para>
<programlisting>&lt;bandbox id="band" onOpen="prepare()"/&gt;&#13;&lt;zscript&gt;&#13;          void prepare() {    &#13;                    if (event.isOpen() &amp;amp;&amp;amp; band.getPopup() == null) {        &#13;                              ...//create child elements            &#13;                    }        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting></sect2><sect2><title>
<code>onChanging</code>イベント</title>
<para>バンドボックスはテキストボックスであるので、リスナを追加する場合、<code>onChanging</code>イベントが送信されます。このイベントを監視することで、お好みの方法でポップアップウィンドウを処理できます。</para>
<para>以下に説明するように、ユーザーが入力しているものに基づいて、ドロップダウンリストに書き込みます。</para>
<programlisting>&lt;bandbox id="band" autodrop="true" onChanging="suggest()"/&gt;&#13;&lt;zscript&gt;&#13;          void suggest() {    &#13;                    if (event.value.startsWith("A")) {        &#13;                              ...//do something            &#13;                    } else if (event.value.startsWith("B")) {        &#13;                              ...//do another            &#13;                    }        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>
<code>onChanging</code>イベントを受け取ったとき、バンドボックスのコンテンツはまだ変更されていません。このため、バンドボックスの<code>value</code>プロパティを使うことはできません。代わりに、(<code>org.zkoss.zk.ui.event.InputEvent</code>)の<code>value</code>プロパティを使います。</para></sect2></sect1><sect1><title>チャート</title>
<para>コンポーネント: <code>chart</code>
</para>
<para>チャートはグラフのようにデータセットを表示します。</para>
<para>
<code>c</code>
<code>hart</code>コンポーネントの使用は直観的です。適切なデータモデルを準備してチャートに読み込ませます。以下はpieチャートの例です。</para>
<para/>
<programlisting>&lt;chart id="mychart" type="pie" width="400" height="200" threeD="true" fgAlpha="128"&gt;&#13;    &lt;zscript&gt;&lt;![CDATA[&#13;      PieModel model = new SimplePieModel();&#13;      model.setValue("C/C++", new Double(17.5));&#13;      model.setValue("PHP", new Double(32.5));<inlinegraphic fileref="img/10000000000001370000005ED5356D68.png" align="right"/>&#13;      model.setValue("Java", new Double(43.2));&#13;      model.setValue("VB", new Double(10.0));&#13;      mychart.setModel(model);&#13;    ]]&gt;&lt;/zscript&gt;&#13;&lt;/chart&gt;&#13;</programlisting>
<para>異なった種類のチャートは異なった種類のデータを表すので、チャートは適当なデータモデルが提供されなければなりません。pieチャートでは開発者はデータとして、PieModelを提供しなければなりません。一方で、バーチャート、ラインチャート、エリアチャートとウォータフォールチャートはCategoryModelとXYModelが必要です。</para><sect2><title>ライブデータ</title>
<para>上の例ではもしかしたら、勘違いするかもしれません。chartコンポーネントはライブデータのメカニズムをサポートしているので、実際は開発者がチャートに読み込む前に本物のデータを準備する必要はありません。ライブデータを使って、開発者はビューからデータを区別します。つまり、開発者はデータモデルから、追加、変更、削除をすることができます。chartはそれにしたがって再描画されます。アドバンス実装では、<code>org.zkoss.zul.ChartModel</code>インターフェースを実装することで、開発者がそれら自身のチャートモデルを提供することさえできます。 </para></sect2><sect2><title>ドリルダウン(<code>onClick</code>イベント)</title>
<para>ユーザーがチャートを見て、何か面白いものを発見したとき、ユーザーはその面白いところに関する詳細な情報を見たいでしょう。それはパイチャート中ではパイ、バーチャートではバー、ラインチャートではポイントです。チャートコンポーネントはドリルダウンファシリティをサポートしていて、<code>chart</code>を<code>area</code>コンポーネントに切り分けます。そして、ユーザーが<code>chart</code>をクリックして、<code>onClickMouse</code>イベントを開始します。開発者は<code>area</code>コンポーネントを配置して、適切なドリルダウンをします。</para>
<para>コンポーネントの<code>componentScope</code>エリア中でいくつかの便利な情報があり、開発者はそれらを使うことができます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>名前</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>entity</para>
</entry>
<entry>
<para>エリアの種類(例:TITLE、DATA、CATEGORY、LEGEND)</para>
</entry>
</row>
<row>
<entry>
<para>series</para>
</entry>
<entry>
<para>関連データのシリーズ名(CategoryModel,XYModel,HiLoModel) </para>
</entry>
</row>
<row>
<entry>
<para>category</para>
</entry>
<entry>
<para>関連データのカテゴリー名(PieModelかCategoryModel)</para>
</entry>
</row>
<row>
<entry>
<para>url</para>
</entry>
<entry>
<para>レガシーページにドリルダウンする文字列中のurl</para>
</entry>
</row>
<row>
<entry>
<para>value</para>
</entry>
<entry>
<para>関連データの数値(PieModel又はCategoryModel)</para>
</entry>
</row>
<row>
<entry>
<para>x</para>
</entry>
<entry>
<para>関連データのX値(XYModel)</para>
</entry>
</row>
<row>
<entry>
<para>y</para>
</entry>
<entry>
<para>関連データのY値(XYModel)</para>
</entry>
</row>
<row>
<entry>
<para>date</para>
</entry>
<entry>
<para>関連データのデータ値(HiLoModel)</para>
</entry>
</row>
<row>
<entry>
<para>open</para>
</entry>
<entry>
<para>関連データの公開データ(HiLoModel)</para>
</entry>
</row>
<row>
<entry>
<para>high</para>
</entry>
<entry>
<para>関連データの高い値(HiLoModel)</para>
</entry>
</row>
<row>
<entry>
<para>low</para>
</entry>
<entry>
<para>関連データの低い値(HiLoModel)</para>
</entry>
</row>
<row>
<entry>
<para>close</para>
</entry>
<entry>
<para>関連データの閉じた値(HiLoModel)</para>
</entry>
</row>
<row>
<entry>
<para>volume</para>
</entry>
<entry>
<para>関連データの容積値(HiLoModel)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>以下の例中で、チャート上で<code>onClick</code>イベントリスナを提供します。関連した<code>area</code>コンポーネントを配置し、<code>area</code>のカテゴリ(つまり、<code>pie</code>パイ) を表示します。</para>
<programlisting>&lt;chart id="mychart" type="pie" width="400" height="250"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;            alert(self.getFellow(event.getArea()).getAttribute("category"));&#13;      &lt;/attribute&gt;&#13;      &lt;zscript&gt;&lt;![CDATA[&#13;            PieModel model = new PieModel();&#13;            model.setValue("C/C++", new Double(17.5));&#13;            model.setValue("PHP", new Double(32.5));&#13;            model.setValue("Java", new Double(43.2));&#13;            model.setValue("VB", new Double(10.0));&#13;            mychart.setModel(model);&#13;      ]]&gt;&lt;/zscript&gt;&#13;&lt;/chart&gt;&#13;</programlisting></sect2><sect2><title>エリア処理</title>
<para>チャートコンポーネントはエリアレンダ装置メカニズムを提供します。開発者はそれらによって<code>chart</code>の分けられた<code>area</code>コンポーネントを処理できます。 </para>
<para>エリアレンダ装置を使用するのに必要な二つのステップは：</para>
<orderedlist>
<listitem>
<para>エリアコンポーネントを処理するのに、<code>org.zkoss.zul.event.ChartAreaListener</code>インターフェースを実装します。例えば、エリアの<code>tooltiptext</code>を変更します。</para>
</listitem>
<listitem>
<para>リスナオブジェクト又はリスナクラス名を<code>chart’s areListener</code>プロパティに設定します。</para>
</listitem>
</orderedlist>
<para>つまり、開発者は機会を得て、<code>area</code>コンポーネントのプロパティを変更し、又はより多くの情報を<code>area</code>コンポーネントの<code>componentScope</code>プロパティに挿入します。そして、<code>onClick</code>イベントリスナに渡します。</para></sect2></sect1><sect1><title>ドラッグ＆ドロップ</title>
<para>ZKはユーザーにユーザーインターフェース中で特定のコンポーネントをドラッグできるようにします。例えば、ファイルを他のディレクトリへドラッグしたり、購入するためにショッピングカートへ商品をドラッグしたりします。 </para>
<para>ドラッグできたら、コンポーネントはドラッグ可能です。ユーザーがドラッグ可能のコンポーネントをあるコンポーネントにドロップしたら、そのコンポーネントはドロップ可能です。</para>
<para>【メモ】: ZKはドロップ後に行われることについては特に処理していません。<code>onDrop</code>イベントリスナを書けるアプリケーション開発者しだいです。アプリケーションがなにもしないなら、ドラッグされたコンポーネントはもとあったところに戻ります。</para><sect2><title>
<code>draggable</code>と<code>droppable</code>プロパティ</title>
<para>ZKを使用して、<code>false</code>以外の値を<code>draggable</code>プロパティに指定することで、コンポーネントをドラッグ可能にできます。使用不可するには<code>false</code>を指定してください。</para>
<programlisting>&lt;image draggable="true"/&gt;&#13;</programlisting>
<para>同様にして、コンポーネントを<code>droppable</code>プロパティに<code>true</code>を指定することでドロップ可能にできます。</para>
<programlisting>&lt;hbox droppable="true"/&gt;&#13;</programlisting>
<para>そのため、ユーザーはドラッグ可能コンポーネントをドラッグできます。そして、ドロップ可能コンポーネントにドロップします。</para></sect2><sect2><title>
<code>onDrop</code>イベント</title>
<para>ユーザーがコンポーネントをドラッグし、他のコンポーネントにドロップすると、ドロップされたコンポーネントは<code>onDrop</code>イベントによって通知されます。<code>onDrop</code>イベントは<code>org.zkoss.ui.event.DropEvent</code>のインスタンスです。<code>getDragged</code>メソッドを呼び出すことより、何がドラッグ(ドロップ) されたかを取得します。</para>
<para>
<code>onDrop</code>イベントの目標はドロップ可能なコンポーネントで、ドラッグされているコンポーネントではありません。</para>
<para>以下は、ユーザーにドラッグアンドドロップによるリスト再配列を可能にしている単純な例です。</para>
<para>
<graphic align="center" fileref="img/1000000000000213000000B4ADEE091E.png">2
			
		</graphic>
</para>
<programlisting>&lt;window title="Reorder by Drag-and-Drop" border="normal"&gt;&#13;   Unique Visitors of ZK:   &lt;listbox id="src" multiple="true" width="300px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Country/Area"/&gt;&#13;         &lt;listheader align="right" label="Visits"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="United States"/&gt;&#13;         &lt;listcell label="5,093"/&gt;&#13;         &lt;listcell label="19.39%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="China"/&gt;&#13;         &lt;listcell label="4,274"/&gt;&#13;         &lt;listcell label="16.27%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="France"/&gt;&#13;         &lt;listcell label="1,892"/&gt;&#13;         &lt;listcell label="7.20%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="Germany"/&gt;&#13;         &lt;listcell label="1,846"/&gt;&#13;         &lt;listcell label="7.03%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem draggable="true" droppable="true" onDrop="move(event.dragged)"&gt;&#13;         &lt;listcell label="(other)"/&gt;&#13;         &lt;listcell label="13,162"/&gt;&#13;         &lt;listcell label="50.01%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listfoot&gt;&#13;         &lt;listfooter label="Total 132"/&gt;&#13;         &lt;listfooter label="26,267"/&gt;&#13;         &lt;listfooter label="100.00%"/&gt;&#13;      &lt;/listfoot&gt;&#13;   &lt;/listbox&gt;&#13;   &lt;zscript&gt;&#13;   void move(Component dragged) {&#13;      self.parent.insertBefore(dragged, self);&#13;   &#13;}&#13;   &lt;/zscript&gt;&#13;&lt;/window&gt;&#13;</programlisting>
</sect2><sect2><title>複数選択のドラッグ</title>
<para>ユーザーがリスト項目又はツリー項目をドラッグアンドドロップするとき、これら項目の選択ステータスは変更されません。視覚的にドラッグされた項目だけが移動されていますが、以下に示したように、すべて選択されている項目を一斉に操作することができます。</para>
<programlisting>public void onDrop(DropEvent evt) {&#13;          Set selected = ((Listitem)evt.getDragged()).getListbox().getSelectedItems();    &#13;          //then, you can handle the whole set at once    &#13;}&#13;</programlisting>
<para>ドラッグされた項目は選択されていないかもしれません。このため、以下に示したように、このケースに対してドラッグされた項目に選択を変更することができます。</para>
<programlisting>Listitem li = (Listitem)evt.getDragged();&#13;if (li.isSelected()) {&#13;          Set selected = ((Listitem)evt.getDragged()).getListbox().getSelectedItems();    &#13;          //then, you can handle the whole set at once    &#13;} else {&#13;          li.setSelected(true);    &#13;          //handle li only    &#13;}&#13;</programlisting></sect2><sect2><title>多種のドラッグ可能なコンポーネント</title>
<para>ドロップ可能なコンポーネントはすべてのドラッグ可能なコンポーネントを受け取らないことは一般的です。例えば、メールフォルダはメールだけ受け取り、他を拒否します。<code>onDrop</code>が呼び出されたとき、受信できないコンポーネントを無視するか、メッセージをアラートすることができます。</para>
<para>より良い視覚効果を表現するために、識別子を伴うドラッグ可能なコンポーネントのタイプを識別します。そのため、ドラッグ可能なプロパティに識別子を指定します。</para>
<programlisting>&lt;listitem draggable="email"/&gt;&#13;...&#13;&lt;listitem draggable="contact"/&gt;&#13;</programlisting>
<para>そして、識別子のリストをドロップ可能なものを設定するため、プロパティに値を指定できます。例えば、以下のイメージでは<code>email</code>と<code>contact</code>だけを受信します。</para>
<programlisting>&lt;image src="/img/send.png" droppable="email, contact" onDrop="send(event.dragged)"/&gt;&#13;</programlisting>
<para>ドラッグ可能なコンポーネントを受信するのに、<code>droppable</code>プロパティに<code>t</code>
<code>rue</code>を指定します。例えば、以下のイメージはドラッグ可能なコンポーネントを受信します。</para>
<programlisting>&lt;image src="/img/trash.png" droppable="true" onDrop="remove(event.dragged)"/&gt;&#13;</programlisting>
<para>一方で、<code>draggable</code>プロパティが<code>true</code>なら、コンポーネントは不明(anonymous)コンポーネントに属します。さらに、<code>droppable</code>プロパティが<code>true</code>に指定されたコンポーネントだけがそれを受信できます。</para></sect2></sect1><sect1><title>HTML関連コンポーネント</title>
<para>一つのZUMLページの中で、XULコンポーネントとHTMLコンポーネントを同時に使用する方法がいくつかあります。</para><sect2><title>
<code>html</code>コンポーネント</title>
<para>最も簡単な方法は<code>html</code>
<footnote>
<para>
<code>html </code>要素に挟まれるテキストは<code>html</code> コンポーネントの <code>content</code> プロパティに指定されます。</para>
</footnote>と呼ばれるXULコンポーネントを使います。<code>html</code>はブラウザに直接送るHTMLタグなら何でも埋め込むことができます。ZKにてHTMLタグをインタープリットしないようにするため、<code>&lt;![CDATA[</code> と <code>]]&gt;</code>で閉じます。つまり、子コンポーネントではなく、<code>c</code>
<code>ontent</code>プロパティ<footnote>
<para>ZKユーザーインターフェースマークアップ言語 章のXML セクションをご覧ください。</para>
</footnote>の中に保存されます。その中ではEL表記を使用することができます。</para>
<programlisting>&lt;window title="Html Demo"&gt;&#13;          &lt;html&gt;&lt;![CDATA[    &#13;                    &lt;h4&gt;Hi ${parent.title}&lt;/h4&gt;        &#13;                    &lt;p&gt;It is the content of the html component. &lt;/p&gt;        &#13;          ]]&gt;&lt;/html&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>html</code>コンポーネントはHTML <code>SPAN</code> タグを生成して、コンテンツを閉じます。このため、他のXULコンポーネントのように処理できます。例えば、CSSスタイルを指定でき、コンテンツを動的に変更できます。</para>
<programlisting>&lt;html id="h" style="border: 1px solid blue;background: yellow"&gt;&lt;![CDATA[&#13;          &lt;ul&gt;    &#13;                    &lt;li&gt;Native browser content&lt;/li&gt;        &#13;          &lt;/ul&gt;    &#13;]]&gt;&lt;/html&gt;&#13;&lt;button label="change" onClick="l.setContent(&amp;quot;Hi Update&amp;quot;)"/&gt;&#13;</programlisting>
<para>
<code>SPAN</code>は埋め込まれたHTMLタグを閉じるために使われます。以下のステートメントは正しくないです。</para>
<programlisting>&lt;html&gt;&lt;![CDATA[&#13;          &lt;ul&gt;    &#13;                    &lt;li&gt; &lt;!-- incomplete since &lt;ul&gt;&lt;li&gt; is inside &lt;span&gt; --&gt;        &#13;]]&gt;&lt;/html&gt;&#13;&#13;&lt;textbox/&gt;&#13;&#13;&lt;html&gt;&lt;![CDATA[&#13;                    &lt;/li&gt;        &#13;          &lt;/ul&gt;    &#13;]]&lt;/html&gt;&#13;</programlisting>
<para>
<code>SPAN</code>を使って閉じることなく埋め込まれたHTMLタグを生成するのが必要なら、<code>inline</code>コンポーネントを以下のように使用します。</para></sect2><sect2><title>
<code>inline</code>コンポーネント</title>
<para>
<code>html</code>コンポーネントのように、<code>inline</code>はクライアントに送信したいHTMLタグなら何でも、埋め込みます。しかしながら、<code>inline</code>は<code>SPAN</code>または他のタグを使用して閉じません。このため、HTMLタグを混在に使用するのは柔軟です。例えば、</para>
<programlisting>&lt;inline&gt;&lt;![CDATA[&#13;          &lt;ul&gt;    &#13;                    &lt;li&gt; &lt;!-- incomplete since &lt;ul&gt;&lt;li&gt; is inside &lt;span&gt; --&gt;        &#13;]]&gt;&lt;/inline&gt;&#13;&#13;&lt;textbox/&gt;&#13;&#13;&lt;inline&gt;&lt;![CDATA[&#13;                    &lt;/li&gt;        &#13;          &lt;/ul&gt;    &#13;]]&lt;/inline&gt;&#13;</programlisting>
<para>コンテンツだけクライアントに送信されるので、クライアントは<code>inline</code>コンポーネントについてなにも知りません(つまり<code>inline</code>はクライアントからは見えません。)このように、いくつかの制限があります。</para>
<orderedlist>
<listitem>
<para>埋め込みコンテンツは動的に変更できません。つまり、<code>inline</code>コンポーネントのコンテンツがクライアントに送信されると、更新が成功しているコンテンツどれもクライアントに送信されません。つまり、ユーザーは更新結果を見ることはありません。何より悪いのは<code>inline</code>を他の親要素に移したら、クライアントでいくつかのランタイムエラーが発生するかもしれません。ですから静的な(static)コンテンツを埋め込む場合だけに<code>inline</code>を使うのがいいです。どうしても動的に更新したい場合は、親要素を無効にしましょう。そして、親コンポーネントとすべての子コンポーネント(<code>inline</code>コンポーネントを含む)が再描画されます。</para>
</listitem>
<listitem>
<para>
<code>inline</code>コンポーネントはXULコンポーネントではありません。CSSスタイル、ツールチップ、ドラッグアンドドロップ、他のものを<code>inline</code>コンポーネントに設定できます。</para>
</listitem>
</orderedlist></sect2><sect2><title>HTMLとXULコンポーネントの混合</title>
<para>XMLネーム空間を使って、以下に示すように、開発者はHTMLとXULのコンポーネントを混在に使用することができます。</para>
<programlisting>&lt;window title="mix HTML demo" xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;          &lt;h:table border="1"&gt;    &#13;                    &lt;h:tr id="row1"&gt;        <inlinegraphic fileref="img/10000000000000B7000000350D72C956.png" align="right"/>&#13;                              &lt;h:td&gt;column 1&lt;/h:td&gt;            &#13;                              &lt;h:td&gt;            &#13;                                        &lt;listbox id="list" mold="select"&gt;                &#13;                                                  &lt;listitem label="AA"/&gt;                    &#13;                                                  &lt;listitem label="BB"/&gt;                    &#13;                                        &lt;/listbox&gt;                &#13;                              &lt;/h:td&gt;            &#13;                    &lt;/h:tr&gt;        &#13;          &lt;/h:table&gt;    &#13;          &lt;button label="add" onClick="new org.zkoss.zhtml.Td().append(row1)"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>
<code>html</code>と<code>inline</code>コンポーネントとは違って、HTMLタグが<code>content</code>プロパティに保存されて、ZKはどの(<code>http://www.w3.org/1999/xhtml</code>ネーム空間に関連している)HTMLタグに対してもコンポーネントを作成します。上の例に示すように(addボタン) 、その利点はどの個別HTMLタグも動的に処理できるところです。</para>
<para>しかし、HTMLタグもサーバーのXHTMLコンポーネントと関連しているので、メモリをより消耗します。</para></sect2><sect2><title>
<code>Include</code>コンポーネント</title>
<para>
<code>include</code>コンポーネントは他のサーブレットによって生成された出力を含んでいます。サーブレットはJSF、JSPと他のZUMLページさえも含んでいるものです。</para>
<programlisting>&lt;window title="include demo" border="normal" width="300px"&gt;&#13;          Hello, World!    &#13;          &lt;include src="/userguide/misc/includedHello.zul"/&gt;    &#13;          &lt;include src="/html/frag.html"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>他のプロパティのように、動的に<code>src</code>属性を変更してランタイムで異なったサーブレットからの出力を含むことができます。</para>
<para>含まれた出力が他のZUMLなら、開発者はまるでそれらが含まれているページであるかのように、含まれたページ中のコンポーネントへアクセスできます。</para><sect3><title>ZUMLページを含む</title>
<para>
<code>i</code>
<code>nclude</code>コンポーネントはZUMLページを含んでいます。含まれたページはデスクトップの一部分です。しかし、含まれたページはリクエストが完全に処理されるまで、参照可能にはなりません。つまり、ユーザーか、タイマーによって発生した以下のイベント中でのみ参照可能です。</para>
<para>その理由は含まれたコンポーネントはレンダリング段階<footnote>
<para>
<code>詳しくはコンポーネントのライフサイクルの章をご覧ください。</code>
</para>
</footnote>で初めてページを読み込み始めるからです。一方で、<code>zscript</code>はコンポーネント作成段階で処理されます。<code>onCreate</code>はイベント処理段階で処理されます。その二つは両方とも含まれる前に、実行されます。</para>
<programlisting>&lt;window onCreate="desktop.getPages()"&gt; &lt;!-- the included page not available --&gt;&#13;          &lt;include src="/my.zul"/&gt;    &#13;          &lt;zscript&gt;    &#13;                    desktop.getPages(); //the included page not available yet        &#13;          &lt;/zscript&gt;    &#13;          &lt;button label="Hit" onClick="desktop.getPages()"/&gt;    &#13;                    &lt;!-- Yes, the included page is available when onClick is received --&gt;        &#13;&lt;/window&gt;&#13;</programlisting>
<para>含まれたページのコンポーネントを調べたかったら、マクロコンポーネントがいい選択です。ZKユーザーインターフェースマークアップ言語章中のマクロコンポーネントセクションを参照してください。</para></sect3></sect2><sect2><title>
<code>style</code>コンポーネント</title>
<para>
<code>style</code>コンポーネントはCSSスタイルをZUMLページの中で指定します。最も簡単なフォーマットは以下のようです。</para>
<programlisting>&lt;style&gt;<inlinegraphic fileref="img/100000000000002900000018A07459D1.png" align="right"/>&#13;.blue {&#13;  color: white; background-color: blue;&#13;}&#13;&lt;/style&gt;&#13;&lt;button label="OK" sclass="blue"/&gt;&#13;</programlisting>
<para>【ヒント】： スタイルシートを全アプリケーションに設定するのに、zk.zmlの中で<code>theme-uri</code>を指定します。より詳しくはthe Developer’s ReferenceのAppendix Bを参照してください。言語にスタイルシートを設定するのに、language addonを使用します。Component Development Guideを参照してください。</para>
<para>
<code>my.css</code>といった独立するファイルの中でCSS定義を保存する方が便利です。そして、以下のように<code>style</code>コンポーネントを使うことで、それを参照することができます。</para>
<programlisting>&lt;style src="/my.css"/&gt;&#13;</programlisting>
<para>上のステートメントは実際に、以下のHTMLタグ<footnote>
<para>ウェブアプリケーションの設定によって、結果が変わります。</para>
</footnote>をブラウザに送信して、指定されたファイルはブラウザからアクセス可能でなければなりません。</para>
<programlisting>&lt;link rel="stylesheet" href="/css/mystyles.css"/&gt;&#13;</programlisting>
<para>つまり、<code>/WEB-INF/xx</code>
<link linkend="">と</link>
<code>C:/xx/yy</code>は指定できません。</para>
<para>他のURLのように、ブラウザとローカル化のスタイルシートを読み込むために*を受け取ります。より詳しくは国際化の章のブラウザとロケール依存 URIセクションを参照してください。</para></sect2><sect2><title>
<code>script</code>コンポーネント</title>
<para>
<code>script</code>コンポーネントはブラウザで働くスクリプトコードを意味します。<code>zscript</code>とは違って、スクリプトコードはブラウザ側で実行されます。スクリプトコードは大抵JavaScriptで書かれていて、ほとんどのブラウザは対応可能です。もっとも簡単なフォーマットは以下です。</para>
<programlisting>&lt;script type="text/javascript"&gt;&#13;function myfunc() {&#13;          $e("${win.uuid}").style.backgroundColor = "blue";    &#13;}&#13;&lt;/script&gt;&#13;</programlisting>
<para>上に示したように、<code>script </code>コードの中で、EL表記<code>(${win.uuid})</code>を使うことができます。</para>
<para>また以下のように<code>src</code>を使って外部のJavaScriptファイルを参照できます。</para>
<programlisting>&lt;script src="/js/super.js" type="text/javascript"/&gt;&#13;</programlisting>
<para>Zkアプリケーションがサーバーで動いている(お好きな言語で実行される)ので、ZKを使って、開発者はめったにJavaScriptコードを使用して、実行しません。JavaScriptはZKクライアントエンジンの動作をカスタマイズする、又は、既存のJavaScriptライブラリーを動かします。</para></sect2><sect2><title>
<code>iframe</code>コンポーネント</title>
<para>
<code>iframe</code>コンポーネントはHTML IFRAMEタグを使用して、画面の一部を他のURLの内容を表示させます。i<code>nclude</code>コンポーネントに類似しているように見えますが、そのコンセプトは全然違います。</para>
<para>
<code>include</code>コンポーネントによって含まれているコンテンツはHTMLページのフラグメントです。そのコンテンツはHTMLページの一部分なので、コンテンツはデスクトップの一部で<code>include</code>コンポーネントの中のどのコンポーネントへもアクセスできます。<code>include</code>作業はサーバーで行われ、ブラウザはそれについて何の情報もないです。つまり、<code>src</code>プロパティによって指定されたURLはどんな内部のリソースでも構いません。</para>
<para>
<code>iframe</code>コンポーネントのコンテンツはブラウザによって、異なった一つのページとして、読み込まれます。独立したページとして読み込まれるので、コンテンツのフォーマットはHTMLと異なっています。例えばPDFファイルを埋め込むことができます。</para>
<programlisting>&lt;iframe src="/my.pdf"/&gt;&#13;...other HTML content&#13;</programlisting>
<para>【ヒント】：デフォルトではボーダー(枠)はありません。ボーダーを使うには、スタイル属性を使用して指定します。例えば、<code>&lt;iframe style="border:1px inset" src="http://www.zkoss.org"/&gt;</code>
</para>
<para>その埋め込みはIFRAMEタグを含んだHTMLページをインタープリットするときにブラウザによって行われます。つまり、そのURLはブラウザからアクセスできるリソースでなければなりません。</para>
<para>
<code>image</code>と<code>audio</code>コンポーネント<footnote>
<para><code>iframe</code> は <code>image</code> と <code>audio</code> と類似しています。</para>
</footnote>のように、動的に生成されたコンテンツを指定します。代表的な例はJasperReport<footnote>
<para>
<code>http://jasperreports.sourceforge.net</code>
</para>
</footnote>を使用して、バイナリ配列またはシステムの中でPDFレポートを生成します。レポートを<code>org.zkoss.util.media.Amedia</code>クラスを使って結果をまとめて、<code>iframe</code>コンポーネントに報告します。</para>
<para>以下の例中では、クライアントがそのフォーマットをサポートする限り、<code>iframe</code>の使用によりどのコンテンツも埋め込むことができます。</para>
<programlisting>&lt;window title="iframe demo" border="normal"&gt;&#13;          &lt;iframe id="iframe" width="95%"/&gt;    &#13;          &lt;separator bar="true"/&gt;    &#13;          &lt;button label="Upload"&gt;    &#13;                    &lt;attribute name="onClick"&gt;{        &#13;                              Object media = Fileupload.get();            &#13;                              if (media != null)            &#13;                                        iframe.setContent(media);                &#13;                    }&lt;/attribute&gt;        &#13;          &lt;/button&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>
<graphic align="center" fileref="img/1000000000000275000001275F0B1F07.png">2
			
		</graphic>
</para>
</entry>
<entry>
<para>この画像はユーザーがマイクロソフトのパワーポイントファイルを更新した後の画像です。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2></sect1><sect1><title>HTMLフォームとJavaサーブレットの使用</title>
<para>イベントドリブンモデルはシンプルでパワフルです。しかし、イベントリスナとサーブレットを再描画するのは実用的でないかもしれません。</para><sect2><title>
<code>name</code>プロパティ</title>
<para>レガシーウェブアプリケーションと働くためには、HTMLページ<code>name</code>プロパティを指定します。例えば、</para>
<programlisting>&lt;window xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;    &lt;h:form method="post" action="/my-old-servlet"&gt;&#13;    &lt;grid&gt;&#13;        &lt;rows&gt;&#13;    &lt;row&gt;When &lt;datebox name="when"/&gt; Name &lt;textbox name="name"/&gt; Department&#13;    &lt;combobox name="department"&gt;&#13;        &lt;comboitem label="RD"/&gt;&#13;        &lt;comboitem label="Manufactory"/&gt;&#13;        &lt;comboitem label="Logistics"/&gt;&#13;    &lt;/combobox&gt;&#13;    &lt;/row&gt;&#13;    &lt;row&gt;&#13;        &lt;h:input type="submit" value="Submit"/&gt;&#13;    &lt;/row&gt;&#13;        &lt;/rows&gt;&#13;<inlinegraphic fileref="img/10000000000002F70000003EBB733BC1.png" align="right"/>    &lt;/grid&gt;&#13;    &lt;/h:form&gt;&#13;&lt;/window&gt;&#13;</programlisting>
<para>ユーザーがsubmitボタンを押すと、リクエストは以下のようにクエリ文字列を使って<code>my-old-servlet</code>サーブレットに提示されます。</para>
<programlisting>/my-old-servlet?when=2006%2F03%2F01&amp;name=Bill+Gates&amp;department=Manufactory&#13;</programlisting>
<para>このため、ネームと値の間の関係をきちんと管理できているなら、サーブレットの設定を変更しなくてもいつもと同じように動作します。</para></sect2><sect2><title>
<code>name</code>プロパティをサポートするコンポーネント</title>
<para>すべてのInput-typesコンポーネントは<code>textbox</code>,<code>datebox</code>,<code>decimalbox</code>,<code>intbox</code>,<code>combobox</code>,<code>bandbox</code>のような<code>name</code>プロパティをサポートします。</para>
<para>さらに、リストボックスとツリーコントロールは<code>name</code>プロパティをサポートしています。<code>multiple</code>プロパティが<code>t</code>
<code>rue</code>でユーザーが多数項目を選択した場合、多数のネーム/値のペアは提示されます。</para>
<programlisting>&lt;listbox name="who" multiple="true" width="200px"&gt;&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="name"/&gt;        &#13;                    &lt;listheader label="gender"/&gt;        &#13;          &lt;/listhead&gt;    &#13;          &lt;listitem value="mary&gt;    &#13;                    &lt;listcell label="Mary"/&gt;        &#13;                    &lt;listcell label="FEMALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem value="john"&gt;    &#13;                    &lt;listcell label="John"/&gt;        &#13;                    &lt;listcell label="MALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem value="jane"&gt;    &#13;                    &lt;listcell label="Jane"/&gt;        &#13;                    &lt;listcell label="FEMALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;          &lt;listitem value="henry"&gt;    <inlinegraphic fileref="img/10000000000000D10000005D4B19ECE7.png" align="right"/>&#13;                    &lt;listcell label="Henry"/&gt;        &#13;                    &lt;listcell label="MALE"/&gt;        &#13;          &lt;/listitem&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting>
<para>JohnとHenryが選択された場合、クエリ文字は以下になります：</para>
<programlisting>who=john&amp;who=henry&#13;</programlisting>
<para>
<code>name</code>プロパティと一緒のリストボックスとツリーコントロールの使用するにはvalueプロパティを<code>listitem</code>と<code>treeitem</code>にそれぞれ指定しなければなりません。それらはサーブレットに提示される値です。</para></sect2><sect2><title>リッチユーザーインターフェース</title>
<para>
<code>form</code>コンポーネントはどんな種類のコンポーネントも含んでいるので、リッチユーザーインターフェースは存在しているサーブレットに関係なく実装されます。例えば、<code>onOpen</code>イベントを監視して、前のセクションで説明したようにタブパネルを実現します。もう一つの例は、動的にグリッドコントロールに列を追加します。そして、それぞれの列に <code>name</code>プロパティを使って入力ボックスを制御します。ユーザーがフォームを提出すると、更新されたコンテンツはサーブレットに提示されます。</para></sect2></sect1><sect1><title>クライアント側の動作</title>
<para>JavaScriptコードを使ってクライアントで行われたほうがいい操作がいくつかあります。たとえば、アニメーション、メールロールオーバーなどです。JavaScriptコードをクライアントで実行するのに、ZKはクライアント側の動作(CSA)のコンセプトを紹介します。CSAを使用して、開発者はいくつかのJavaScriptイベントを監視し、クライアント側でJavaScriptコードを実行します。</para>
<para>JavaScriptで書かれていることとクライアント側で実行される点以外は、CSAはイベントリスナに似ています。ZKは開発者が<code>onfocus</code>、<code>onblur</code>、<code>onmouseover</code>、<code>onmouseout</code>といったJavaScriptイベントに動作を、目標ブラウザがそれらをサポートしている限り、指定できます。</para>
<para>クライアント側の動作のシンタックスは以下のようです。</para>
<programlisting>action="[onfocus|onblur|onmouseover|onmouseout|onclick|onshow|onhide...]: javascript;"&#13;</programlisting>
<para>
<code>onFocus</code>のような名前を持っているかもしれませんが、CSAとZKイベントリスナとは別物です。違う点は以下を参照ください。</para>
<itemizedlist>
<listitem>
<para>ZKイベントリスナがサーバーで呼び出される前に、CSAはクライアント側で実行されます。</para>
</listitem>
<listitem>
<para>CSAコードはJavaScript中でかかれる一方、ZKイベントリスナはJava中でかかれます。</para>
</listitem>
<listitem>
<para>CSAに目標ブラウザが許可するイベントのすべてを登録することができます。ZKはEventsセクション中のリストのイベントだけをサポートします。</para>
</listitem>
</itemizedlist><sect2><title>コンポーネントの参照</title>
<para>JavaScriptコード中でレイト(晩期)バインディングEL表記を使用して、コンポーネント又は他のオブジェクトを参照できます。レイトバインディングEL表記は以下に書かれているように、<code>#{</code>で始まり、<code>}</code>で終わります。</para>
<programlisting>&lt;button action="onmouseover: action.show(#{parent.tip})"/&gt;&#13;</programlisting>
<para>レイトバインディングEL表記は読み込み段階と同じくらいに処理されます。一方で、<code>${</code>,で始まるEL表記を指定したら、コンポーネント作成段階で<code>action</code>プロパティに指定される前に評価されます。例えば、 </para>
<programlisting>&lt;button action="onfocus: action.show(${tip}); onblur: action.hide(${tip})"/&gt;&#13;&lt;div id="tip" visible="false"&gt;...&lt;/div&gt;&#13;</programlisting>
<para>は以下に処理されます。</para>
<programlisting>&lt;button action="onfocus: action.show(); onblur: action.hide()"/&gt;&#13;&lt;div id="tip" visible="false"&gt;...&lt;/div&gt;&#13;</programlisting>
<para>それは<code>action</code>プロパティが指定されるとき、<code>tip</code>コンポーネントがまだ作成されていないからです。</para>
<para>
<code>action</code>が指定される前に参照コンポーネントが作成されるとすると、ZUMLローダーがCSAについて　何も知らないので、それはまだ正しく動作しません。<code>toString</code>メソッドを呼び出されることでコンポーネントは文字列に変換されます。</para>
<para>また、以下に示すように、動作中に<code>$</code>
<code>{}</code>をしても構いません。ただ覚えておいてほしいのは<code>action</code>プロパティを指定する前に処理されるという事です。</para>
<programlisting>&lt;variables myaction="onfocus: action.show(#{tip}); onblur: action.hide(#{tip});"&#13;&lt;button action="${myaction} onmouseover: action.show(#{parent.parent.tip})"/&gt;&#13;</programlisting><sect3><title>
<code>onfocus</code> と<code>onblur</code>の例</title>
<para>以下の例で、クライアント側を使用してオンラインヘルプを提供する方法をデモします。ユーザーがフォーカスをテキストボックスに変えるとき、それに従ってヘルプメッセージが表示されます。</para>
<programlisting>&lt;grid&gt;&#13;          &lt;columns&gt;    <inlinegraphic fileref="img/1000000000000164000000379E269FE3.png" align="right"/>&#13;                    &lt;column/&gt;        &#13;                    &lt;column/&gt;        &#13;                    &lt;column/&gt;        &#13;          &lt;/columns&gt;    &#13;          &lt;rows&gt;    &#13;                    &lt;row&gt;        &#13;&lt;label value="text1: "/&gt;&#13;&lt;textbox action="onfocus: action.show(#{help1}); onblur: action.hide(#{help1})"/&gt;&#13;&lt;label id="help1" visible="false" value="This is help for text1."/&gt;&#13;                    &lt;/row&gt;        &#13;                    &lt;row&gt;        &#13;&lt;label value="text2: "/&gt;&#13;&lt;textbox action="onfocus: action.show(#{help2}); onblur: action.hide(#{help2})"/&gt;&#13;&lt;label id="help2" visible="false" value="This is help for text2."/&gt;&#13;                    &lt;/row&gt;        &#13;          &lt;/rows&gt;    &#13;&lt;/grid&gt;&#13;</programlisting></sect3><sect3><title>強制的なルール</title>
<para>ZULコンポーネントは実際にEL表記<code>(＃{})</code>を結果オブジェクトのクラスに基づいて、適切なJavaScriptコードに変換します。</para>
<orderedlist>
<listitem>
<para>結果が無効な場合、<code>null</code>ととって変えます。</para>
</listitem>
<listitem>
<para>結果がコンポーネントの場合、<code>$e</code>
<code>('</code>
<code>uuid</code>
<code>')</code>を取り換えます。<code>$e</code>はJavaScriptのファンクションで参照をHTMLタグに返します。<code>uuid</code>はコンポーネントのUUIDです。</para>
</listitem>
<listitem>
<para>結果がデータのオブジェクトの場合、<code>new Date(milliseconds)</code>と取り換えます。</para>
</listitem>
<listitem>
<para>それ以外の場合、<code>toString</code>メソッドを呼び出す事で、結果は文字列に変換されます。そして、<code>'</code>
<code>result in string'</code>と取り換えます。</para>
</listitem>
</orderedlist></sect3></sect2><sect2><title>
<code>onshow</code>と<code>onhide</code>動作</title>
<para>
<code>onshow</code>と<code>onhide</code>動作はコンポーネントの表示と非表示の設定を行います。</para><sect3><title>ウィンドウの表示方法を変更する例。</title>
<programlisting>&lt;zk&gt;&#13;          &lt;button label="Show Overlapped" onClick="win.doOverlapped();"/&gt;    &#13;          &lt;window id="win" border="normal" width="200px" mode="overlapped"    &#13;action="onshow:anima.appear(#{self});onhide:anima.fade(#{self})" visible="false"&gt;&#13;                    &lt;caption image="/img/inet.png" label="Hi there!"/&gt;        &#13;                    &lt;checkbox label="Hello, Effect!"/&gt;        &#13;          &lt;/window&gt;    &#13;&lt;/zk&gt;&#13;</programlisting></sect3></sect2><sect2><title>CSA JavaScript ユーティリティ</title>
<para>CSAプログラミングを簡単にするのに、ZKは利用できるユーティリティオブジェクトを提供しています。</para><sect3><title>
<code>action</code>オブジェクト</title>
<para>基本ユーティリティはどのオブジェクトにも適用することができます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>ファンクション名</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>action.show(cmp)</code>
</para>
</entry>
<entry>
<para>コンポーネントを可視化します。</para>
<para>
<code>cmp</code> はコンポーネントで、<code> #{</code>
<code>EL-expr</code>
<code>}</code>を使って識別します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>action.hide(cmp)</code>
</para>
</entry>
<entry>
<para>コンポーネントを不可視化します。</para>
<para>
<code>cmp </code>はコンポーネントで、<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使って識別します。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>【ヒント】：JavaScriptプログラマーには、style.displayを直接視覚要素として処理するのは一般的です。しかし、それはいい方法ではありません。それはZKクライアントエンジンは視覚効果とバグの回避方法などを処理しなければならないからです。代わりに<code>action.show</code>と<code>action.hide</code>を使いましょう。</para></sect3><sect3><title>
<code>anima</code>オブジェクト</title>
<para>アニメーションのような視覚効果です。<code>anima</code>は<code>script.aculo.us</code>
<ulink url="http://script.aculo.us/">
<footnote>
<para>
<code>http://script.aculo.us </code>には便利なJavaScriptライブラリーがあります。</para>
</footnote>
</ulink>によって提供されたEffectクラスに基づいています。APIは単純です。視覚効果を追加する場合、Effectを使用します。</para>
<para>【メモ】:Effectは<code>DIV</code>タグで閉じられたコンポーネントを必要としています。すべてのZULコンポーネントはこの方法で実装されているわけではありません。使えるかどうかわからなかったら、以下のように<code>div</code>コンポーネントを重ねましょう。</para>
<programlisting>&lt;window&gt;&#13;          &lt;div id="t" visible="false"    &#13;          action="onshow: anima.slideDown(#{self}); onhide: anima.slideUp(#{self})"&gt;    &#13;            &lt;div&gt;&lt;!-- the 2nd div is optional but sometimes it looks better with it --&gt;&#13;                              &lt;groupbox&gt;            &#13;                                        &lt;caption label="slide down"/&gt;                &#13;                                        Hi &lt;textbox/&gt;                &#13;                              &lt;/groupbox&gt;            &#13;                              When? &lt;datebox/&gt;            &#13;                    &lt;/div&gt;        &#13;          &lt;/div&gt;    &#13;          &lt;button label="toggle" onClick="t.visible = !t.visible"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para/>
<para>また、この制限のない他のライブラリーを読み込めます。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>ファンクション名</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>anima.appear(cmp)anima.appear(cmp, dur)</code>
</para>
</entry>
<entry>
<para>不透明度を増やす事でコンポーネントを可視化します。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して識別します。</para>
<para>
<code>dur</code>: 継続期間(単位：ミリ秒)。デフォルトは800。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.slideDown(cmp)anima.slideDown(cmp, dur)</code>
</para>
</entry>
<entry>
<para>スライドダウン効果でコンポーネントを可視化します。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して、識別します。 </para>
<para>
<code>dur</code>:継続期間(単位：ミリ秒)。デフォルトは400。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.slideUp(cmp)anima.slideUp(cmp, dur)</code>
</para>
</entry>
<entry>
<para>スライドアップ効果でコンポーネントを付加しにします。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して、識別します。 </para>
<para>
<code>dur</code>:継続期間(単位：ミリ秒)。デフォルトは400。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.fade(cmp)anima.fade(cmp, dur)</code>
</para>
</entry>
<entry>
<para>フェードアウトによりコンポーネントを不可視化します。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して、識別します。 </para>
<para>
<code>dur</code>:継続期間(単位：ミリ秒)。デフォルトは550。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.puff(cmp)anima.puff(cmp, dur)</code>
</para>
</entry>
<entry>
<para>パフアウトによりコンポーネントを不可視化します。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して識別します。 </para>
<para>
<code>dur</code>:継続期間(単位：ミリ秒)。デフォルトは700です。 </para>
</entry>
</row>
<row>
<entry>
<para>
<code>anima.dropOut(cmp)</code>
<code>anima.dropOut(cmp, dur)</code>
</para>
</entry>
<entry>
<para>フェーディングとドロップアウトによりコンポーネントを不可視化します。</para>
<para>
<code>cmp</code>:コンポーネント。<code>#{</code>
<code>EL-expr</code>
<code>}</code>を使用して識別します。 </para>
<para>
<code>dur</code>:継続期間(単位：ミリ秒)。デフォルトは700です。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>例えば、</para>
<programlisting>&lt;window title="Animation Effects"&gt;&#13;   &lt;style&gt;.ctl {   border: 1px outset #777; background:#ddeecc;&#13;   margin: 2px; margin-right: 10px; padding-left: 2px; padding-right: 2px;&#13; &#13;}&#13;   &lt;/style&gt;&#13;   &lt;label value="Slide" sclass="ctl"action="onmouseover: anima.slideDown(#{t}); onmouseout: anima.slideUp(#{t})"/&gt;&#13;   &lt;label value="Fade" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.fade(#{t})"/&gt;&#13;   &lt;label value="Puff" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.puff(#{t})"/&gt;&#13;   &lt;label value="Drop Out" sclass="ctl"action="onmouseover: anima.appear(#{t}); onmouseout: anima.dropOut(#{t})"/&gt;&#13;   &lt;div id="t" visible="false"&gt;&#13;      &lt;div&gt;&#13;      &lt;groupbox&gt;&#13;         &lt;caption label="Dynamic Content"/&gt;&#13;         Content to show and hide dynamically.&#13;         &lt;datebox/&gt;&#13;      &lt;/groupbox&gt;&#13;      Description &lt;textbox/&gt;      &#13;      &lt;/div&gt;&#13;   &lt;/div&gt;&#13;&lt;/window&gt;&#13;</programlisting>
</sect3></sect2></sect1><sect1><title>イベント</title>
<para>イベントがサポートされているかどうかはコンポーネントしだいです。さらに、イベントはコンポーネントのコンテンツが更新された後に送信されます。</para><sect2><title>マウスイベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption column div groupbox image imagemap label listcell listfooter listheader menuitem tabpanel toolbar toolbarbutton treecell treecol window</code>
</para>
</entry>
<entry>
<para>イベント： <code>org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>ユーザーがコンポーネントをクリックしたことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onRightClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption checkbox column div groupbox image imagemap label listcell listfooter listheader listitem radio slider tab tabbox tabpanel toolbar toolbarbutton treecell treecol treeitem window</code>
</para>
</entry>
<entry>
<para>イベント：<code> org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>ユーザーがコンポーネントを右クリックしたことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onDoubleClick</code>
</para>
</entry>
<entry>
<para>
<code>button caption checkbox col</code>
<code>umn div groupbox image label listcell listfooter listheader listitem tab tabpanel toolbar treecell treecol treeitem window</code>
</para>
</entry>
<entry>
<para>イベント：<code> org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>ユーザーがコンポーネントをダブルクリックしたことを意味します。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
</sect2><sect2><title>Keystroke イベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onOK</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント： <code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>ユーザーがENTERキーを押したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCancel</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント：<code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>ユーザーがESCキーを押したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCtrlKey</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント：<code>org.zkoss.zk.ui.event.KeyEvent</code>
</para>
<para>ユーザーがPgUp、Home、または、<code>Ctrl</code>や<code>Alt</code>と組み合わされたキーといった特別なキーがユーザによって押されたことを意味します。もっと詳しくは以下の<code>ctrlKeys</code>Propertyセクション参照ください。</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>キーストロークイベントは指定されたイベントにイベントリスナを保存した一番近いウィンドウに送信されます。それはsubmit、cancel、shortcut機能を実装するためにあります。</para>
<para>以下に説明されたように、T1にフォーカスしていて、ユーザーがENTERを押しら<code>DoA()</code>は呼び出されます。T2にフォーカスしていてユーザーがENTERを押したなら、<code>doB()</code>が呼び出されます。</para>
<programlisting>&lt;window id="A" onOK="doA()"&gt;&#13;          &lt;window id="B" onOK="doB()"&gt;    &#13;                    &lt;textbox id="T1"/&gt;        &#13;          &lt;/window&gt;    &#13;          &lt;textbox id="T2"/&gt;    &#13;&lt;/window&#13;</programlisting>
<para>ウィンドウはウィンドウの内側で送られるキーストロークイベントを手動でポストしない限り、受信しません。上の例ではイベントはウィンドウAには送信されません。<code>T1</code>をフォーカスする場合、<code>onOK</code>ハンドラがウィンドウBに宣言されたかどうかは関係ありません。</para><sect3><title>
<code>ctrlKeys</code>プロパティ</title>
<para>
<code>onCtrlKey</code>イベントを受け取るのに<code>ctrlKeys</code>プロパティでどのキーが中断させるか指定しなければなりません。つまり、<code>ctrlKeys</code> プロパティ中で指定されたキーだけがサーバーに返信されます。例えば、ユーザーが<code>Alt+C</code>,<code>Ctrl+A</code>,<code>F10</code>,<code>Ctrl+F3</code>を押した場合、<code>onCtrlKey</code>イベントが送信されます。</para>
<programlisting>&lt;window ctrlKeys="@c a#10 #3"&gt;&#13;...&#13;</programlisting>
<para>以下は<code>ctrlKeys</code>プロパティのシンタックスです。</para>
<para/>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>キー</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
<row>
<entry>
<para> <code>k</code>
</para>
</entry>
<entry>
<para>コントロールキー。i.e,<code>Ctrl</code>+<code>k</code>,  <code>k</code> はa~z，0~9，#n か~n。</para>
</entry>
</row>
<row>
<entry>
<para>@<code>k</code>
</para>
</entry>
<entry>
<para>alt キー，i.e,<code>Alt</code>+<code>k</code>, <code>k</code> はa~z, 0~9, #n か ~n。</para>
</entry>
</row>
<row>
<entry>
<para>$<code>k</code>
</para>
</entry>
<entry>
<para>shift キー，i.e,<code>Shift</code>+<code>k</code>，<code>k</code>= #n , ~n。</para>
</entry>
</row>
<row>
<entry>
<para>#<code>n</code>
</para>
</entry>
<entry>
<para>特別なキー：</para>
<informaltable frame="all">
<tgroup cols="6">
<colspec colnum="1" colname="c1"/>
<colspec colnum="2" colname="c2"/>
<colspec colnum="3" colname="c3"/>
<colspec colnum="4" colname="c4"/>
<colspec colnum="5" colname="c5"/>
<colspec colnum="6" colname="c6"/><tbody>
<row>
<entry>
<para>#<code>home</code>
</para>
</entry>
<entry>
<para>
<code>Home</code>
</para>
</entry>
<entry>
<para>#<code>end</code>
</para>
</entry>
<entry>
<para>
<code>End</code>
</para>
</entry>
<entry>
<para>#<code>ins</code>
</para>
</entry>
<entry>
<para>
<code>Ins</code>
<code>ert</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>del</code>
</para>
</entry>
<entry>
<para>
<code>Del</code>
<code>ete</code>
</para>
</entry>
<entry>
<para>#<code>left</code>
</para>
</entry>
<entry>
<para>
<code>←</code>
</para>
</entry>
<entry>
<para>#<code>right</code>
</para>
</entry>
<entry>
<para>
<code>→</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>up</code>
</para>
</entry>
<entry>
<para>
<code>↑</code>
</para>
</entry>
<entry>
<para>#<code>down</code>
</para>
</entry>
<entry>
<para>
<code>↓</code>
</para>
</entry>
<entry>
<para>#<code>pgup</code>
</para>
</entry>
<entry>
<para>
<code>PgUp</code>
</para>
</entry>
</row>
<row>
<entry>
<para>#<code>pgdn</code>
</para>
</entry>
<entry>
<para>
<code>PgDn</code>
</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>#<code>f</code>
<code>n</code>
</para>
</entry>
<entry namest="c2" nameend="c6">
<para>ファンクションキー。 #<code>f1</code>, #<code>f2</code>, ... #<code>f12</code> は <code>F1</code>, <code>F2</code>,... <code>F12</code>に対応。</para>
</entry>
</row></tbody></tgroup>
</informaltable>

<para/>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>入力イベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onChange</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.InputEvent</code>
</para>
<para>ユーザーが入力コンポーネントのコンテンツを変更したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onChanging</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.InputEvent</code>
</para>
<para>ユーザーが入力コンポーネントのコンテンツを変更していることを意味します。(サーバーで) コンポーネントのコンテンツは<code>onChanged</code>を受信するまで変更しません。そのため、<code>InputEvent</code>クラス中で<code>getValue</code>メソッドを呼び出して、一時データを取得しなければなりません。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onSelection</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandbox</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.SelectionEvent</code>
</para>
<para>ユーザーが入力コンポーネントのテキスト部分を選択している事を意味します。<code>getStart</code>と<code>getEnd</code>メソッドより選択したテキストの初めと終わりの部分を取得できます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onFocus</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandboxbutton toolbarbutton checkboxradio</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.Event</code>
</para>
<para>コンポーネントをフォーカスしたという意味です。</para>
<para>サーバーでイベントリスナが実行されていることを覚えてください。そのため、<code>onFocus</code>が実行されるときクライアントでのフォーカスは変更されているかもしれません。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onBlur</code>
</para>
</entry>
<entry>
<para>
<code>textbox datebox decimalbox doublebox intbox combobox bandboxbutton toolbarbutton checkboxradio</code>
</para>
</entry>
<entry>
<para>イベント:<code> org.zkoss.zk.ui.event.Event</code>
</para>
<para>コンポーネントがフォーカスを失ったという意味です。</para>
<para>サーバでイベントリスナが動作しているから、<code>onBlur</code>のイベントリスナが動作しているときクライアントでのフォーカスは変更されているかもしれません。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>リストとツリーイベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onSelect</code>
</para>
</entry>
<entry>
<para>
<code>listbox tabbox tab tree</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.SelectEvent</code>
</para>
<para>ユーザーが一つまたは多数の子コンポーネントを選択したという意味です。<code>listbox</code>では、<code>listitem</code>のセットです。<code>tree</code>では、<code>treeitem</code>のセットです。<code>tabbox</code>ではtabのことです。</para>
<para>メモ：<code>onSelect</code>は<code>tab</code>と<code>tabbox</code>両方に送信されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onOpen</code>
</para>
</entry>
<entry>
<para>
<code>groupbox treeitem combobox bandbox menupopup window</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.OpenEvent</code>
</para>
<para>ユーザーがコンポーネントを開いたたまたは閉じたことを意味します。メモ：<code>onClose</code>とは違って、このイベントはコンポーネント開閉後のただの通知です。</para>
<para>
<code>onOpen</code>イベントを監視し、コンポーネントが初めて開かれたときにコンポーネント作成をすることで、load-on-demandを実装するのは便利です。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>スライダーとスクロールイベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onScroll</code>
</para>
</entry>
<entry>
<para>
<code>Slider</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.ScrollEvent</code>
</para>
<para>スクロール可能なコンポーネントのコンテンツがユーザーによってスクロールされたことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onScrolling</code>
</para>
</entry>
<entry>
<para>
<code>Slider</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.ScrollEvent</code>
</para>
<para>ユーザーがスクロール可能なコンポーネントをスクロールしている事を意味します。(サーバーで)コンポーネントコンテンツは<code>onScroll</code>を受け取るまで変更されません。このため、<code>ScrollEvent</code>クラス中の<code>getPos</code>メソッドを呼び出して一時的な位置を取得しなければなりません。 </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>他のイベント</title>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onCreate</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.ui.zk.ui.event.CreateEvent</code>
</para>
<para>ZUMLページ読み込み時にコンポーネントが作成されることを意味します。コンポーネントのライフサイクルの章を参照してください。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClose</code>
</para>
</entry>
<entry>
<para>
<code>window tab fileupload</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.ui.zk.ui.event.Event</code>
</para>
<para>closeボタンがユーザーによって押されたことを意味します。コンポーネントは自分自身をはずします。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onDrop</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.ui.zk.ui.event.DropEvent</code>
</para>
<para>他のコンポーネントがこのイベントを受け取るコンポーネントのところへドロップしたことを意味します。ドラッグ&amp;ドロップセクションを参照してください。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onCheck</code>
</para>
</entry>
<entry>
<para>
<code>checkbox radio radiogroup</code>
</para>
</entry>
<entry>
<para>イベント:<code> org.zkoss.zk.ui.event.CheckEvent</code>
</para>
<para>ユーザーによってコンポーネントのステートメントが変更されたことを意味します。</para>
<para>メモ： <code>onCheck</code>は<code>radio</code>と<code>radiogroup</code>の両方に送信されます 。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onMove</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.MoveEvent</code>
</para>
<para>ユーザーによってコンポーネントが動かされたことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onSize</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.SizeEvent</code>
</para>
<para>ユーザーがコンポーネントのサイズを変更したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onZIndex</code>
</para>
</entry>
<entry>
<para>
<code>window</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.ZIndexEvent</code>
</para>
<para>ユーザーがコンポーネントのz-indexを変更したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onTimer</code>
</para>
</entry>
<entry>
<para>
<code>timer</code>
</para>
</entry>
<entry>
<para>イベント:<code> org.zkoss.zk.ui.event.Event</code>
</para>
<para>指定したタイマーがイベントを発生させた事を意味します。どのタイマーかを知るのに、Eventクラス中で<code>getTarget</code>メソッドを呼び出します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onNotify</code>
</para>
</entry>
<entry>
<para>any</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.Event</code>
</para>
<para>アプリケーション依存イベントである事を意味します。その意味はアプリケーションによって違います。現在このイベントを送信するコンポーネントはありません。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClientInfo</code>
</para>
</entry>
<entry>
<para>root</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.ClientInfoEvent</code>
</para>
<para>タイムゾーン、解像度のようなクライアント情報をルートコンポーネントに通知します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onPiggyback</code>
</para>
</entry>
<entry>
<para>root</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zku.ui.event.Event</code>
</para>
<para>クライアントがリクエストをサーバーに送信したことをルートコンポーネントに通知します。それは大抵リアルタイムでないUIの更新をクライアントへピギーバックするときに使われます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onColSize</code>
</para>
</entry>
<entry>
<para>
<code>columns listhead treecols</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zul.event.ColSizeEvent</code>
</para>
<para>二つの子要素の幅が変更されたことをヘッダーグループの親要素に通知します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onPaging</code>
</para>
</entry>
<entry>
<para>
<code>grid listbox paging</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zul.event.PagingEvent</code>
</para>
<para>マルチページコンポーネントのうちの一ページがユーザによって選択されたことを通知します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onUpload</code>
</para>
</entry>
<entry>
<para>
<code>fileupload</code>
</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zul.event.UploadEvent</code>
</para>
<para>file(s)がアップロードされたことを意味します。アプリケーションは<code>getMedia</code>または<code>getMedias</code>メソッドを使ってアップロードしたファイルを取得することができます。</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>
<code/>
</title></sect3><sect3><title>
<code>radio</code>と<code>radiogroup</code> イベントの流れ</title>
<para>開発者にとって使いやすくするため、<code>onCheck</code>イベントは初め<code>raido</code>に送信され、そして、<code>radiogroup</code>
<footnote>
<para>
<code>radio</code> が <code>radiogroup</code>に追加されたときに内部ではリスナを追加することで実現します。</para>
</footnote>に送信されます。このため、<code>radiogroup</code>または<code>radio</code>ボタンごとにリスナを付加えることができます。</para>
<programlisting>&lt;radiogroup onCheck="fruit.value = self.selectedItem.label"&gt;&#13;          &lt;radio label="Apple"/&gt;    &#13;          &lt;radio label="Orange"/&gt;    &#13;&lt;/radiogroup&gt;&#13;You have selected : &lt;label id="fruit"/&gt;&#13;</programlisting>
<para>上のサンプル効果は以下のようです。</para>
<programlisting>&lt;radiogroup&gt;&#13;          &lt;radio label="Apple" onCheck="fruit.value = self.label"/&gt;    &#13;          &lt;radio label="Orange" onCheck="fruit.value = self.label"/&gt;    &#13;&lt;/radiogroup&gt;&#13;You have selected : &lt;label id="fruit"/&gt;</programlisting>
</sect3></sect2></sect1></chapter>
<chapter>
<title>8. ZUMLとXHTMLコンポーネントセット</title>
<para>この章ではXHTMLコンポーネントセットを説明します。</para><sect1><title>目的</title>
<para>XHTMLコンポーネントセットを紹介したのはすでに存在しているウェブページをZUMLに変更する事を簡単にするためです。最終的な目的はすべて有効なXHTMLページを有効なZUMLページにすることです。そして、サーブレットはいつもの通り送信されたフォームを処理します。</para>
<para>こうして、存在しているXHTMLページはZUMLページが持っているパワフルな利点：リッチなインターフェースを共有できます。リッチなUIは二つの方法で実現できます。初めは、Javaコードを埋め込み、XHTMLコンポーネントを動的に処理します。二つ目は、XHTMLをXULページに挿入するように、存在しているページにすでにできているXULコンポーネントを追加することです。</para><sect2><title>XHTMLページは有効なZUMLページ</title>
<para>以下に示したウェブページは簡単ですが、代表的な例です。</para>
<programlisting>&lt;html&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;ul id="ul"&gt;&#13;      &lt;li&gt;The first item.&lt;/li&gt;&#13;      &lt;li&gt;The second item.&lt;/li&gt;&#13;   &lt;/ul&gt;&#13;   &lt;input type="button" value="Add Item""/&gt;&#13;   &lt;br/&gt;&#13;   &lt;input id="inp0" type="text"/&gt; +&#13;   &lt;input id="inp1" type="text"/&gt; =&#13;   &lt;text id="out"/&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>
<code>zhtml</code>の拡張子<footnote>
<para>すべてのHTMLページをZUMLページに変換するため、拡張子の.htmlをDHtmlLayoutServletにマッピングします。開発用レファレンスのAppendix A をご覧ください。</para>
</footnote>で名前をつけることで、ZKローダーによりZUMLページとしてインタープリットされます。そして、<code>org.zkoss.zhtml.Html</code>、<code>org.zkoss.zhtml.Head</code>などのインスタンスはそれぞれ作成されます。つまり、XHTMLコンポーネントツリーはサーバー側で作成されました。そして、一般的なZUMLページと同様に、ZKはそれらを標準的なXHTMLページに変換し、ブラウザへ送信します。</para></sect2><sect2><title>サーバー中心構造の対話能力</title>
<para>ZUMLページであるには、Javaコードを埋め込めることができます。そして、以下のようにサーバーでそれらを実行します。</para>
<programlisting>&lt;html xmlns:zk="http://www.zkoss.org/2005/zk"&gt;&#13;&lt;head&gt;&#13;&lt;title&gt;ZHTML Demo&lt;/title&gt;&#13;&lt;/head&gt;&#13;&lt;body&gt;&#13;   &lt;h1&gt;ZHTML Demo&lt;/h1&gt;&#13;   &lt;ul id="ul"&gt;&#13;      &lt;li&gt;The first item.&lt;/li&gt;&#13;      &lt;li&gt;The second item.&lt;/li&gt;&#13;   &lt;/ul&gt;&#13;   &lt;input type="button" value="Add Item" zk:onClick="addItem()"/&gt;&#13;   &lt;br/&gt;&#13;   &lt;input id="inp0" type="text" zk:onChange="add()"/&gt; +&#13;   &lt;input id="inp1" type="text" zk:onChange="add()"/&gt; =&#13;   &lt;text id="out"/&gt;&#13;   &lt;zscript&gt;&#13;   void addItem() {&#13;      Component li = new Raw("li");&#13;      li.setParent(ul);&#13;      new Text("Item "+ul.getChildren().size()).setParent(li);&#13;   }&#13;   void add() {&#13;      out.setValue(inp0.getValue() + inp1.getValue());&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>上の例では、ZKネーム空間を使用して<code>onClick</code>プロパティを指定します。XHTML自身で同じ名前のプロパティを持つので、はっきり指定することは必要になります。</para>
<para>ここで注意してほしいのは、すべてのJavaコードはサーバーで実行されます。HTMLページ中に埋め込むJavaScriptとは違って、直接サーバーのリソースにアクセスできます。例えば、データベースにコネクションを開いたり、コンポーネント中に入れるためのデータを取得したりします。</para>
<programlisting>&lt;zscript&gt;&#13;import java.sql.*;&#13;void addItem() {&#13;          Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");    &#13;          String url = "jdbc:odbc:Fred";    &#13;          Connection conn = DriverManager.getConnection(url,"myLogin", "myPassword");    &#13;          ...    &#13;          conn.close();    &#13;}&#13;&lt;/zscript&gt;&#13;</programlisting></sect2><sect2><title>サーブレットはそのまま</title>
<para>従来のウェブアプリケーションでは、XHTMLページは処理するため、大抵特定なサーブレットに対してフォームを提出します。ページをZKへポーティングするため、それらを調整する必要はありません。</para></sect2></sect1><sect1><title>相違</title>
<para>ZKコンポーネントであるほかに、従来のXHTMLページをZKへ移植するのを簡単にするため、XHTMLコンポーネントセットの実装は他のコンポーネントセット<footnote>
<para>特定なインターフェースを実装するため、差が生じます。自分のコンポーネントにも適用できます。</para>
</footnote>とは違うように定義されています。</para><sect2><title>UUIDはIDです</title>
<para>従来のサーブレットとJavaScriptコードは大抵id属性によって決められます。そのため、XHTMLコンポーネントのUUIDはIDと同じに作られています。ですから、開発者は以下に示すように、既に存在しているコードを変更して、ZKへ適応させる必要はありません。</para>
<programlisting>&lt;img id="which"/&gt;&#13;&lt;script type="text/javascript"&gt;&lt;![CDATA[&#13;//JavaScript and running at the browser&#13;          function change() {    &#13;                    var el = document.getElementById("which");        &#13;                    el.src = "something.gif";        &#13;          }    &#13;]]&gt;&lt;/script&gt;&#13;&lt;zscript&gt;&lt;!-- Java and running at the server --&gt;&#13;          void change() {    &#13;                    which.src = "another.gif";        &#13;          }    &#13;&lt;/zscript&gt;&#13;</programlisting>
<para>UUIDは不変で、XHTML以外のコンポーネントに対しては無関係です。このため、上の例はXULコンポーネントが使われていると、失敗します。JavaScript中でXULコンポーネントを参照する場合、現在のUUIDを得るためのEL表記を使用しなければなりません。</para>
<programlisting>&lt;input id="which"/&gt;&#13;&lt;script type="text/javascript"&gt;//Running at the browser&#13;          var el = document.getElementById("${which.uuid}");    &#13;          el = $e("${which.uuid}"); //$e() is an utility of ZK Client Engine    &#13;&lt;/script&gt;&#13;</programlisting><sect3><title>副作用</title>
<para>UUIDはIDなので、同じデスクトップで二つのコンポーネントに対して同じ名前は使えません。</para></sect3></sect2><sect2><title>すべてのタグは有効</title>
<para>XULや他のコンポーネントセットとは違って、XHTMLコンポーネントセット中で無効なXML要素はありません。ZKは<code>org.zkoss.zhtml.Raw</code>クラスで未確認のXML要素<footnote>
<para>ノート:これは org.zkoss.zk.ui.ext.DynamicTag インタフェースを実装することにより完成します。</para>
</footnote>を組み立てます。ですから、ZKコンポーネントとして実装されているいないにかかわらず、開発者は目標ブラウザがサポートしているどのタグも使うことができます。</para>
<para>同様にして、以下のように<code>r</code>
<code>aw</code>コンポーネント使用してXHTMLコンポーネントの中で定義されていないコンポーネントも作成できます。</para>
<programlisting>new Raw("object"); //object could be any tag name the target browser supports&#13;</programlisting></sect2><sect2><title>大文字・小文字を区別せず</title>
<para>XUL、または他のコンポーネントセットとは違って、XHTMLのコンポーネント名は大文字・小文字を区別しません。以下のXML要素はすべて<code>org.zkoss.zhtml.Br</code>コンポーネントにマッピングされます。</para>
<programlisting>&lt;br/&gt;&#13;&lt;BR/&gt;&#13;&lt;bR/&gt;&#13;</programlisting></sect2><sect2><title>モールドはサポートされません</title>
<para>XHTMLコンポーネントはそのコンテンツを直接出力します。それらはモールドをサポートしていません。つまり、<code>mold</code>プロパティは無視されます。</para></sect2></sect1><sect1><title>ブラウザでのDOMツリー</title>
<para>XHTMLページをZKへ移植した後、JavaScriptを使ってブラウザでDOMツリーを処理する必要はありません。因みにZKはそれを禁止はしていません。代わりにXHTMLコンポーネントをサーバーで処理します。そしてZKエンジンはブラウザでDOMツリーを更新します。</para>
<para>それは便利ですが、落とし穴があります。ZKはブラウザにあるDOMツリーはサーバーにあるコンポーネントと同じを想定しています。大抵の場合、それは本当です。しかし、そうでない場合もあります。</para><sect2><title>
<code>TABLE</code>と<code>TBODY</code>タグ</title>
<para>ブラウザはいつも<code>TABLE</code>と<code>TR</code>の間に<code>TBODY</code>を作成します。こうして以下の二つのテーブルは同じ構造を持っています。</para>
<programlisting>&lt;table&gt;&#13;          &lt;tr&gt;&lt;td&gt;Hi&lt;/td&gt;&lt;/tr&gt;    &#13;&lt;/table&gt;&#13;&lt;table&gt;&#13;          &lt;tbody&gt;    &#13;                    &lt;tr&gt;&lt;td&gt;Hi&lt;/td&gt;&lt;/tr&gt;        &#13;          &lt;/tbody&gt;    &#13;&lt;/table&gt;&#13;</programlisting>
<para>あいにく、コンポーネントツリーはZKの中では同じではありません。このため、動的にテーブルを処理する場合、<code>TABLE</code>と<code>TR</code>の間に<code>TBODY</code>を宣言しなければなりません。もちろん、スティックテーブルの場合はこれを心配する必要はありません。</para></sect2></sect1><sect1><title>イベント</title>
<para>XHTMLコンポーネントは以下のイベントをサポートしていますが、適用できるかどうかはブラウザしだいです。例えば、<code>onChange</code>は入力の必要のないコンポーネント、例えば<code>body</code>、<code>div</code>、にとっては意味がありません。HTMLスタンダード<footnote>
<para>
<code>http/www.w3c.org</code>
</para>
</footnote>を参考にしてください。</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>イベント名</para>
</entry>
<entry>
<para>コンポーネント</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>onChange</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.InputEvent</code>
</para>
<para>ユーザーが入力コンポーネントのコンテンツを変更したことを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>onClick</code>
</para>
</entry>
<entry>
<para>all</para>
</entry>
<entry>
<para>イベント: <code>org.zkoss.zk.ui.event.MouseEvent</code>
</para>
<para>ユーザーがコンポーネントをクリックしたことを意味します。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect1><sect1><title>JSF、JSP、その他を組み込む</title>
<para>既存のウェブページに組み込む時、プログラマーは以下の点に気をつけなければなりません。</para>
<itemizedlist>
<listitem>
<para>その既存のページは静的ですか、それとも、動的に生成されていますか？</para>
</listitem>
<listitem>
<para>既存ページを少しだけ変更するか、それとも大幅に書き換えますか？</para>
</listitem>
<listitem>
<para>新しいページを追加するとき、XULとXHTMLのどちらかをデフォルトコンポーネントセットとして使用しますか？</para>
</listitem>
</itemizedlist>
<para>需要によって、いくつかのアプローチがあります。</para><sect2><title>既存のサーブレットを使用</title>
<para>フォームコンポーネントの使用によって、リクエストを既存のサーブレットをポストします。より詳しくはZUMLと XUコンポーネントセットの章のHTMLフォームとJavaサーブレットの使用セクションを参照してください。</para>
<para>フォームコンポーネントはいろいろなコンポーネントを含むことができるので、既存のサーブレットを変更することなく、リッチユーザーインターフェースを設計することができます。</para></sect2><sect2><title>挿入で豊富にする</title>
<para>既存のページの一部を書き直すとき、書き直す部分を別のZUMLファイルで書いたほうがいいかもしれません。そして、そのファイルを挿入します。例えば、JSP技術が使われているなら、<code>jsp:include </code>で挿入します。</para>
<programlisting>&lt;jsp:include page="/my/ria.zul"/&gt;&#13;</programlisting></sect2><sect2><title>静的なHTMLページを豊富にする</title>
<para>静的なHTMLページにリッチコンテンツを追加することでページを変更するなら、拡張子を<code>zhtml</code>に変更してください。ZKローダーはそのページを読み込み、ZKが動作します。</para></sect2><sect2><title>ZK JSPタグの使用</title>
<para>ZKはそれぞれのZULコンポーネントに対してJSPタグを提供します。もし、JSPページでそれらを使うとき、以下のようにTLDファイルを指定します。</para>
<programlisting>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"&#13; "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&#13;&#13;&lt;%@ taglib uri="/WEB-INF/tld/zul/jsp/zul2jsp.tld" prefix="z" %&gt;&#13;&#13;&lt;html&gt;&#13;   &lt;head&gt;&#13;      &lt;title&gt;Test of ZUL on JSP&lt;/title&gt;&#13;   &lt;/head&gt;&#13;   &lt;body&gt;&#13;   &lt;h1&gt;1. Header outside z:page&lt;/h1&gt;&#13;&lt;z:page&gt;&#13;   &lt;h2&gt;2. Header in z:page&lt;/h2&gt;&#13;   &lt;z:window title="Test" border="normal"&gt;&#13;      &lt;p&gt;3. Content in z:window&lt;/p&gt;&#13;   &lt;/z:window&gt;&#13;      &lt;p&gt;4. Content in z:page after z:window&lt;/h2&gt;&#13;&#13;&lt;/z:page&gt;&#13;   &lt;p&gt;5. Content after z:page&lt;/p&gt;&#13;   &lt;/body&gt;&#13;&lt;/html&gt;&#13;</programlisting>
<para>まずは、上に示したとおり、ZKクライアントエンジンが想定しているように<code>DOCTYPE</code>を指定しましょう。二番目にTLDファイルはZKパッケージの<code>dist/WEB-INF/tld/zul/jsp</code>ディレクトリーの中にあります。三番目、ページタグを使って、すべてのコンポーネントタグを閉じなければなりません。</para>
<para>ZULコンポーネントはJSPタグに包まれています。そして、プロパティはタグ属性に包まれてます。さらに、他のタグを使ってZK JSPを一緒に使うのもできます。こうしてZK JSPタグの使用はストレートです。</para></sect2><sect2><title>ZKフィルターを使用して動的に生成したページを豊富にする</title>
<para>動的に生成したHTMLページ(例えばJSPページの出力)をajax化にするときに、ZKフィルターで生成したページを処理します。ZKフィルターを使用可能にするのに、以下に示したように、<code>web.xml</code>を設定しなければなりません。</para>
<programlisting>&lt;filter&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;filter-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutFilter&lt;/filter-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;extension&lt;/param-name&gt;&#13;      &lt;param-value&gt;html&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;&lt;/filter&gt;&#13;&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&#13;&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna/*&lt;/url-pattern&gt;&#13;&lt;/filter-mapping&gt;&#13;</programlisting>
<para>
<code>url-pattern</code>はアプリケーションに依存します。<code>ex</code>
<code>tension</code>パラメーター(<code>init-param</code>)は動的な出力の言語を定義します。デフォルトでは<code>html</code>です。<code>xul/html</code>の場合、拡張子として<code>zul</code>を指定します。 </para>
<para>【ヒント】： ZK JSPはZKフィルターより少ないメモリーを消耗することは簡単です。上級者のための章のパフォーマンスを改善のためのヒントを参照ください。</para>
<para>挿入または転送からの出力にフィルターをかけたいときは、<code>REQUEST</code> and/or <code>INCLUDE</code>と共にはずされる要素を指定する事を忘れないでください。より詳しくは<code>Java Servlet Specification </code>を参照ください。例えば、</para>
<programlisting>&lt;filter-mapping&gt;&#13;   &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;&#13;   &lt;url-pattern&gt;/my/dyna/*&lt;/url-pattern&gt;&#13;   &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&#13;   &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;&#13;&lt;/filter-mapping&gt;&#13;</programlisting>
</sect2><sect2><title>XUL？それともXHTML？</title>
<para>正しい答えはありません。それは好みです。</para>
<para>しかし、覚えてほしいのは、<code>HTML</code>、<code>HEAD</code>、<code>BODY</code>タグを書いてページの見た目を変えるかどうかです。もしするなら、XHTMLをデフォルトのネーム空間として使用したほうが便利です（<code>zhtml</code>拡張子を使用）。もし、しないなら、XULをデフォルトのネーム空間として、(zul拡張子を使用)使用します。</para>
<para>コンポーネントを分けるためのXMLネーム空間の使用で同じページ中で異なったコンポーネントを混在に使用することができます。さらに、からのプレフィックスのネーム空間は選んだ拡張子とは無関係です。例えば、下のステートメントはどんな拡張子を使ったとしても有効です。</para>
<programlisting>&lt;window xmlns="http://www.zkoss.org/2005/zul" xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;          &lt;h:table&gt;    &#13;...&#13;</programlisting>
<para>上の記述は下と同様の働きをします。</para>
<programlisting>&lt;x:window xmlns:x="http://www.zkoss.org/2005/zul" xmlns="http://www.w3.org/1999/xhtml"&gt;&#13;          &lt;table&gt;    &#13;...&#13;</programlisting></sect2></sect1></chapter>
<chapter>
<title>9. マクロコンポーネント</title>
<para>コンポーネントを実装する方法は二つあります。一つは<code>org.zkoss.zk.ui.AbstractComponent</code>クラスから得られるクラスを実装します。もう一つは他のコンポーネントを使うことで実装します。</para>
<para>一番目の方法はより柔軟です。しかし、それを使うのに、より深くZKを理解する必要があります。ですから、この方法を使っているのは大抵コンポーネントの開発者です。詳しくはComponent Development Guideをご覧ください。</para>
<para>一方で、他のコンポーネントを使用した新しいコンポーネントの実装は直観的です。それは、組み立て、マクロ拡張またはインライン取替えのように動作します。便宜上、このタイプのコンポーネントをマクロコンポーネントと呼びます。このタイプでないコンポーネントをネイティブコンポーネントと呼びます。</para>
<para>【ヒント】：アプリケーション開発者の視点から見ると、実装の仕方を除いて、マクロコンポーネントとネイティブコンポーネントに違いはありません。</para><sect1><title>マクロコンポーネントを使用する三つのステップ</title>
<para>マクロコンポーネントを使用する三つのステップは以下のようです。</para>
<orderedlist>
<listitem>
<para>ZUMLページによってマクロコンポーネントを実装する。</para>
</listitem>
<listitem>
<para>それを使用するページの中でマクロコンポーネントを宣言する。</para>
</listitem>
<listitem>
<para>他のコンポーネントを使用するようにマクロコンポーネントを使用する。</para>
</listitem>
</orderedlist>
<para>【ヒント】：ページ中でマクロコンポーネントを定義することに加えて、言語<code>add-on</code>に定義を挿入する事ができます。そうすることによって、すべてのページはマクロコンポーネントにアクセスできます。</para><sect2><title>ステップ１．実装</title>
<para>必要な事はコンポーネントが構成しているものを説明するZUMLページを作成するだけです。つまり、そのページはマクロのテンプレートです。</para>
<para>例えば、ラベルとテキストボックスをパッケージにし、マクロコンポーネントを作ることにします。作り方は以下のように<code>/WEB-INF/macros/username.zul</code>を作成します。</para>
<programlisting>&lt;hbox&gt;&#13;          Username: &lt;textbox/&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting>
<para>出来上がりました。</para>
<para>ZUMLページがマクロコンポーネントを実装するのは、他のページとも同じです。つまり、どのZUMLページでもマクロコンポーネントとして使われます。</para></sect2><sect2><title>ステップ２.宣言</title>
<para>マクロコンポーネントをインスタンス化にする前に、宣言をしなければなりません。宣言する簡単な方法のうちの一つはコンポーネントコマンドを使用する事です。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;</programlisting>
<para>示したように、名前(<code>name</code>属性)とページのURI(<code>macro-uri</code>属性)を宣言しなければなりません。</para><sect3><title>その他のプロパティ</title>
<para>
<code>name</code>、<code>macro-uri</code>と<code>class</code>
<footnote>
<para>クラス属性は後ほど説明します。</para>
</footnote>属性に加えて、初期化されるときにコンポーネントをインスタンス化するために使用する初期プロパティのリストを指定できます。</para>
<programlisting>&lt;?component name="mycomp" macro-uri="/macros/mycomp.zul"&#13;    myprop="myval" another="anotherval"?&gt;&#13;</programlisting>
<para>そうして</para>
<programlisting>&lt;mycomp/&gt;&#13;</programlisting>
<para>以下と同様の働きをします。</para>
<programlisting>&lt;mycomp myprop="myval1" another="anotherval"/&gt;&#13;</programlisting></sect3></sect2><sect2><title>ステップ３．使用</title>
<para>マクロコンポーネントの使用は他のコンポーネントと何も変わりません。</para>
<programlisting>&lt;window&gt;&#13;          &lt;username/&gt;    &#13;&lt;/window&gt;&#13;</programlisting><sect3><title>
<code>pass </code>プロパティ</title>
<para>普通のコンポーネントを使うように、マクロコンポーネントを使用するとき、プロパティ(aka,.属性)を指定できます。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;window&gt;&#13;          &lt;username who="John"/&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>これらのプロパティはすべてマップ中に保存されます。そして、<code>arg</code>と呼ばれる変数を通して、テンプレートに送られます。テンプレート中では以下のようにこれらのプロパティにアクセスできます。</para>
<programlisting>&lt;hbox&gt;&#13;          Username: &lt;textbox value="${arg.who}"/&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting>
<para>【メモ】:マクロページが読み込まれているときのみ<code>arg</code>は利用可能です。イベントリスナの中で通信するために、<code>getDynamicProperty</code>を代わりに使用します。より詳しくはメソッドを使うセクションを参照ください。 </para></sect3><sect3><title>
<code>arg.includer</code>
</title>
<para>指定したプロパティ(aka,.属性)に加えて、<code>arg.includer</code>と呼ばれるプロパティがマクロテンプレート中で定義されたコンポーネントの親要素を表すためにいつも渡されます。 </para>
<para>標準マクロが作成されたとしたら、<code>arg.includer</code>はマクロコンポーネントそのものです。インラインマクロが作成されたら、<code>arg.includer</code>は親コンポーネントです。より詳しくはインラインマクロセクションを参照してください。</para>
<para>上の例では<code>arg.includer</code>は標準マクロコンポーネント、<code>&lt;username who="John"/&gt;</code>を表します。またそれは<code>＜hbox＞</code>(<code>username.zul</code>中で定義された)の親要素です。 </para></sect3></sect2></sect1><sect1><title>インラインマクロ</title>
<para>二種類のマクロコンポーネントがあります。インライン<footnote>
<para>インラインマクロコンポーネントはZK 2.3より追加されています。</para>
</footnote>とレギュラー(標準)です。デフォルトでは、レギュラーマクロスが想定されています。インラインマクロスを指定するのに、コンポーネントコマンド中で<code>inline=”true”</code>を指定しなければなりません。</para>
<para>インラインマクロは<code>inline-expansion</code>のように作動します。インラインマクロが指定されると、ZKはマクロコンポーネントを作成しません。その代わり、マクロURIの中で定義されたコンポーネントをインライン拡張します。つまり、インラインマクロのコンテンツを直接目標ページに入力するのと同様です。</para>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry>
<para>use.zul： (ターゲットページ)</para>
<programlisting>&lt;?component name="username" inline="true" macro-uri="username.zul"?&gt;
 &lt;grid&gt;
   &lt;rows&gt;
	 &lt;username id="ua" name="John"/&gt;
	&lt;/rows&gt;
 &lt;/grid&gt;</programlisting>
<para>username.zul：(マクロの定義)</para>
<programlisting>&lt;row&gt;
	Username
	&lt;textbox id="${arg.id}" value="${arg.name}"/&gt;
&lt;/row&gt;</programlisting>
</entry>
<entry>
<para>同等なページ：</para>
<programlisting>&lt;grid&gt;
   &lt;rows&gt;
 &lt;row&gt;
   Username
   &lt;textbox id="ua" value="John"/&gt;
 &lt;/row&gt;
   &lt;/rows&gt;
&lt;/grid&gt;</programlisting>
<para>所有的属性，包括id，都会被传递到内联宏。</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>一方で、ZKは(マクロコンポーネントと呼ばれる)本当のコンポーネントを作成しレギュラーマクロを表します。つまり、マクロの中で定義されたコンポーネントの親としてマクロコンポーネントは作成されます。</para>
<para>複雑なページではレギュラーより、インラインマクロを使うほうが簡単です。例えば、前の例では、<code>rows</code>はマクロコンポーネントではなくて、列のみを受け取るので、レギュラーコンポーネントを使うことはできません。インラインマクロでは、すべてのコンポーネントが同じIDスペースにあるため、アクセスするのはより簡単ですが、名前の衝突を避けなければなりません。</para>
<para>一方、レギュラーマクロスでは、APIを使用することができます。どのレギュラーマクロコンポーネントもIDスペースの所有者です。ですから、名前の衝突はありません。</para><sect2><title>例</title>
<para>
<code>inline.zul</code>: (マクロ定義)</para>
<programlisting>&lt;row&gt;&#13;   &lt;textbox value="${arg.col1}"/&gt;&#13;   &lt;textbox value="${arg.col2}"/&gt;&#13;&lt;/row&gt;&#13;</programlisting>
<para>
<code>useinline.zul</code>: (目標ページ)</para>
<programlisting>&lt;?component name="myrow" macro-uri="inline.zul" inline="true"?&gt;&#13;&lt;window title="Test of inline macros" border="normal"&gt;&#13;   &lt;zscript&gt;&lt;![CDATA[&#13;   import org.zkoss.util.Pair;&#13;   List infos = new LinkedList();&#13;   for (int j = 0; j &lt; 10; ++j) {&#13;      infos.add(new Pair("A" + j, "B" + j));&#13;   }&#13;   ]]&gt;&lt;/zscript&gt;&#13;   &lt;grid&gt;&#13;      &lt;rows&gt;&#13;         &lt;myrow col1="${each.x}" col2="${each.y}" forEach="${infos}"/&gt;&#13;      &lt;/rows&gt;&#13;   &lt;/grid&gt;&#13;&lt;/window&gt;&#13;</programlisting>
</sect2></sect1><sect1><title>レギュラー(標準)マクロ</title>
<para>ZKは前のセクションで説明されたように本当のコンポーネント(マクロコンポーネントと呼ばれる)を作成します。</para>
<para>便宜上、このセクションで話すマクロコンポーネントとは、レギュラーマクロコンポーネントのことを示します。</para><sect2><title>マクロコンポーネントとIDスペース</title>
<para>ウィンドウのように、マクロコンポーネントはIDスペースの所有者です。つまり、マクロコンポーネント(aka.,マクロコンポーネントの子コンポーネント)を実装するページの中で、コンポーネントを識別するどんな識別子も使えます。マクロコンポーネントと同ページ中で定義された他のコンポーネントと衝突することはありません。</para>
<para>例えば、マクロを以下のように定義します。</para>
<programlisting>&lt;hbox&gt;&#13;          Username: &lt;textbox id="who" value="${arg.who}"/&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting>
<para>そうすると、以下のコードは正しく動作します。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;zk&gt;&#13;          &lt;username/&gt;    &#13;          &lt;button id="who"/&gt; &lt;!-- no conflict because it is in a different ID space --&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>しかし、以下のコードは動作しません。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"?&gt;&#13;&lt;username id="who"/&gt;&#13;</programlisting>
<para>どうしてでしょうか？どのIDスペース所有者のように、マクロコンポーネントそれ自体は子コンポーネントと同じIDスペースにあります。代わりの二つの解決方法があります。</para>
<orderedlist>
<listitem>
<para>特別なプレフィックスをマクロコンポーネントの子コンポーネントの識別子に使用します。例えば、”<code>who</code>”の代わりに”<code>ms_who</code>”です。</para>
</listitem>
</orderedlist>
<programlisting>&lt;hbox&gt;&#13;          Username: &lt;textbox id="mc_who" value="${arg.who}"/&gt;    &#13;&lt;/hbox&gt;&#13;</programlisting>
<orderedlist>
<listitem>
<para>ウィンドウコンポーネントを使用して追加IDスペースを作成する。</para>
</listitem>
</orderedlist>
<programlisting>&lt;window&gt;&#13;          &lt;hbox&gt;    &#13;                    Username: &lt;textbox id="who" value="${arg.who}"/&gt;        &#13;          &lt;/hbox&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>適応できるなら、一番目の解決方法はより簡単なのでお勧めします。</para><sect3><title>外部から子コンポーネントと通信</title>
<para>他のIDスペース所有者のように、<code>org.zkoss.zk.ui.Path</code>または<code>getFellow</code>メソッドを使用して、子コンポーネントに通信できます。</para>
<para>例えば、マクロコンポーネントのIDを”<code>username</code>”と呼びます。そして、以下のように<code>textbox</code>に通信できます。</para>
<programlisting>comp.getFellow("username").getFellow("mc_who");&#13;new Path("/username/mc_who");&#13;</programlisting></sect3><sect3><title>親で定義された変数に通信</title>
<para>マクロコンポーネントはインライン拡張のように動作します。このため、他のコンポーネントと同じように、(マクロコンポーネントの) 子コンポーネントは親IDスペースの中で定義された変数と通信できます。</para>
<para>例えば、<code>username</code>の子コンポーネントは直接vと通信できます。</para>
<programlisting>&lt;zscript&gt;&#13;          String v = "something";    &#13;&lt;/zscript&gt;&#13;&lt;username/&gt;&#13;</programlisting>
<para>しかしこの方法では、マクロが使える場面が制限されますので、お勧めしません。</para></sect3><sect3><title>ランタイムで<code>macro-uri</code>を変更</title>
<para>以下のようにマクロURIを動的に変更できます。</para>
<programlisting>&lt;username id="ua"/&gt;&#13;&lt;button onClick="ua.setMacroURI(&amp;quot;another.zul&amp;quot;)"/&gt;&#13;</programlisting></sect3></sect2><sect2><title>メソッドを使う</title>
<para>マクロコンポーネントは<code>org.zkoss.zk.ui.ext.DynamicPropertied</code>インターフェースを実装します。つまり<code>getDynamicProperty</code>メソッドを以下のように使うことでそのプロパティと通信できます。</para>
<programlisting>&lt;username id="ua" who="John"/&gt;&#13;&lt;button label="what?" onClick="alert(ua.getDynamicProperty(&amp;quot;who&amp;quot;))"/&gt;&#13;</programlisting>
<para>明らかに、<code>DynamicPropertied</code>の使用はいい方法ではありません。その上、<code>setDynamicProperty</code>を使用してプロパティを変更しても、マクロの子コンポーネントは変更されません。例えば、以下のコードはまた<code>username</code>としてMaryではなくてJohnを表示します。</para>
<programlisting>&lt;username id="ua" who="John"/&gt;&#13;&lt;zscript&gt;&#13;    ua.setDynamicProperty("who", "Mary");&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>どうしてでしょうか？マクロコンポーネントが作成された時、マクロコンポーネントのすべての子コンポーネントは作成されます。手動で処理しない限り、変更されません。このため、<code>se</code>
<code>tDynamicProperty</code>の起動はマクロコンポーネントの中に保存されたプロパティのみに影響します。<code>Textbox</code>のコンテンツは変更されません。</para>
<para>このため、直接コンポーネントを処理する<code>setWho</code>のようなメソッドを提供したほうがいいです。自分の方法を適用するのに、マクロコンポーネントにクラスを実装し、コンポーネントコマンドの<code>class</code>属性に指定しなければなりません。</para>
<para>【ヒント】：現在のプロパティを使用して子コンポーネントを再作成するのに、<code>recreate</code>メソッドを使用します。このメソッドは、すべての子コンポーネントを切り離し、新たに作成します。</para>
<para>クラスを実装する方法は二つあります。その詳細は以下のセクションで説明されます。</para><sect3><title>Javaで追加のメソッドを提供</title>
<para>マクロコンポーネントに追加メソッドを使用するのに、二つの方法があります。</para>
<orderedlist>
<listitem>
<para><code>zkoss.zk.ui.HtmlMacroComponent</code>クラスを拡張する事でクラスを実装します。</para>
</listitem>
<programlisting>
//Username.java
package mypack;
public class Username extends HtmlMacroComponent {
  public void setWho(String name) {
      setDynamicProperty("who", name); //arg.who requires it
      final Textbox tb = (Textbox)getFellow("mc_who");
      if (tb != null) tb.setValue(name); //correct the child if available
   }
   public String getWho() {
      return (String)getDynamicaProperty("who");>
   }
}</programlisting>

<itemizedlist>
<listitem>
<para>上に説明したように、マクロコンポーネントが子コンポーネントを作成時に使用される<code>${arg.who}</code>は(<code>${arg.who})</code>マクロページ中で参照されるので、<code>setWho</code>の中で<code>setDynamicProperty</code>を呼びださなければなりません。</para>a>
</listitem>
<listitem>
<para><code>setWho</code>メソッドはマクロコンポーネントが子コンポーネントを作成する前に呼び出される可能性もあるので、<code>mc_who</code>が存在しているかどうか確認しなければなりません。 </para>
</listitem>
<listitem>
<para><code>mc_who</code>の<code>setValue</code>が呼び出されたので、コンテンツとクライアントでの視覚表現は<code>setWho</code>が呼び出されたとき自動的に更新されます。</para>
</listitem>
</itemizedlist>
<listitem>
<para>クラス属性を使用してマクロ宣言中でクラスを宣言します。 </para>
</listitem>
</orderedlist>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;    class="mypack.Username"?&gt;&#13;</programlisting></sect3><sect3><title>zscriptで追加メソッドを提供</title>
<para>Javaファイルで実装するのに加えて、<code>zscript</code>でJavaクラスを実装できます。メリットはコンパイル不要と、そのコンテンツを動的に(ウェブアプリケーションを再びデプロイすることなく)変更できることです。デメリットはパフォーマンスが落ちる事と、間違いやすいことです。</para>
<para>ZscriptでJavaクラスを実装するのに、いくつかステップをとります。</para>
<itemizedlist>
<listitem>
<para>例えば、実装するクラスへ<code>/zs/username.zs</code>のような<code>zscript</code>ファイルを準備しなければなりません。同じ<code>zscript</code>ファイルの中で複数のクラスとファンクションを入れることができます。</para>
</listitem>
</itemizedlist>
<programlisting>//username.zs&#13;package mypack;&#13;public class Username extends HtmlMacroComponent {&#13;          public void setWho(String name) {    &#13;                    setDynamicProperty("who", name);        &#13;                    Textbox tb = getFellow("mc_who");        &#13;                    if (tb != null) tb.setValue(name);        &#13;          }    &#13;          public String getWho() {    &#13;                    return getDynamicProperty("who");        &#13;          }    &#13;}&#13;</programlisting>
<itemizedlist>
<listitem>
<para>
<code>init</code>コマンドを使用して、<code>zscript</code>ファイルを読み込みます。そして、コンポーネントを宣言します。</para>
</listitem>
</itemizedlist>
<programlisting>&lt;?init zscript="/zs/username.zs"?&gt;
&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;    class="mypack.Username"?&gt;&#13;</programlisting>
<para>実装クラス(前の例中で<code>mypack.Username</code>)はマクロコンポーネントを本当に使用するのと同じぐらいタイミングで解析されます。そのため、<code>zscript</code>要素を使用して<code>zscript</code>ファイルを処理するのはOKです。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;    class="mypack.Username"?&gt;&#13;&lt;zk&gt;&#13;          &lt;zscript src="/zs/username.zs"/&gt;    &#13;          &lt;username/&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>個人的な意見ですが、<code>init</code>コマンドのほうがわかりやすいと思います。</para></sect3><sect3><title>インストール中に実装クラスをオーバーライド</title>
<para>他のコンポーネントのように、<code>use</code>属性を使用して、マクロコンポーネントを実装するクラスをオーバーライドできす。</para>
<programlisting>&lt;?component name="username" macro-uri="/WEB-INF/macros/username.zul"&#13;    class="mypack.Username?&gt;&#13;&#13;&lt;username use="another.MyAnotherUsername/&gt;&#13;</programlisting>
<para>もちろん、上の例で<code>another.MyAnotherUsername</code>を提供しなければなりません。方法としては、独立したJavaファイルを使用するか、<code>zscript</code>を使用して実装します。</para></sect3><sect3><title>手動でマクロコンポーネントを作成</title>
<para>手動でマクロコンポーネントを作成するのに、以下のようにすべての初期化が終わった後に<code>afterCompose</code>を呼び出さなければなりません。</para>
<programlisting>HtmlMacroComponent ua = (HtmlMacroComponent)&#13;          page.getComponentDefinition("username", false).newInstance(page);    &#13;ua.setParent(wnd);&#13;ua.applyProperties(); //apply properties defined in the component definition&#13;ua.setDynamicProperty("who", "Joe");&#13;ua.afterCompose(); //then the ZUML page is loaded and child components are created&#13;</programlisting>
<para>【メモ】：<code>getComponentDefinition</code>　メソッドはページ中で定義されたコンポーネント定義を探します。</para>
<para>以下はマクロに<code>Username</code>のようなクラスを実装する例です。</para>
<programlisting>Username ua = new Username();&#13;ua.setWho("Joe");&#13;ua.setParent(wnd);&#13;ua.afterCompose();&#13;</programlisting>
<para/></sect3></sect2></sect1></chapter>
<chapter>
<title>10. 上級者のための機能</title>
<para>この章は上級者のため、コンポーネントとページの高度な機能を説明します。</para><sect1><title>ページ認識</title>
<para>一つのデスクトップ上のすべてのページはイベントリスナで通信されます。コンポーネントが存在しているページを取得するのに、<code>org.zkoss.zk.ui.Component</code>インターフェース中の<code>getPage</code>メソッドを使用します。</para>
<para>他のページを参照するのに、探しているページに識別子を指定しなければなりません。</para>
<programlisting>&lt;?page id="another"?&gt;&#13;...&#13;</programlisting>
<para>そして、<code>org.zkoss.zk.ui.Desktop</code>インターフェースの中で以下のように<code>getPage</code>メソッドを使用します。</para>
<programlisting>&lt;zscript&gt;&#13;          Page another = self.getDesktop().getPage("another");    &#13;&lt;/zscript&gt;&#13;</programlisting></sect1><sect1><title>コンポーネント認識</title>
<para>IDスペースによってコンポーネントはグループ化されます。ページそのものが一つのIDスペースです。<code>Window</code>コンポーネントはまた一つのIDスペースです。Pと呼ばれるページを所有している事を想定します、そのページはAというウィンドウを持っています。そしてウィンドウAは子ウィンドウBを持っています。子コンポーネント例えばCをBウィンドウから取得するには以下のコードを書きます。</para>
<programlisting>comp.getDesktop().getPage("P").getFellow("A").getFellow("B").getFellow("C");&#13;</programlisting>
<para>
<code>getFellow</code>メソッドは同IDスペースの中でフェローを取得します。IDスペースのコンセプトについては、第三章のIDスペースセクションを参照してください。</para><sect2><title>コンポーネントパス</title>
<para>ファイルシステム中のパスのように、コンポーネントパスはIDスペースに沿ったコンポーネントのIDチェーンです。上の例ではそのパスは”/A/B/C”です。つまり、ルートパスは現在使用中のページです。別のページを指定するときに、//を使用しなければなりません。つまり、そのパスは//P/A/B/Cになります。</para>
<para>
<code>org.zkoss.zk.ui.Path</code>クラスは<code>java.io.File</code>のように供給されてコンポーネントのパスを単純化します。このため、以下のステートメントは上の例と同様の働きをします。</para>
<programlisting>Path.getComponent("/A/B/C"); //assume the current page is P&#13;Path.getComponent("//P/A/B/C");&#13;</programlisting>
<para>静的なメソッドに加えて、パスインスタンスをインスタンス化することができます。</para>
<programlisting>Path parent = new Path("//P/A");&#13;new Path(parent, "B/C").getComponent();&#13;</programlisting></sect2></sect1><sect1><title>並び替え(ソート)</title>
<para>
<code>org.zkoss.zk.ui.Component</code>インターフェースの<code>getChildren</code>メソッドから返されるリストは動的(ライブ)です。<code>org.zkoss.zul.Listbox</code>インターフェースの<code>getItems</code>や他のメソッドの<code>getItems</code>で返されるリストも同様にライブです。つまりそのコンテンツを直接処理することができます。例えば、以下のステートメントはそのような働きです。</para>
<programlisting>comp.getChildren().remove(0);&#13;((Component)comp.getChildren().get(0)).setParent(null);&#13;</programlisting>
<para>しかし、<code>java.util.Collections</code>クラスの<code>sort</code>メソッドを使用して並び替えることはできません。その理由は、ある子要素を他の位置へ追加するとき、子要素のリストが自動的に元々あった位置から子要素を取り除きます。例えば、以下のステートメントは実際に2番目の子要素を初めの子要素の前に移動します。</para>
<programlisting>comp.getChildren().add(0, comp.getChildren().get(1));&#13;</programlisting>
<para>(LinkedListのように)普通のリストとは違った働きをするので、<code>Collections</code>の<code>sort</code>メソッドは動作しません。</para>
<para>コンポーネントの並べ替えを簡単にするため、子要素リストに使用できる<code>org.zkoss.zk.ui.Components</code>クラスの中の<code>sort</code>メソッドを提供します。</para>
<para>以下の例中で、<code>sort</code>メソッドと<code>org.zkoss.zul.ListitemComparator</code>を使用してリストボックスに並び替え機能をつけます。</para>
<para>ここではリスト項目を使用してソート機能を説明しましたが、リスト項目は実は元々並び替えられます。ZUMLとXULコンポーネントセットの章中でリストボックスセクションのソーティングセクションを参照してください。</para>
<programlisting>&lt;window title="Sort Listbox" border="normal" width="200px"&gt;<inlinegraphic fileref="img/10000000000000D30000009AAB835ED5.png" align="right"/>&#13;          &lt;vbox&gt;    &#13;                    &lt;listbox id="l"&gt;        &#13;                              &lt;listhead&gt;            &#13;                                        &lt;listheader label="name"/&gt;                &#13;                                        &lt;listheader label="gender"/&gt;                &#13;                              &lt;/listhead&gt;            &#13;                              &lt;listitem&gt;            &#13;                                        &lt;listcell label="Mary"/&gt;                &#13;                                        &lt;listcell label="FEMALE"/&gt;                &#13;                              &lt;/listitem&gt;            &#13;                              &lt;listitem&gt;            &#13;                                        &lt;listcell label="John"/&gt;                &#13;                                        &lt;listcell label="MALE"/&gt;                &#13;                              &lt;/listitem&gt;            &#13;                              &lt;listitem&gt;            &#13;                                        &lt;listcell label="Jane"/&gt;                &#13;                                        &lt;listcell label="FEMALE"/&gt;                &#13;                              &lt;/listitem&gt;            &#13;                              &lt;listitem&gt;            &#13;                                        &lt;listcell label="Henry"/&gt;                &#13;                                        &lt;listcell label="MALE"/&gt;                &#13;                              &lt;/listitem&gt;            &#13;                    &lt;/listbox&gt;        &#13;                    &lt;hbox&gt;        &#13;                              &lt;button label="Sort 1" onClick="sort(l, 0)"/&gt;            &#13;                              &lt;button label="Sort 2" onClick="sort(l, 1)"/&gt;            &#13;                    &lt;/hbox&gt;        &#13;          &lt;/vbox&gt;    &#13;          &lt;zscript&gt;    &#13;          void sort(Listbox l, int j) {    &#13;                    Components.sort(l.getItems(), new ListitemComparator(j));        &#13;          }    &#13;          &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting></sect1><sect1><title>ブラウザの情報とコントロール</title>
<para>クライアントについての情報を取得するのに、ルートコンポーネントで<code>onClientInfo</code>イベントにイベントリスナを登録します。<code>org.zkoss.zk.ui.util.Clients</code>クラスを利用すれば、クライアントの動作をコントロールできます。</para><sect2><title>
<code>onClientInfo</code>イベント</title>
<para>アプリケーションはタイムゾーンというようなクライアント情報を知る必要がある場合があります。そのとき、<code>onClientInfo</code>イベントにイベントリスナを追加します。イベントが追加されると、クライアントは<code>org.zkoss.zk.ui.event.ClientInfoEvent</code>クラスのインスタンスを返信します。その返信の内容からクライアントの情報を取得できます。</para>
<programlisting>&lt;grid onClientInfo="onClientInfo(event)"&gt;&#13;   &lt;rows&gt;&#13;      &lt;row&gt;Time Zone &lt;label id="tm"/&gt;&lt;/row&gt;&#13;      &lt;row&gt;Screen &lt;label id="scrn"/&gt;&lt;/row&gt;&#13;   &lt;/rows&gt;&#13;&#13;   &lt;zscript&gt;&#13;   void onClientInfo(ClientInfoEvent evt) {&#13;      tm.setValue(evt.getTimeZone().toString());&#13;      scrn.setValue(&#13;         evt.getScreenWidth()+"x"+evt.getScreenHeight()+"x"+evt.getColorDepth());&#13;   }&#13;   &lt;/zscript&gt;&#13;&lt;/grid&gt;&#13;</programlisting>
<para>【メモ】：<code>onClientInfo</code>イベントはルートコンポーネント(aka.,親コンポーネントがいないコンポーネント)に対してのみ意味があります。</para>
<para>クライアント情報はZKによって保存されることはありません。つまり必要なら、手動で保存しなければなりません。セッションは同じクライアントに関連しているので、セッションの属性中にクライアント情報を保存するのは一つの方法です。</para>
<programlisting>session.setAttribute("px_preferred_time_zone", event.getTimeZone());&#13;</programlisting>
<para>
<code>px_preferred_time_zone</code>と呼ばれるセッションの変数としてタイムゾーンを保存したら、その値はデフォルトのタイムゾーンとして、それ以降使用されます。国際化章中でタイムゾーンセクションを参照してください。</para>
<para>
<code>onClientInfo</code>イベントはページが読み込まれた後(そしてクライアントに送信される)クライアントから送信されます。このため、コンポーネントのデータはタイムゾーンといったクライアント情報しだいなら、以下のようにクライアントにリクエストの再送信をさせなければなりません。</para>
<programlisting>import org.zkoss.util.TimeZones;&#13;...&#13;if (!TimeZones.getCurrent().equals(event.getTimeZone())&#13;          Executions.sendRedirect(null);    &#13;</programlisting></sect2><sect2><title>
<code>org.zkoss.ui.util.Clients </code>クラス</title>
<para>クライアントの視覚表現をコントロールするブラウザウィンドウは<code>org.zkoss.ui.util.Clients</code>に入っています。例えば以下のようにブラウザウィンドウ(aka.,デスクトップ)をスクロールできます。</para>
<programlisting>Clients.scrollBy(100, 0);&#13;</programlisting></sect2><sect2><title>ウィンドウを閉じさせないようにする</title>
<para>ユーザーがウィンドウを閉じたり、または今のURLから離れて他のURLを見たりすることを禁止、もしくは確認させる場合があります。例えば、ユーザーがメールを作成していてまだ保存されていないときです。</para>
<programlisting>if (mail.isDirty()) {&#13;          Clients.confirmClose("Your message has not been sent.\nDiscard your message?");    &#13;} else {&#13;          Clients.confirmClose(null);    &#13;}&#13;</programlisting>
<para>この例では、空ではない文字列で<code>confirmClose</code> メソッドが呼ばれると、ユーザーがブラウザウィンドウを閉じる、ページをリロードする、または他のページに移動するとき、下記の確認ダイアログが表示されます。</para>
<para>
<graphic align="center" fileref="img/100000000000036D000000FE561CE3BC.png">2
			
		</graphic> </para></sect2></sect1><sect1><title>ブラウザの履歴管理</title>
<para>従来の複数ページウェブアプリケーションの中で、ユーザーはたいていBACKとFORWARDボタンを使って、ページ間で移動し、ブックマークします。ZKでは、従来のウェブアプリケーションと同じ方法で、複数ページを使って特徴と情報のセットを表すことができます。</para>
<para>しかし、従来のウェブアプリケーションで、特徴を複数ページで表現するのに対して、ZKでは、たくさんの特徴を一つのデスクトップで表すのが一般的です。ユーザビリティを向上させるため、ZKはブラウザの履歴管理機能を提供しています。それによって、ZKアプリケーションはサーバー側で履歴を簡単に管理できます。</para>
<para>そのコンセプトは簡単です。ブラウザ履歴にデスクトップの適切な状態項目を付き加えます。ユーザーはBACKとFORWARDボタンを使用して同じZKデスクトップの中の異なった状態で移動します。ユーザーがこれらの状態の間で移動するとき、<code>onBookmarkChanged</code>と呼ばれるイベントは送信されてアプリケーションに通知します。</para>
<para>アプリケーションの視点から、ブラウザの履歴を制御するには２つのステップが必要です。</para>
<orderedlist>
<listitem>
<para>デスクトップの適切な状態に対して、ブラウザの履歴に項目を付き加えます。</para>
</listitem>
<listitem>
<para>
<code>onBookmarkChanged</code>イベントを監視して、デスクトップを状況に応じて処理します。</para>
</listitem>
</orderedlist><sect2><title>適切な状態をブラウザの履歴へ付き加え</title>
<para>アプリケーションはブラウザ履歴に付加する適切な状態が何かを決めなければなりません。たとえば、ステップ・バイ・ステップで完成する操作では、それぞれのステップが一つの状態としてブラウザの履歴に付き加えるのがいいかもしれません。これによって、ユーザーはこれらの状態を飛び越したり、ブックマークしたりすることができます。</para>
<para>ブラウザの履歴に状態を付加するタイミングを決めたら、必要なときは<code>org.zkoss.zk.ui.Desktop</code>インターフェースの<code>setBookmark</code>メソッドを呼び出すだけでOKです。ブラウザの履歴に状態を追加することは<code>bookmarking</code>と呼びます。ユーザーがブラウザに追加したブックマーク(インターネットエクスプローラのお気に入り)とは違います。</para>
<para>【ヒント】：クライアント側のブックマークと比較して、サーバー側で状態を追加するのをサーバーのブックマークと呼ばれます。</para>
<para>例えば、Nextボタンをクリックした時、状態をブックマークすることを想定して、以下のように書きます。</para>
<programlisting>&lt;button label="Next" onClick="desktop.setBookmark(&amp;quot;Step-2&amp;quot;)"/&gt;&#13;</programlisting>
<para>URLをきちんと見たら、ZKは<code>#Step-2</code>をURLに付き加えたことがわかります。</para>
<para>
<graphic align="center" fileref="img/1000000000000284000000226A7DEE65.png">2
			
		</graphic>BACKボタンを押したら、URLは以下になります。</para></sect2><sect2><title>
<code>onBookmarkChanged</code>イベントの監視とデスクトップの処理</title>
<para>ブラウザ履歴へ状態を付加したら、ユーザーはBACKボタンを押すといったことでこれらの状態の中で切り替えられます。状態が変更されたら、ZKはデスクトップの中のすべてのルートコンポーネントに<code>onBookmarChanged</code>
<graphic align="center" fileref="img/100000000000027B0000001CA1C78D7E.png">2
			
		</graphic>イベント(<code>org.zkoss.zk.ui.event.BookmarkEvent</code>クラスのインスタンス)をブロードキャストし、アプリケーションに通知します。</para>
<para>従来の複数ページのウェブアプリケーションとは違って、状態が変更されたら、ZKデスクトップを手動で処理しなければなりません。デスクトップを処理して、ブックマークをあらわす状態に反映させるのはアプリケーション開発者の仕事です。</para>
<para>
<code>onBookmarkChanged</code>イベントを監視するには、デスクトップのページにイベント付加するか、ルートコンポーネントに付加します。</para>
<programlisting>&lt;window onBookmarkChanged="goto(event.bookmark)"&gt;&#13;          &lt;zscript&gt;    &#13;          void goto(String bookmark) {    &#13;                    if ("Step-2".equals(bookmark)) {        &#13;                              ...//create components for Step 2            &#13;                    } else { //empty bookmark        &#13;                              ...//create components for Step 1            &#13;                    }        &#13;          &lt;/zscript&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>他のイベントを操作するように、<code>onBookmarkChanged</code>イベントを受け取るとき、デスクトップを自由に処理できます。最も一般的な方法は、<code>org.zkoss.zk.ui.Executions </code>クラスの<code>createComponents </code>メソッドを使用することです。つまり、それぞれのページをそれぞれのZUMLページで表現することができます。そして、<code>creatComponents</code>を使用して、<code>onBookmarkChanged</code>を受け取るとき、すべてのコンポーネントを作成します。</para>
<programlisting>if ("Step-2".equals(bookmark)) {&#13;          //1. Remove components, if any, representing the previous state    &#13;          try {    &#13;                    self.getFellow("replacable").detach();        &#13;          } catch (ComponentNotFoundException ex) {    &#13;                    //not created yet        &#13;          }    &#13;&#13;          //2. Creates components belonging to Step 2    &#13;          Executions.createComponents("/bk/step2.zul", self, null);    &#13;}&#13;</programlisting></sect2><sect2><title>簡単な例</title>
<para>この例では、それぞれのタブ選択をブックマークします。</para>
<programlisting>&lt;window id="wnd" title="Bookmark Demo" width="400px" border="normal"&gt;&#13;   &lt;zscript&gt;&#13;   page.addEventListener("onBookmarkChanged",&#13;      new EventListener() {&#13;         public void onEvent(Event event) throws UiException {&#13;            try {&#13;               wnd.getFellow(wnd.desktop.bookmark).setSelected(true);&#13;            } catch (ComponentNotFoundException ex) {&#13;               tab1.setSelected(true);&#13;            }&#13;         }&#13;      });&#13;   &lt;/zscript&gt;&#13;&#13;   &lt;tabbox id="tbox" width="100%" onSelect="desktop.bookmark = self.selectedTab.id"&gt;&#13;      &lt;tabs&gt;&#13;         &lt;tab id="tab1" label="Tab 1"/&gt;&#13;         &lt;tab id="tab2" label="Tab 2"/&gt;&#13;         &lt;tab id="tab3" label="Tab 3"/&gt;&#13;      &lt;/tabs&gt;&#13;      &lt;tabpanels&gt;&#13;         &lt;tabpanel&gt;This is panel 1&lt;/tabpanel&gt;&#13;         &lt;tabpanel&gt;This is panel 2&lt;/tabpanel&gt;&#13;         &lt;tabpanel&gt;This is panel 3&lt;/tabpanel&gt;&#13;      &lt;/tabpanels&gt;&#13;   &lt;/tabbox&gt;&#13;&lt;/window&gt;&#13;</programlisting>
</sect2></sect1><sect1><title>コンポーネント複製</title>
<para>すべてのコンポーネントは複製できます。つまり、<code>java.lang.Clonable</code>で実装されています。このため、以下のように、コンポーネントを簡単に複製できます。</para>
<programlisting>&lt;vbox id="vb"&gt;&#13;   &lt;listbox id="src" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem value="A"&gt;&#13;         &lt;listcell label="A. Graduate"/&gt;&#13;         &lt;listcell label="20%"/&gt;&#13;     &lt;/listitem&gt;&#13;      &lt;listitem value="B"&gt;&#13;         &lt;listcell label="B. College"/&gt;&#13;         &lt;listcell label="23%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem value="C"&gt;&#13;         &lt;listcell label="C. High School"/&gt;&#13;         &lt;listcell label="40%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;&#13;   &lt;zscript&gt;&#13;   int cnt = 0;&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Clone"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;     Listbox l = src.clone();&#13;      l.setId("dst" + ++cnt);&#13;      vb.insertBefore(l, self);&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/vbox&gt;&#13;</programlisting>
<itemizedlist>
<listitem>
<para>コンポーネントが複製されると、子コンポーネントも複製されます。</para>
</listitem>
<listitem>
<para>複製されたコンポーネントはどのページと親コンポーネントにも属しません。つまり、<code>src.clone().getParent()</code>は<code>null</code>を返します。</para>
</listitem>
<listitem>
<para>IDは変化しません。つまり、同じIDスペースで使用するなら、IDを変えることを忘れないように。</para>
</listitem>
</itemizedlist></sect1><sect1><title>コンポーネントの直列化 </title>
<para>すべてのコンポーネントは直列化(serialize)できます。つまり、コンポーネントを直列化してメモリまたはほかのレジスターに送ることができます。そして、後に直列化復元をします。複製のように、直列化復元したコンポーネントは他のページ(デスクトップ)に属しません。直列化したものにも依存しません。下に示したように、直列化は複製機能を実装する時にも使えます。</para>
<programlisting>&lt;vbox id="vb"&gt;&#13;   &lt;listbox id="src" multiple="true" width="200px"&gt;&#13;      &lt;listhead&gt;&#13;         &lt;listheader label="Population"/&gt;&#13;         &lt;listheader align="right" label="%"/&gt;&#13;      &lt;/listhead&gt;&#13;      &lt;listitem value="A"&gt;&#13;         &lt;listcell label="A. Graduate"/&gt;&#13;         &lt;listcell label="20%"/&gt;&#13;         &lt;/listitem&gt;&#13;      &lt;listitem value="B"&gt;&#13;         &lt;listcell label="B. College"/&gt;&#13;         &lt;listcell label="23%"/&gt;&#13;      &lt;/listitem&gt;&#13;      &lt;listitem value="C"&gt;&#13;         &lt;listcell label="C. High School"/&gt;&#13;         &lt;listcell label="40%"/&gt;&#13;      &lt;/listitem&gt;&#13;   &lt;/listbox&gt;&#13;&#13;   &lt;zscript&gt;&#13;   int cnt = 0;&#13;   &lt;/zscript&gt;&#13;   &lt;button label="Clone"&gt;&#13;      &lt;attribute name="onClick"&gt;&#13;      import java.io.*;&#13;      ByteArrayOutputStream boa = new ByteArrayOutputStream();&#13;      new ObjectOutputStream(boa).writeObject(src);&#13;      Listbox l = new ObjectInputStream(&#13;         new ByteArrayInputStream(boa.toByteArray())).readObject();&#13;      l.setId("dst" + ++cnt);&#13;      vb.insertBefore(l, self);&#13;      &lt;/attribute&gt;&#13;   &lt;/button&gt;&#13;&lt;/vbox&gt;&#13;</programlisting>
<para>もちろん、<code>clone</code>メソッドで複製するのはよりよいパフォーマンスがあります。一方、直列化は異なった機械間でも使えます。</para><sect2><title>直列化可能なセッション</title>
<para>デフォルトでは、直列化していない実装は(<code>org.zkoss.zk.ui.Session)</code>セッションを表します。直列化していない実装を使用することの利点は、開発者はコンポーネントの中に保存された値が、例えば、<code>listitem</code>の <code>setValue</code>といった値が直列化されているかどうかを心配する必要がないことです。</para>
<para>しかしながら、コンポーネントの中で、保存されたすべての値が直列化できると確認できたら、直列化ズ実装を使用して、セッションを表現することもできます。</para>
<para>直列化実装を使用できるように設定するには、<code>WEB-INF/zk.xml</code>の中の<code>ui-factory-class</code>要素を設定しなければなりません。より詳しくは開発用リファレンス中のAppendix Bを参照してください。</para></sect2><sect2><title>直列化リスナ</title>
<para>コンポーネント、ページ、デスクトップ、セッションの中に保存された属性、値、リスナは直列化可能ならば、直列化されます。(それらに対応するコンポーネント、ページ、デスクトップ、セッションも)</para>
<para>直列化可能なオブジェクトの実装を簡単にするのに、特別なインターフェースが実装された場合、ZKは直列化する前と直列化復元した後に、直列化リスナを呼び出します。例えば、コンポーネントに対して、以下のようにイベントリスナを実装できます。</para>
<programlisting>public MyListener&#13;implements EventListener, java.io.Serializable, ComponentSerializationListener {&#13;          private transient Component _target; //no need to serialize it    &#13;&#13;          //ComponentSerializationListener//    &#13;          public willSerialize(Component comp) {    &#13;          }    &#13;          public didDeserialize(Component comp) {    &#13;                    _target = comp; //restore it back        &#13;          }    &#13;}&#13;</programlisting>
<para>
<code>org.zkoss.zk.ui.util.ComponentSerializationListener</code>インターフェースはコンポーネントを直列化するときに使用されます。同様に<code>PageSerializationListener</code>、　<code>DesktopSerializationListener</code>、　<code>SessionSerializationListener</code>はページ、セッションそれぞれを直列化するときに使用されます。</para></sect2></sect1><sect1><title>ページ間における通信</title>
<para>同デスクトップの中でページ間の通信は簡単です。一つ目の方法は、イベントを使用してそれぞれのページに通知します。二つ目に、属性を使用して、データを共有します。</para><sect2><title>イベントをポストする、または送信する</title>
<para>同デスクトップの中で別のページに通信することができます。通信する方法は<code>postEvent</code>、または、<code>sendEvent</code>を使用して目標のページのコンポーネントに通知します。</para>
<programlisting>Events.postEvent(new Event("SomethingHappens",&#13;          comp.getDesktop().getPage("another").getFellow("main"));    &#13;</programlisting></sect2><sect2><title>属性</title>
<para>どのページも、コンポーネントも、セッションも、デスクトップも、ウェブアプリケーションも、属性の独立したマップを持っています。つまり、コンポーネント間、ページ間、デスクトップ間、イベントセッション間でデータを共有するのは簡単です。</para>
<para>
<code>z</code>
<code>script</code>とEL表記では<code>implicit</code>オブジェクト: <code>componentScope</code>
<code>・　</code>
<code>pageScope</code>
<code>・　</code>
<code>desktopScope</code>
<code>・　</code>
<code>　</code>
<code>sessionScope</code>
<code>・　</code>
<code>requestScope</code>
<code>・</code>
<code>　</code>
<code>applicationoScope</code>を使用します。</para>
<para>Javaクラスの中で、対応するクラスので属性依存(attribute-relevant)メソッドを使用して通信することができます。scope argumentを使用して、どの領域に通信するかを決められます。以下の二つのステートメントは同様です。Compはコンポーネントであることを想定します。</para>
<programlisting>comp.getAttribute("some", comp.DESKTOP_SCOPE);&#13;comp.getDesktop().getAttribute("some");&#13;</programlisting></sect2></sect1><sect1><title>ウェブアプリ間における通信</title>
<para>一つのEARファイルは複数のWARファイルに対応する可能性があります。EAR、WARのそれぞれはウェブアプリケーションです。二つのウェブアプリケーション間で通信する標準的な方法はありません。</para>
<para>しかしながら、ZKは他のウェブアプリケーションからのリソースを参照する方法を提供しています。例えば、app2といったアプリケーションから<code>/foreign.zul</code>といったリソースを挿入することを想定したら、以下のように書きます。</para>
<programlisting>&lt;include src="~app2/foreign.zul"/&gt;&#13;</programlisting>
<para>同様に、他のウェブアプリケーションからスタイルシートを参照できます。</para>
<programlisting>&lt;style src="~app2/foreign.css"/&gt;&#13;</programlisting>
<para>【ヒント】： 他のウェブアプリケーション中におかれているリソースに通信できるかどうかはウェブサーバーの設定によります。例えば、Tomcat を使用する場合は、<code>conf/context.xml</code>の中で<code>crossContext=”true”</code>を指定しなければなりません。</para><sect2><title>クラスパスから取得するウェブリソース</title>
<para>ZKでは、クラスパスで指定できるリソースを参照することができます。その利点はウェブリソースを一つのJARファイルに埋め込むことができ、デプロイを簡単化にできます。</para>
<programlisting>&lt;img src="~./my/jar.gif"/&gt;&#13;</programlisting>
<para>そして、ZKは、クラスパスを利用して、<code>/web</code>ディレクトリーでリソース<code>/my/jar.gif</code>を検索します。</para></sect2></sect1><sect1><title>アノテーション</title>
<para>アノテーション(注釈)はコンポーネント自身の一部分ではない、あるコンポーネントについてのデータを提供します。それらがアノテート(注釈を付加)されるコンポーネントの操作に直接影響しません。アノテーションは主にランタイムで検査するツールまたはマネージャーによって使用されます。アノテーションのコンテンツと意味は開発者が使用するマネージャーまたはツールによる異なります。例えば、データバイディングマネージャーはアノテーションを検査して、コンポーネントが保存さするデータソースを確認します。</para><sect2><title>ZUMLページに注釈をつける(アノテート)</title>
<para>アノテーションはZUMLページの中のコンポーネントとプロパティの宣言に使用できます。それらに注釈をつける方法は二つあります。従来の方法と簡単な方法です。どちらを使うかはプログラマーの好みです。また、それらを一緒に使用することもできます。</para><sect3><title>コンポーネントの宣言に注釈をつける従来の方法</title>
<para>アノテーションはアノテートしたい(注釈をつけたい)要素の宣言の前にあります。</para>
<programlisting>&lt;window xmlns:a="http://www.zkoss.org/2005/zk/annotation"&gt;&#13;          &lt;vbox&gt;    &#13;                    &lt;a:author name="John Magic" date="3/17/2006"/&gt;        &#13;                    &lt;listbox&gt;        &#13;                    &lt;/listbox&gt;        &#13;...&#13;</programlisting>
<para>
アノテーションは<code>http://www.zkoss.org/2005/znnotation</code>
ネーム空間の中の要素です。要素名と属性はプログラマーが使うツールによって何にでもなります。一つのコンポーネント宣言に複数のアノテーションで注釈をつけることができます。</para>
<programlisting>&lt;a:author name="John Magic"/&gt;&#13;&lt;a:editor name="Mary White" date="4/11/2006"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>ここでは、作者(author)と編集者(editor)がアノテーションの名前で、名前と日付が要素名です。つまり、アノテーションは名前と要素のマップから成り立っています。</para>
<para>宣言をアノテートしているアノテーションは同じ名前を持っている場合、合併することができます。たとえば、</para>
<programlisting>&lt;a:define var1="auto"/&gt;&#13;&lt;a:define var2="123"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>上は下と同様の働きをします。</para>
<programlisting>&lt;a:define var1="auto" var2="123"/&gt;&#13;&lt;listbox/&gt;&#13;</programlisting>
<para>【メモ】： EL表記はここでは使えません。</para></sect3><sect3><title>プロパティ宣言に注釈をつける従来の方法 </title>
<para>プロパティ宣言に注釈をつけるには、アノテーションを以下に示すようにプロパティの宣言の前におきます。</para>
<programlisting>&lt;listitem a:bind="datasource='author',name='name'" value="${author.name}"/&gt;&#13;</programlisting>
<para>また、attribute要素を使用して、コンポーネント宣言と同様の形で、プロパティの宣言に注釈をつけることもできます。つまり、上のアノテーションは以下と同様の働きをします。</para>
<programlisting>&lt;listitem&gt;&#13;                &lt;a:bind datasource="author" name="name"/&gt;    &#13;                &lt;attribute name="value"&gt;${author.name}&lt;/attribute&gt;    &#13;&lt;/listitem&gt;&#13;</programlisting>
<para>【メモ】：アノテーションの属性名が省略される場合、その名前は<code>value</code>と想定されます。たとえば、</para>
<programlisting>&lt;listitem a:bind="value='selected'" value=""/&gt;&#13;</programlisting>
<para>上は以下と同様です。</para>
<programlisting>&lt;listitem a:bind="selected" value=""/&gt;&#13;</programlisting></sect3><sect3><title>プロパティ宣言に注釈をつける簡単な方法</title>
<para>上に説明したように、XMLネーム空間を使用して注釈をつけるのほかに、もう一つプロパティに注釈をつける簡単な方法があります。以下に示すように、注釈をつけるプロパティにアノテーション表記を使用して値を指定します。</para>
<programlisting>&lt;listitem label="@{bind(datasource='author',selected)}"/&gt;&#13;</programlisting>
<para>アノテーションのフォーマットは<code>@{annot-name(attr-name1=attr-value1,attr-name2=attr-value2)}</code>です。つまり、プロパティの値がアノテーション表記になっていたら、それは対応するプロパティの値として認識されるのではなく、アノテーションとして認識されます。上の例では、<code>bind</code>と呼ばれるアノテーションは<code>label</code>プロパティに注釈をつけます。こうして、上の例は以下と同じ働きをします。</para>
<programlisting>&lt;listitem a:bind=" datasource='author',selected" label=""/&gt;&#13;</programlisting>
<para>アノテーション名が指定されてない場合、名前は<code> </code>
<code>default </code>とみなされます。例えば、以下のコードは<code>default</code>の名前のついたアノテーションを使って<code>label</code>に注釈をつけます。そのアノテーションはひとつの属性を持っていて、その値と名前はそれぞれ<code>value</code>と<code>selected.name</code>です。</para>
<programlisting>&lt;listitem label="@{selected.name}"/&gt;&#13;</programlisting>
<para>つまり、上は以下のコードと同様です。</para>
<programlisting>&lt;listitem label="@{default(value='selected.name')}"/&gt;&#13;</programlisting>
<para>【メモ】：以下に示すように、複数のアノテーションを使って一つのプロパティに注釈をつけられます。</para>
<programlisting>&lt;listitem label="@{ann1(selected.name) ann2(attr2a='attr2a',attr2b)}"/&gt;&#13;</programlisting></sect3><sect3><title>コンポーネント宣言に注釈をつける簡単な方法</title>
<para>同様に、以下のように<code>self</code>と呼ばれる指定された属性にアノテーション表記を指定することで、コンポーネントに注釈をつけることできます。</para>
<programlisting>&lt;listitem self="${bind(each=person)}"/&gt;&#13;</programlisting>
<para>
<code>self</code>は一つのプロパティではなく、コンポーネント宣言に注釈をつけるアノテーションを示すキーワードです。以下と同様の働きをします。</para>
<programlisting>&lt;a:bind each="person"/&gt;&#13;&lt;listitem/&gt;&#13;</programlisting></sect3></sect2><sect2><title>手動で作成されたコンポーネントに注釈をつける</title>
<para>
<code>org.zkoss.zk.ui.sys.ComponentCtrl</code>インターフェースの<code>addAnnotation</code>メソッドを使用することで、ランタイムでコンポーネントに注釈をつけられます。</para>
<programlisting>Listbox listbox = new Listbox();&#13;listbox.addAnnotation("some", null);&#13;</programlisting></sect2><sect2><title>アノテーションを取得</title>
<para>ランタイムでアノテーションを取得することができます。それらはアプリケーションよりも、データバインディングマネージャーのようなツールで取得されます。つまり、アプリケーションはZUMLページに注釈をつけて、ツールにコンポーネントを操作する方法を教えます。 </para>
<para>以下は、コンポーネントのアノテーションをリストアップする例です。</para>
<programlisting>void dump(StringBuffer sb, Component comp) {&#13;      ComponentCtrl compCtrl = (ComponentCtrl)comp;&#13;          sb.append(comp.getId()).append(": ")    &#13;               .append(compCtrl .getAnnotations()).append('\n');    &#13;&#13;          for (Iterator it = compCtrl.getAnnotatedProperties().iterator(); it.hasNext();) {    &#13;                    String prop = it.next();        &#13;                    sb.append(" with ").append(prop).append(": ")        &#13;                              .append(compCtrl .getAnnotations(prop)).append('\n');            &#13;          }    &#13;}&#13;</programlisting></sect2></sect1><sect1><title>リッチレット</title>
<para>リッチレットはユーザー要求に応じて、必要なコンポーネントを作成する小さなJavaプログラムです。</para>
<para>ユーザーがURLを打つと、ZKローダーは指定されたURLのリソースがZUMLページかリッチレットかを確認します。ZUMLページである場合、ZKローダーは前の章で説明したように、ZUMLページのコンテンツに基づいて、自動的にコンポーネントを作成します。</para>
<para>リソースがリッチレットの場合、ZKローダーが処理をリッチレットに任せます。どのようなコンポーネントをどのように作成するかはすべてリッチレットが決めます。つまり、開発者はプログラム的に必要となるコンポーネントをすべて作成しなければなりません。</para>
<para>ZUMLページかリッチレットかを選ぶのはプログラマーしだいです。ほとんどのプログラマーはZUMLページにします。その理由はZUMLページのほうが簡単でわかりやすいです。</para>
<para>リッチレットを実装するのは簡単です。はじめに<code>org.zkoss.zk.ui.Richlet</code>インターフェースを実装して、そしてURLでリッチレットの関係を宣言します。</para><sect2><title>
<code>org.zkoss.zk.ui.Richlet</code>インターフェースの実装</title>
<para>リッチレットは<code>org.zkoss.zk.ui.Richlet</code>インターフェースを実装しなければなりません。<code>org.zkoss.zk.ui.GenericRichlet</code>クラスを拡張することで、メソッドを実装する影響を最小にすることができます。こうして、指定されたURLが要求されたとき、<code>service</code>メソッドが呼ばれ、ユーザーインターフェースを作成できます。</para>
<programlisting>package org.zkoss.zkdemo;import org.zkoss.zk.ui.Page;import org.zkoss.zk.ui.GenericRichlet;import org.zkoss.zk.ui.event.*;import org.zkoss.zul.*;public class TestRichlet extends GenericRichlet {      //Richlet//      public void service(Page page) {            page.setTitle("Richlet Test");            final Window w = new Window("Richlet Test", "normal", false);            new Label("Hello World!").setParent(w);            final Label l = new Label();            l.setParent(w);            final Button b = new Button("Change");            b.addEventListener(Events.ON_CLICK,                  new EventListener() {                        int count;                        public void onEvent(Event evt) {                              l.setValue("" + ++count);                        }                  });            b.setParent(w);            w.setPage(page);      }}                                                                                                                                                                                &#13;</programlisting>
<para>サーブレットのように、<code>init</code>と<code>destroy</code>メソッドを実装して、リッチレットが読み込まれるとき、初期化、または破棄できます。サーブレットのように、リッチレットは一度だけ読み込まれて、関係しているURLにすべての要求を提供します。</para><sect3><title>URLごとのリッチレット</title>
<para>サーブレットのように、リッチレットは作成されて、同じURLに共有されます。つまり、サーブレット(少なくとも<code>service</code>メソッドは)はthread-safeでなければなりません。一方、コンポーネントは共有できません。どのデスクトップも独立したコンポーネントのセットを持ちます。そのため、ほとんどの場合では、リッチレットのデータメンバーとして、コンポーネントを保存するのはいい方法ではありません。</para>
<para>この問題を解決するのに多くの方法があります。代表的な例は以下に示すように、一つのデスクトップに一つのクラスを使用してコンポーネントを保存します。</para>
<programlisting>class MyApp { //one per desktop&#13;          Window _main;    &#13;          MyApp(Page page) {    &#13;                    _main = new Window();        &#13;                    _main.setPage(page);        &#13;          }    &#13;}&#13;&#13;class MyRichlet extends GenericRichlet {&#13;          public void service(Page page) {    &#13;                    new MyApp(page); //create and forget        &#13;          }    &#13;}&#13;</programlisting></sect3></sect2><sect2><title>
<code>web.xml</code>と<code>zk.xml</code>を設定</title>
<para>リッチレットの実装後、以下のステートメントを使用した<code>zk.xmlの</code>中でリッチレットを定義します。</para>
<programlisting>&lt;richlet&gt;&#13;   &lt;richlet-name&gt;Test&lt;/richlet-name&gt;&#13;   &lt;richlet-class&gt;org.zkoss.zkdemo.TestRichlet&lt;/richlet-class&gt;&#13;&lt;/richlet&gt;&#13;</programlisting>
<para>リッチレットを宣言すると、以下に示すように、<code>richlet-mapping</code>を使用して、リッチレットをいくつものURLにマッピングできます。</para>
<programlisting>&lt;richlet-mapping&gt;&#13;          &lt;richlet-name&gt;Test&lt;/richlet-name&gt;    &#13;          &lt;url-pattern&gt;/test&lt;/url-pattern&gt;    &#13;&lt;/richlet-mapping&gt;&#13;&lt;richlet-mapping&gt;&#13;          &lt;richlet-name&gt;Test&lt;/richlet-name&gt;    &#13;          &lt;url-pattern&gt;/some/more/*&lt;/url-pattern&gt;    &#13;&lt;/richlet-mapping&gt;&#13;</programlisting>
<para>デフォルトではリッチレットは使用できません。リッチレットを使用可能にするには、<code>web.xml</code>に以下の宣言を追加しなければなりません。使用可能にした後、<code>web.xml</code>を変更しないで、リッチレットを追加することができます。</para>
<programlisting>&lt;servlet-mapping&gt;&#13;   &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;   &lt;url-pattern&gt;/zk/*&lt;/url-pattern&gt;&#13;&lt;/servlet-mapping&gt;&#13;</programlisting>
<para>そして、<code>http://localhost/zk/test</code>にアクセスし、リッチレットを参照できます。</para>
<para>
<code>url-pattern</code>要素中で指定されたURLは<code>/</code>で始まります。URIの最後は<code>/*</code>になっている場合は、同じプレフィックスのすべてのリクエストに一致します。本当のリクエストを取得するには、現在のページの<code>getRequestP_ath</code>メソッドが返した値をチェックします。</para>
<programlisting>public void service(Page page) {&#13;          if ("/some/more/hi".equals(page.getRequestPath()) {    &#13;                    ...        &#13;          }}    &#13;</programlisting>
<para>【ヒント】：<code>url-pattern</code>に<code>/*</code>を指定することで、マッピングされたリッチレットにすべてのURLをマップできます。</para></sect2></sect1><sect1><title>セッションタイムアウト管理</title>
<para>セッションがタイムアウトになった後、デスクトップに属しているすべてのものは取り除かれます。ユーザーがもう取り除かれてしまったデスクトップに通信しようとする場合は、ユーザーに知らせるためにブラウザでエラーメッセージが表示されます。</para>
<para>エラーメッセージをポップアップするほか、もう一度ユーザーにログインさせたり、ほかのページに行かせたり(転送)する場合があります。タイムアウトになったときにURIの転送先は<code>WEB-INF</code> ディレクトリーの<code>zk.xml</code> ファイルで設定します。例えば、転送先のURLが<code>/timeout.zul</code>でしたら、以下のステートメントを<code>zk.xml</code>に追加します。</para>
<programlisting>&lt;device-config&gt;&#13;   &lt;device-type&gt;ajax&lt;/device-type&gt;&#13;   &lt;timeout-uri&gt;/timeout.zul&lt;/timeout-uri&gt;&#13;&lt;/device-config&gt;&#13;</programlisting>
<para>【ヒント】：どのデバイスもひとつのタイムアウトURIに対応します。より詳しくは開発用リファレンス中のAppendix Bを参照ください。 </para>
<para>zk.xmlに加えて、以下のように手動で転送先のURLを指定できます。</para>
<programlisting>Devices.setTimeoutURI("ajax", "/timeout.zul");&#13;</programlisting>
<para>【デバイスについて】：デバイスはクライアントデバイスを意味しています。どのデスクトップもひとつのデバイスに対応します。また逆も同じです。</para>
<para>ほかのURLに転送するのではなく、ページを再び読み込ませる場合は、以下のように空のURLを指定します。</para>
<programlisting>&lt;device-config&gt;&#13;   &lt;device-type&gt;ajax&lt;/device-type&gt;&#13;   &lt;timeout-uri&gt;&lt;/timeout-uri&gt;&#13;&lt;/device-config&gt;&#13;</programlisting>
</sect1><sect1><title>エラー処理</title>
<para>ZKウェブアプリケーションはどのようにエラーを処理するのかを指定できます。エラーはアプリケーションに処理できない例外によって起きます。</para>
<para>例外は二つの状況で起きます<footnote>
<para>コンポーネントのライフサイクル章をご覧ください</para>
</footnote>：ページ読み込み中とページ更新中です。</para><sect2><title>ページ読み込み中のエラー処理</title>
<para>ZUMLページ読み込み中に処理できない例外が起こった場合、ウェブサーバーによって、直接処理されます。つまり、JSPといったほかのページを処理するのと何も変わりません。</para>
<para>デフォルトでは、ウェブサーバーはエラーメッセージとそのトレースを表示します。</para>
<para>
<graphic align="center" fileref="img/100000000000038700000181C7DBF256.png">2
			
		</graphic>以下のように<code>INF/web.xml</code>の中でエラーページを指定することで、エラー処理をカスタマイズできます。より詳しくはJava Servlet Specificaiton を参照ください。</para>
<programlisting>&lt;!-- web.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>ページ読み込み中にエラーが発生したら、ウェブサーバーはプログラマーが指定したエラーページ<code>/error/error.zu</code>lに転送します。転送するときに、ウェブサーバーはリクエスト属性を送信し、何が起こったかを表示します。属性は以下のようです。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>要求属性</para>
</entry>
<entry>
<para>種類</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>javax.servlet.error.status_code</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Integer</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.exception_type</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Class</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.message</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.String</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.exception</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Throwable</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.request_uri</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.String</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.servlet_name</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.String</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>これらの属性を使用して、エラーページをカスタマイズすることができます。例えば、</para>
<programlisting>&lt;window title="Error ${requestScope['javax.servlet.error.status_code']}"&gt;&#13;          Cause: ${requestScope['javax.servlet.error.message']}    &#13;&lt;/window&gt;&#13;</programlisting>
<para>【ヒント】：エラーページはどんなサーブレットにでもなることができます。ZULのほかに、JSPまたは他のお好みのものを何でも使用できます。</para>
<para>【ヒント】：転送した後、エラーページは主なページとして表示されます。つまり、プログラマーはモーダルを指定したり、メインウィンドウにオーバーラップさせたりする必要はありません。</para><sect3><title>ZK Mobileのエラー処理</title>
<para>サーブレット２.x (web.xml)はデバイスタイプというコンセプトを持っていません。このため、Ajax用ブラウザとモバイルデバイスを同じサーバー上で使用するには、ページを転送しなければなりません。これはひとつの例です。</para>
<programlisting>//error.zul&#13;&lt;zk&gt;&#13;          &lt;zscript&gt;    &#13;          if (Executions.getCurrent().isMilDevice())    &#13;                    Executions.forward("error.mil");        &#13;          &lt;/zscript&gt;    &#13;          &lt;window&gt;    &#13;          ....error message in ZUL    &#13;          &lt;/window&gt;    &#13;&lt;/zk&gt;&#13;</programlisting></sect3></sect2><sect2><title>ページ更新中のエラー処理</title>
<para>ZUMLページ(aka.,イベントリスナ実行中)を更新しているとき、例外が発生した場合、その例外はZKアップデートエンジンによって処理されます。デフォルトでは、ただ単純に警告ボックスを表示して、ユーザーに警告します。</para>
<para>
<graphic align="center" fileref="img/10000000000002C10000011E30DFBEA1.png">2
			
		</graphic>以下のように、<code>WEB-INF/zk.xml</code>の中でエラーページを指定することで、エラー処理をカスタマイズできます。より詳しくは開発用リファレンス中のAppendix Bを参照してください。</para>
<programlisting>&lt;!-- zk.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>イベントリスナの中でエラーが発生したら、ZKアップデートエンジンはプログラマーが指定したエラーページ,<code>/error/error.zul</code>で、ダイアログを作成します。</para>
<para>ZUMLページを読み込み中のエラー処理のように、一つ以上の<code>&lt;error-page&gt;</code>要素を指定できます。そのどれも異なった例外のタイプ(<code>&lt;exception-type&gt;</code>要素の値)に関連しています。エラーが発生したとき、ZKは対応する例外タイプが見つかるまで、エラーページを一つ一つ探します。</para>
<para>さらに、ZKはリクエスト属性のセットをエラーページに送信して、何が起こったかを表示します。これらの属性は以下のようです。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>要求属性</para>
</entry>
<entry>
<para>種類</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>javax.servlet.error.exception_type</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Class</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.message</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.String</code>
</para>
</entry>
</row>
<row>
<entry>
<para>
<code>javax.servlet.error.exception</code>
</para>
</entry>
<entry>
<para>
<code>java.lang.Throwable</code>
</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>以下はエラーページの一つの例です。</para>
<programlisting>&lt;window title="Error ${requestScope['javax.servlet.error.status_code']}"&#13;width="400px" border="normal" mode="modal"&gt;&#13;   &lt;vbox&gt;&#13;   KillerApp encounters a fatal error, ${requestScope['javax.servlet.error.message']}.&#13;The error is recorded and we will look at it and fix it soon.&#13;          &lt;hbox style="margin-left:auto; margin-right:auto"&gt;&#13;         &lt;button label="Continue" onClick="spaceOwner.detach()"/&gt;&#13;         &lt;button label="Reload" onClick="Executions.sendRedirect(null)"/&gt;&#13;      &lt;/hbox&gt;&#13;   &lt;/vbox&gt;&#13;   &lt;zscript&gt;&#13;   org.zkoss.util.logging.Log.lookup("Fatal").log(&#13;      requestScope.get("javax.servlet.error.exception"));&#13;   &lt;/zscript&gt;&#13;
&lt;/window&gt;</programlisting>
<para>【ヒント】：エラーページはエラーを起こした同デスクトップで作成されます。つまり、そこから、関連した情報を取得できます。</para>
<para>【ヒント】：まったくモーダルを使用しないアプリケーションがあるため、バージョン2.3.1以降、ZKは自動的にモーダルとしてルートウィンドウを作成しません。モーダルを使用する場合は、前の例をご参照ください。</para><sect3><title>ページ更新中のZKモバイルのエラー</title>
<para>どのデバイスタイプもエラーページのセットを持っています。ZKモバイルデバイス(MILをサポートしているモバイルデバイス)にエラーページを指定するには 、以下のように<code>mil</code>を<code>device-type</code>に指定しなければなりません。</para>
<programlisting>&lt;!-- zk.xml --&gt;&#13;&lt;error-page&gt;&#13;   &lt;device-type&gt;mil&lt;/device-type&gt;&#13;   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;&#13;   &lt;location&gt;/WEB-INF/sys/error.zul&lt;/location&gt;&#13;&lt;/error-page&gt;&#13;</programlisting>
<para>【ヒント】：<code>devie-type</code>要素が省略された場合、ajaxが想定されます。つまり、Ajaxブラウザにエラーページを指定します。<code> &lt;device-type&gt;ajax&lt;/device-type&gt; &lt;!-- ajax is the default --&gt;</code>
</para></sect3></sect2></sect1><sect1><title>パフォーマンス改善のためのヒント</title><sect2><title>コンパイルしたJavaコードを使用</title>
<para>ZUMLの中で<code>zscript</code>を使用するのは便利ですが、デメリットはパフォーマンスの低下です。低下の程度はアプリケーションによる違います。大きなウェブサイトでは、可能なら、できるだけ<code>zscript</code>を使用しないことをお勧めします。必要のであれば、処理を遅らせ(必要なときだけ処理する)、パフォーマンスを向上させるように設定できます。これによって、インタプリタは<code>zscript</code>中に書かれたイベントリスナが実行される直前まで、読み込まれません。</para>
<programlisting>&lt;zscript deferred="true"&gt;&#13;...&#13;</programlisting>
<para>【メモ】：<code>onCreate</code>イベントが以下に示したように、<code>zscript</code>によって処理される場合、遅らせても意味がありません。なぜなら<code>onCreate</code>イベントはページが読み込まれるときに送信されます。つまり、遅らせた<code>zscript</code>はページが読み込まれるときに処理されます。</para>
<programlisting>&lt;window onCreate="init()"&gt;&#13;...&#13;</programlisting>
<para>むしろ、以下のように書き直したほうがいいです。</para>
<programlisting>&lt;window use="my.MyWindow"&gt;&#13;...&#13;</programlisting>
<para>そして、以下のように<code>MyWindow.java</code>を準備します。</para>
<programlisting>package my;&#13;public class MyWindow extends Window {&#13;          public void onCreate() { //to process the onCreate event    &#13;...&#13;</programlisting>
<para>コンポーネント(とその子コンポーネント）を作成した直後に初期化するなら、以下のように、<code>org.zkoss.zk.ui.ext.AfterCompose</code>インターフェースを実装します。<code>AfterCompose</code>インターフェースの<code>afterCompose</code>メソッドはコンポーネント作成段階で処理されます。一方、<code>onCreate</code>イベントはイベント処理段階で処理されます。</para>
<programlisting>package my;&#13;public class MyWindow extends Window implements org.zkoss.zk.ui.ext.AfterCompose {&#13;          public void afterCompose() { //to initialize the window    &#13;...&#13;</programlisting></sect2><sect2><title>サーブレットスレッドを使用してイベントを処理</title>
<para>デフォルトでは、ZKはイベントプロセススレッドと呼ばれる独立したスレッドでイベントを処理します。このため、開発者はサーブレッドスレッドがレスポンスをブラウザへ送信することをやめることなく、いつでも中断と再開を行うことができます。</para>
<para>しかし、中断したスレッドがたくさんある場合はメモリをたくさん使います。この場合、サーブレットスレッドのローカル記憶装置で情報を記憶するほかのシステムとの統合は難しくなります。</para>
<para>ZKではイベントプロセススレッドを使用不可にすることができます。つまり、ほかの従来のフレームワークのようにサーブレットスレッドの中でZKにすべてのイベントを処理させられます。サーブレットスレッドを使用する場合、実行を一時中断することができません。</para>
<para>イベントプロセススレッドの使用を不可にするのに、<code>WEB-INF/zk.xml</code>中の以下のコンテンツを指定しなければなりません。</para>
<programlisting>&lt;system-config&gt;&#13;   &lt;disable-event-thread/&gt;&#13;&lt;/system-config&gt;&#13;</programlisting>
<para>サーブレットを使用してイベントを処理する制限と利点はここにあります。以下のセクション中で、サーブレットスレッドを使用するときの制限とその回避対策について話します。</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para/>
</entry>
<entry>
<para>サーブレットスレッドを使用</para>
</entry>
<entry>
<para>イベントプロセススレッドを使用</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>他の技術との統合</para>
</entry>
<entry>
<para>統合しやすい</para>
<para>多くのコンテナーはHTTPリクエストがサーブレットスレッドで処理されることを想定します。</para>
</entry>
<entry>
<para>統合するのに、<code>EventThreadInit</code> と/または<code>EventThreadCleanup</code>を実装しなければならないかもしれません。</para>
<para>ZKとそのコミュニティは統合を簡単にするように努力しています。</para>
</entry>
</row>
<row>
<entry>
<para>中断と再開</para>
</entry>
<entry>
<para>イベントリスナの実行を中断する方法はありません。</para>
<para>例えば、モーダルウィンドウを作成できません。</para>
</entry>
<entry>
<para>まったく制限はありません。</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>モーダルウィンドウ</title>
<para>モーダルウィンドウをもう使用できません。ハイライトモードで同じ視覚効果を達成できます。しかし、サーバー側では、オーバーラップウィンドウとして認識されます。ユーザーの返信を待つことなしにすぐに返信します。</para>
<programlisting>win.doHighlighted(); //returns once the mode is changed; not suspended&#13;</programlisting></sect3><sect3><title>メッセージボックス</title>
<para>メッセージボックスがすぐに返信するので、<code>Messagebox.OK</code>がいつも返信されます。このため、OK以外のボタンを表示させるのは意味がありません。例えば、以下の例では<code>if</code>で指定した条件が<code>True</code>になることはありません。</para>
<programlisting>if (Messagebox.show("Delete?", "Prompt", Messagebox.YES|Messagebox.NO, Messagebox.QUESTION) == Messagebox.YES) {&#13;          this_never_executes();    &#13;}&#13;</programlisting></sect3><sect3><title>ファイルアップロード</title>
<para>ファイルアップロードダイアログはもう使用できません。代わりに<code>fileupload</code>コンポーネントを使用すべきです。<code>f</code>
<code>ileupload</code>コンポーネントはモーダルダイアログではありません。というより、他コンポーネントと一緒にインラインで配置されます。より詳しくは<code>fileupload Component</code>セクションを参照します。</para>
<programlisting>&lt;fileupload onUpload="handle(event)"/&gt;&#13;</programlisting></sect3></sect2><sect2><title>ファイルが変更されたかどうかを調べるため期間を延長</title>
<para>ZKはZUMLページの結果をキャッシュし、それが変更された場合のみ再びコンパイルします。開発が終わって、生産過程に入ると、ZUMLページはほとんど変更されません。以下に示すように<code>WEB-INF/zk.xml</code>中の<code>file-check-period</code>を指定することでページが変更されるかどうかを調べる期間を延ばすことができます。デフォルトでは5秒です。</para>
<programlisting>&lt;desktop-config&gt;&#13;          &lt;file-check-period&gt;600&lt;/file-check-period&gt;&lt;!-- unit: seconds --&gt;    &#13;&lt;/desktop-config&gt;&#13;</programlisting></sect2><sect2><title>子コンポーネントの作成を遅らせる</title>
<para>複雑なページでは、子コンポーネントの作成をそれらが可視になるまで遅らせれば、パフォーマンスを改善できます。<code>f</code>
<code>ullfill</code>属性を使うのが一番簡単な方法です。以下の例中で、2番目のタブパネルの子要素は可視になってから作成されます。ZKユーザーインターフェースマークアップ言語の章のロードオンデマンドセクションを参照してください。</para>
<programlisting>&lt;tabbox&gt;&#13;          &lt;tabs&gt;    &#13;                    &lt;tab label="Preload" selected="true"/&gt;        &#13;                    &lt;tab id="tab2" label="OnDemand"/&gt;        &#13;          &lt;/tabs&gt;    &#13;          &lt;tabpanels&gt;    &#13;                    &lt;tabpanel&gt;        &#13;          This panel is pre-loaded since no fulfill specified    &#13;                    &lt;/tabpanel&gt;        &#13;                    &lt;tabpanel fulfill="tab2.onSelect"&gt;        &#13;          This panel is loaded only tab2 receives the onSelect event    &#13;                    &lt;/tabpanel&gt;        &#13;          &lt;/tabpanels&gt;    &#13;&lt;/tabbox&gt;&#13;</programlisting></sect2><sect2><title>巨大なリストボックスにおけるライブデータとページングの使用</title>
<para>巨大なリストボックスをクライアントへ送信することは軽い作業ではありません。さらに、ブラウザのJavaScriptエンジンはたくさんのリスト項目の処理に苦手です。ですから、ライブデータで処理したほうがいいかもしれません。つまり、リストモデルにそれを指定します。そうすることで、リスト項目は参照可能な場合にだけクライアントに送信されます。</para>
<para>ページングモールドを使用すると、パフォーマンスはより改善されます。</para>
<para>より詳しくはZUMLとXULコンポーネントセットの章のリストボックスセクションを参照してください。</para></sect2><sect2><title>モーダルウィンドウを開くのに時間がかかる</title>
<para>モーダルウィンドウが開かれるとき、モーダルウィンドウに属していないすべてのコンポーネントは使用不可になります。しかし、ページがとても大きい場合、パフォーマンスが大分落ちるかもしれません。(ブラウザのJavaScript インタプリタとクライアントコンピュータの動作速度しだいです。)モーダルウィンドウを開くのが遅すぎるなら、以下のようにこの機能をオフにできます。</para>
<programlisting>&lt;desktop-config&gt;&#13;          &lt;disable-behind-modal&gt;false&lt;/disable-behind-modal&gt;&lt;!-- default: true --&gt;    &#13;&lt;/desktop-config&gt;&#13;</programlisting>
<para>副作用としては、ユーザーがTABまたはShift-TABを使用して、使用不可のはずのコンポーネントを選択できてしまいます。なお、この機能がオンかオフかにかかわらず、ユーザーはモーダルウィンドウに属していないコンポーネントをクリックすることはできません。</para></sect2><sect2><title>XHTML コンポーネントの代わりに<code>html</code>または<code>inline</code>を使用</title>
<para>ZUMLとXULコンポーネントの章のHTML関連コンポーネントセクション中に書かれているように、XHTML コンポーネントはZKコンポーネントです。つまりZKはサーバーでそれらの状態を維持しなければなりません。XHTML コンポーネントはHTML タグの数が多く、処理に時間が比較的にかかります。このときに、<code>h</code>
<code>tml</code>または<code>i</code>
<code>nline</code>コンポーネントを使用したら、パフォーマンスは改善されます。</para>
<para>たとえば、以下のコードは五つのコンポーネントを作成します。(<code>table,tr,td x 2,textbox</code>)</para>
<programlisting>&lt;h:table xmlns:h="http://www.w3.org/1999/xhtml"&gt;&#13;          &lt;h:tr&gt;    &#13;                    &lt;h:td&gt;Name&lt;/h:td&gt;        &#13;                    &lt;h:td&gt;        &#13;                    &lt;textbox/&gt;        &#13;                    &lt;/h:td&gt;        &#13;          &lt;/h:tr&gt;    &#13;&lt;/h:table&gt;&#13;</programlisting>
<para>一方で、以下のコードは三つのコンポーネントを作成します(二つの<code>inline</code>と<code>textbox</code>) </para>
<programlisting>&lt;inline&gt;&lt;![CDATA[&#13;          &lt;table&gt;    &#13;                    &lt;tr&gt;        &#13;                              &lt;td&gt;Name&lt;/td&gt;            &#13;                              &lt;td&gt;            &#13;]]&gt;&lt;/inline&gt;&#13;                              &lt;textbox/&gt;            &#13;&lt;inline&gt;&lt;![CDATA[&#13;                    &lt;/td&gt;        &#13;          &lt;/tr&gt;    &#13;&lt;/table&gt;&#13;]]&gt;&lt;/inline&gt;&#13;</programlisting></sect2><sect2><title>ZKフィルターの代わりにZK JSP タグを使用</title>
<para>ZKフィルターは対応したXHTMLコンポーネントにそれぞれのHTMLタグをマッピングします。前のセクションで説明したように、ZKはすべてのZKコンポーネントの状態を保持するので、マッピングは必要以上に多くのメモリを使用します。(XULとXHTMLコンポーネントを含みます) </para>
<para>ZK JSPタグはZK フィルターの代わりとして作られました。ZK JSPタグを使用すれば、ZULコンポーネントだけが生成されます。ZULコンポーネント間にあるHTMLタグは、一つの<code>inline</code>コンポーネントとしてエンコードされます。</para>
<programlisting>&lt;!-- a JSP page --&gt;
&lt;z:page&gt;&#13;          &lt;table&gt;    &#13;                    &lt;tr&gt;        &#13;                              &lt;td&gt;Name&lt;/td&gt;            &#13;                              &lt;td&gt;&lt;z:textbox/&gt;&lt;/td&gt;            &#13;                    &lt;/tr&gt;        &#13;          &lt;/table&gt;    &#13;&lt;/z:page&gt;&#13;</programlisting>
<para>ZULページが使用されている場合、上のコードは以下のコード一部分と同様の働きをします。</para>
<programlisting>&lt;!-- a ZUL page --&gt;
&lt;inline&gt;&lt;![CDATA[&#13;          &lt;table&gt;    &#13;                    &lt;tr&gt;        &#13;                              &lt;td&gt;Name&lt;/td&gt;            &#13;                              &lt;td&gt;            &#13;]]&gt;&lt;/inline&gt;&#13;                              &lt;textbox/&gt;            &#13;&lt;inline&gt;&lt;![CDATA[&#13;                    &lt;/td&gt;        &#13;          &lt;/tr&gt;    &#13;&lt;/table&gt;&#13;]]&gt;&lt;/inline&gt;&#13;</programlisting></sect2></sect1><sect1><title>その他</title><sect2><title>ZKローダーが出力を圧縮しないように設定</title>
<para>デフォルトでは、ブラウザがコンテンツの圧縮<footnote>
<para>
<code>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</code>の14.3 Accept-Encodingをご参照ください</para>
</footnote>に対応できれば、ZKローダーとZKフィルターは出力を圧縮してから出力します。出力の圧縮によって、低速インターネットでの伝送時間は劇的に減少します。</para>
<para>しかし、フィルターを使用して、出力を遅れさせる(post-process)場合、コンテンツを圧縮しないように設定できます。以下のように、<code>WEB/web.xml</code>の中のZKローダーを設定する際に、<code>compress</code>パラメータ(<code>init-param</code>)を<code>true</code>に指定します。</para>
<programlisting>&lt;servlet&gt;
      &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;
      &lt;init-param&gt;
          &lt;param-name&gt;update-uri&lt;/param-name&gt;
          &lt;param-value&gt;/zkau&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
          &lt;param-name&gt;compress&lt;/param-name&gt;
          &lt;param-value&gt;false&lt;/param-value&gt;
      &lt;/init-param&gt;
&lt;/servlet&gt;</programlisting>
<para>【注意】：一つのウェブアプリケーションの中で一つ以上のZKローダーを設定できます。それぞれZKローダーの設定値は独立しています。</para>
<programlisting>&lt;servlet&gt;
      &lt;servlet-name&gt;zkLoader1&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;...
&lt;/servlet&gt;&#13;
&lt;servlet&gt;
      &lt;servlet-name&gt;zkLoader2&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;...
&lt;/servlet&gt;&#13;</programlisting>
<para>同様に、ZKフィルター(<code>org.zkoss.zk.ui.http.DHtmlLayoutFilter</code>)を設定し、出力を圧縮しないようにできます。</para>
<programlisting>&lt;filter&gt;
      &lt;filter-name&gt;zkFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutFilter&lt;/filter-class&gt;
      &lt;init-param&gt;
					&lt;param-name&gt;extension&lt;/param-name&gt;
					&lt;param-value&gt;html&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
          &lt;param-name&gt;compress&lt;/param-name&gt;
          &lt;param-value&gt;false&lt;/param-value&gt;
			&lt;/init-param&gt;
&lt;/filter&gt;</programlisting></sect2></sect1></chapter>
<chapter>
<title>11. 国際化 </title>
<para>この章ではZKアプリケーションを柔軟にして、どの地域の中でも動作できるようにします。</para>
<para>ZKは開発者にJavaコードとEL表記を好きなように埋め込むことを可能にしています。また、<code>Java.util.ResourceBundle</code>等お好みの国際化する方法を使用することができます。</para>
<para>さらに、ZKではいくつかの国際化する方法を提供しています。</para><sect1><title>ロケール</title>
<para>リクエストとイベントを処理するロケールはデフォルトで(<code>javax.servlet.ServletRequest</code>メソッドの<code>getLocale</code>を使用して)ブラウザの環境設定(preference)によって決定します。</para>
<para>しかし、ロケールは設定可能です。例えば、ブラウザがどのように設定されたかにかかわらず、すべてのユーザーに同じロケールを使用させる場合があります。また、サーバーの中でユーザーのプロフィルを持っている場合、プロフィルの中で指定した好みのロケールを使用したい場合もあります。</para><sect2><title>
<code>px_preferred_local</code>セッション属性</title>
<para>ブラウザの環境設定(preference)をチェックする前に、ZKは<code>px_preferred_locale</code>と呼ばれるセッションが定義されたかどかを確認します。定義されていたら、ZKはブラウザの環境設定の代わりにセッションにデフォルトロケールとしてそれを使用します。これによって、この属性の中で好みのロケールを設定することで、セッションのロケールを決められます。</para>
<para>以下は、ユーザーがログインするときに使用する例です。</para>
<programlisting>void login(String username, String password) {&#13;          //check password    &#13;          ...    &#13;          Locale preferredLocale = ...; //decide the locale (from, say, database)    &#13;          session.setAttribute("px_preferred_locale", preferredLocale);    &#13;          ...    &#13;}&#13;</programlisting>
<para>【ヒント】：<code>org.zkoss.web.Attributes</code>クラスの中で<code>PREFERRED_LOCALE</code>と呼ばれる定数を使用すれば。誤植を避けることができます。</para></sect2><sect2><title>リクエストインターセプター</title>
<para>アプリケーションの性質により、ユーザーがログインしてから、ロケールを決めるのが遅すぎる場合があります。例えば、ユーザーがログインする前に、前セッションで使用した同じロケールを使用させる場合があります。そのとき、ウェブアプリケーションでは、クッキーを使って行われます。ZKの場合は、リクエストインターセプターを登録し、インターセプターが呼ばれるときにクッキーを処理します。</para>
<para>リクエストインターセプターはZKローダーとZKアップデートエンジンによって処理されたリクエストをインターセプト(一時遮断) します。それを使用するため、<code>org.zkoss.zk.ui.util.RequestInterceptor</code>インターフェースを実装しなければなりません。例えば、</para>
<programlisting>public class MyLocaleProvider implements org.zkoss.zk.ui.util.RequestInterceptor {&#13;          public void request(org.zkoss.zk.ui.Session sess,    &#13;          Object request, Object response) {    &#13;                    final Cookie[] cookies = ((HttpServletRequest)request).getCookies();        &#13;                    if (cookies != null) {        &#13;                              for (int j = cookies.length; --j &gt;= 0;) {            &#13;                                        if (cookies[j].getName().equals("my.locale")) {                &#13;                                                  //determine the locale                    &#13;                                                  String val = cookies[j].getValue();                    &#13;                              Locale locale = org.zkoss.util.Locales.getLocale(val);&#13;                                                  sess.setAttribute(Attributes.PREFERRED_LOCALE, locale);                    &#13;                                                  return;                    &#13;                                        }                &#13;                              }            &#13;                    }        &#13;          }    &#13;}&#13;</programlisting>
<para>有効にするために、以下のように<code>WEB-INF/zk.xml</code>の中にそれを登録しなければなりません。一度登録されると、ZKローダーまたはZKアップデートエンジンがリクエストを受け取るたびに、リクエストメソッドを呼び出します。設定について開発用リファレンス中のAppendix Bを参照してください。</para>
<programlisting>&lt;listener&gt;&#13;          &lt;listener-class&gt;MyLocaleProvider&lt;/listener-class&gt;    &#13;&lt;/listener&gt;&#13;</programlisting>
<para>【メモ】：インターセプターのインスタンスは登録されるときにインスタンス化されます。同アプリケーション中のすべてのリクエストで共有されます。このため、同時に通信できる(つまり、thread-safe)ことを事前に確認しなければなりません。</para>
<para>【メモ】：<code>request </code>メソッドはかなり早い段階、リクエストパラメータが渡される前に、呼び出されます。このため、リクエストにロケールと文字列を適切にエンコードしない限り、このメソッドでそれらに通信することを推奨します。 </para></sect2></sect1><sect1><title>タイムゾーン</title>
<para>デフォルトでは、イベントとリクエストを処理するタイムゾーンはJVMの環境設定(preference)によって(<code>java.util.Timezone</code>の<code>getDefault</code>メソッドの使用で)、決定されます。</para>
<para>【メモ】： ロケールとは異なり、ブラウザにタイムゾーンを決定する標準的な方法はありません。</para>
<para>ロケールのように、セッションのタイムゾーンは設定可能です。例えば、プログラマーがサーバー側でユーザープロフィルを設定した場合、ユーザーがプロフィルで指定した好みのタイムゾーンを使用することができます。</para><sect2><title>
<code>px_preferred_time_zone</code>セッション属性</title>
<para>ZKは<code>px_preferred_time_zone</code>と呼ばれるセッション属性が定義されているかどうか確認します。定義されている場合、システムデフォルトの代わりにセッションのデフォルトタイムゾーンとして使用します。このため、この属性の中で必要なロケール情報を保存すれば、セッションのタイムゾーンを指定できます。</para>
<para>【ヒント】：誤値を防ぐために、<code>org.zkoss.web.Attributes</code>クラスの中で定義された<code>PREFERRED_TIME_ZONE</code>と呼ばれる定数を使用します。</para></sect2><sect2><title>リクエストインターセプター</title>
<para>ローカルのように、リクエストインターセプタを使用して<code>px_preferred_time_zone</code>属性でセッションにタイムゾーンを指定することができます。</para></sect2></sect1><sect1><title>ラベル</title>
<para>ZUMLページ(とJSPページ)からロケール依存のデータを分けるため、ロケール依存のデータを<code>WEB-INF</code>ディレクトリーの下の<code>i3_label_lang_CNTY</code>の中に保存します。<code>lang</code>がen、frといった言語で、<code>CNTY</code>はUSやFRといった国名です。</para>
<para>ロケール依存プロパティを得るために、Javaで<code>org.zkoss.util.resource.Labels</code>または ELで<code>${c:l('key')}</code>を使用できます。ELを使用する場合、以下のようにTLDファイルを挿入しなければなりません。</para>
<programlisting>&lt;%@ taglib uri="/WEB-INF/tld/web/core.dsp.tld" prefix="c" %&gt;&#13;&#13;&lt;window title="${c:l('app.title')}"&gt;&#13;...&#13;&lt;/window&gt;&#13;</programlisting>
<para>【ファイルのディレクトリー】：<code>core.tld</code>は<code>dist/WEB-INF</code>ディレクトリーの下に配布されています。 </para>
<para>ロケール依存ラベルが取得されようとするとき、<code>i3-label_lang_CNTY.propaties</code>が読み込まれます。例えば、ロケールが<code>de_DE</code>の場合、<code>WEB-INF/i3-label_de_DE.properties</code> が読み込まれます。そのようなファイルが見つからなかったら、ZKは順番に、<code>WEB-INF/i3-label_de.propaties</code>と<code>WEB-INF/i3-label.properties</code>を読み込もうとします。</para>
<para>Javaコード(<code>zscript</code>を含んで)でラベルにアクセスするのに<code>org.zkoss.util.resource.Labels</code>クラスの<code>getLabel</code>メソッドを使用します。</para>
<para>さらに、<code>org.zkoss.util.resource.LabelLocator</code>インターフェースを実装して、ロケーターを登録することで、ラベルローダーを拡張し、データベースなど他の位置からラベルを読み込むことができます。</para></sect1><sect1><title>ロケール依存ファイル</title><sect2><title>ブラウザとロケール依存URI</title>
<para>リソースはロケールやブラウザに依存する場合が多くあります。例えば、読みやすくするため、大きなフォントを設定したりします。</para>
<para>”*”を使ってスタイルシートのURLを指定すれば、ZKは自動的にこれを処理できます。アルゴリズムは以下のようになります。</para>
<orderedlist>
<listitem>
<para>
<code>/my*.css</code>のようなURIの中で一つの"*"が指定されたら、"*"はユーザーブラウザの環境設定(preference)によって適切なロケールと取り替えます。例えば、ユーザーの設定が<code>de_DE</code>とすると、ZKは<code>/my_de_DE.css</code>、<code>/my_de.css</code>、 <code>/my.css</code> を順番にウェブサイトから検索し、それらのうちの一つかが見つかるまで探します。何も見つからなかった場合、<code>/my.css</code>が使用されます。</para>
</listitem>
<listitem>
<para>二つ以上の"*"が<code>/my*/lang*.css</code>といったURIの中で指定された場合、はじめの"*"はインターネットイクスプローラーが"ie"、Safariが"saf"、その他のブラウザが"moz"<footnote>
<para>今後はインターネットエクスプローラ・ファイヤフォックス・サファリの以外のブラウザもサポートする予定です。</para>
</footnote>と取り替えられます。さして、最後のアスタリスクはステップ1の中で説明したように適切なロケールと取り替えられます。まとめとして、最後のアスタリスクはロケールを表します。一方、はじめのアスタリスクはブラウザの種類を表します。 </para>
</listitem>
<listitem>
<para>上記以外の"*"は無視されます。</para>
</listitem>
</orderedlist>
<para>【メモ】：はじめのドット(".")の直前にロケールを表す最後のアスタリスクをおかなければなりません。または、ドットがないなら、最後にアスタリスクをおきます。さらに、その次にスラッシュ(/)が許可されません。つまり、それはディレクトリーではなく、ファイル名の一部です。最後のアスタリスクは上記の条件を満足しない場合、削除されます。(無視ではない) 例えば、“<code>/my/lang.css*</code>”は”<code>/my/lang.css</code>”と同様です。つまり、ロケールにとっては中立だと考えられます。</para>
<para>【ヒント】：このルールを採用して、ロケールではなくて、ブラウザの種類によってURIを指定することができます。例えば、インターネットイクスプローラが現在のブラウザなら、"<code>/my/lang*.css*</code>"は"<code>/my/langie.css</code>"と取り替えられます。 </para>
<para/>
<para>以下の例中で、設定された(prefered)のロケールが<code>de_DE</code>で、ブラウザがインターネットイクスプローラと想定します。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>URI</para>
</entry>
<entry>
<para>検索されるリソース</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>/css/norm*.css</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/norm_de_DE.css</code>
</para>
</listitem>
<listitem>
<para>
<code>/norm_de.css</code>
</para>
</listitem>
<listitem>
<para>
<code>/norm.css</code>
</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>
<code>/css-*/norm*.css</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/css-ie/norm_de_DE.css</code>
</para>
</listitem>
<listitem>
<para>
<code>/css-ie/norm_de.css</code>
</para>
</listitem>
<listitem>
<para>
<code>/css-ie/norm.css</code>
</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>
<code>/img*/pic*/lang*.png</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/imgie/pic*/lang_de_DE.png</code>
</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>
<code>/imgie/pic*/lang_de.png</code>
</para>
</listitem>
<listitem>
<para>
<code>/imgie/pic*/lang.png</code>
</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>
<code>/img*/lang.gif</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/img/lang.gif</code>
</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>
<code>/img/lang*.gif*</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/img/langie.gif</code>
</para>
</listitem>
</orderedlist>
</entry>
</row>
<row>
<entry>
<para>
<code>/img*/lang*.gif*</code>
</para>
</entry>
<entry>
<orderedlist>
<listitem>
<para>
<code>/imgie/lang*.gif</code>
</para>
</listitem>
</orderedlist>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>Javaでブラウザとロケール依存するリソース</title>
<para>コンポーネント属性とZUML属性に加えて、Javaでプログラム的にブラウザとローカル依存リソースを制御できます。使用できるメソッドのリストは以下になります。</para>
<itemizedlist>
<listitem>
<para>
<code>fowardorg.zkoss.zk.ui.Exection</code>の中の<code>endoceURL</code>、<code>forward</code>、<code>include</code>メソッドはそれぞれURLをエンコードする、ほかのページへ転送する、ページを挿入するという動作をします。ほとんどの場合、これらの方法はすべて必要です。</para>
</listitem>
<listitem>
<para>
<code>org.zkoss.web.servlet.Servlets</code>の中の<code>locate</code>、<code>forward</code>、と<code>include</code>メソッドはウェブリソースを探し出してくれます。ZKアプリケーションを開発するのに、ほとんど必要になることはありませんが、サーブレット、ポートレット、フィルターを書くときには便利です。</para>
</listitem>
<listitem>
<para>
<code>org.zkoss.web.servlet.http.Encodes</code>の中の<code>encodeURL</code>メソッドはURLをエンコードします。ZKアプリケーションを開発するとき、必要になることはめったにありません。しかし、サーブレット、ポートレット、または、フィルターを書くときには便利です。</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<para>
<code>Org.zkoss.util.resource.Locators</code>中のlocateメソッドはクラスリソースを探し出します。</para>
</listitem>
</itemizedlist></sect2></sect1><sect1><title>メッセージ</title>
<para>メッセージはクラスパスの<code>/metainfo/mesg</code>ディレクトリーに位置するプロパティファイルの中に保存されます。それぞれのモジュールは唯一の名前を持っています。さらに、ロケールはプロパティファイルに付き加えます。例えば、ドイツ語メッセージ用の<code>zk.jar</code>のメッセージファイルは<code>msgzk_de_DN.properties</code>または、<code>msgzk_de.properties</code>です。プロパティファイルをクラスパスの<code>/metainfo/mesg</code>ディレクトリーに置けば、お好みのロケールを追加できます。</para></sect1><sect1><title>中国語文字とより大きなフォント</title>
<para>XULコンポーネントセットはそれぞれのタイプのブラウザに二つのスタイルシートを提供します。一つはより小さなフォント、もう一つはより大きなフォントです。例えば、インターネットエクスプローラ用のスタイルシート<code>normie.css.dsp</code>と<code>normie_zh.css.dsp</code>は、それぞれより小さなフォントとより大きなフォントが設定されています。</para>
<para>デフォルトでは<code>、normie.css.dsp</code>
<footnote>
<para>2.3より前のバージョンでは、中国語が大きなフォント、その他の言語が小さなフォントに設定されていました。</para>
</footnote>のような小さなフォントだけを使用します。変更するには、以下を<code>WEB-INF/zk.xm</code>lの中で以下のコードを指定すれば、より大きなフォントを使用することができます。</para>
<programlisting>&lt;zk&gt;&#13;          &lt;desktop-config&gt;    &#13;                    &lt;disable-default-theme&gt;xul/html&lt;/disable-default-theme&gt;        &#13;                    &lt;theme-uri&gt;~./zul/css/norm*_zh.css.dsp*&lt;/theme-uri&gt;        &#13;          &lt;/desktop-config&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>より大きなフォントを中国語の文字に、小さなフォントはその他の言語に設定する方法は以下になります。</para>
<programlisting>&lt;zk&gt;&#13;          &lt;desktop-config&gt;    &#13;                    &lt;disable-default-theme&gt;xul/html&lt;/disable-default-theme&gt;        &#13;                    &lt;theme-uri&gt;~./zul/css/norm**.css.dsp&lt;/theme-uri&gt;        &#13;          &lt;/desktop-config&gt;    &#13;&lt;/zk&gt;&#13;</programlisting>
<para>
<code>WEB-INF/zk.xml</code>を設定する方法については、開発用リファレンスを参照してください。</para></sect1></chapter>
<chapter>
<title>12.データベースとの接続</title>
<para>この章ではデータベースへとの接続する方法を説明します。</para><sect1><title>ZKはプレゼンテーション層</title>
<para>ZKはプレゼンテーション層と同じぐらいシンになることを目標としています。さらに、サーバー中心というアプローチにより、サーバーですべてのコードを実行します。ですから、データベースに通信することはデスクトップアプリケーションとは同じです。つまり、JDBCを使用しているかHibernate<footnote>
<para>
<ulink url="http://www.hibernate.org/">http://www.hibernate.org</ulink>
</para>
</footnote>といった既存のフレームワークを使用しているかに関わらず、ZKの使用によるデータベースへアクセスする方法が変わったことはありません。</para></sect1><sect1><title>JDBCを使用する最も簡単な方法(しかし、推奨しません)</title>
<para>JDBCチュートリアルが薦めるように、JDBCを使用する最も簡単な方法は<code>java.sql.DriverManager</code>を使用することです。MySQL<footnote>
<para>
<ulink url="http://www.mysql.com/">http://www.mysql.com</ulink>
</para>
</footnote>データベースにメールと名前を保存する例が以下になります。</para>
<programlisting>&lt;window title="JDBC demo" border="normal"&gt;&#13;          &lt;zscript&gt;&lt;![CDATA[    &#13;          import java.sql.*;    &#13;          void submit() {    &#13;                    //load driver and get a database connetion        &#13;                    Class.forName("com.mysql.jdbc.Driver");        &#13;                    Connection conn = DriverManager.getConnection(        &#13;                              "jdbc:mysql://localhost/test?user=root&amp;password=my-password");            &#13;                    PreparedStatement stmt = null;        &#13;                    try {        &#13;                              stmt = conn.prepareStatement("INSERT INTO user values(?, ?)");            &#13;&#13;                              //insert what end user entered into database table            &#13;                              stmt.set(1, name.value);            &#13;                              stmt.set(2, email.value);            &#13;&#13;                              //execute the statement            &#13;                              stmt.executeUpdate();            &#13;                    } finally { //cleanup        &#13;                              if (stmt != null) {            &#13;                                        try {                &#13;                                                  stmt.close();                    &#13;                                        } catch (SQLException ex) {                &#13;                                                  log.error(ex); //log and ignore                    &#13;                                        }                &#13;                              }            &#13;                              if (conn != null) {            &#13;                                        try {                &#13;                                                  conn.close();                    &#13;                                        } catch (SQLException ex) {                &#13;                                                  log.error(ex); //log and ignore                    &#13;                                        }                &#13;                              }            &#13;                    }        &#13;          }    &#13;          &lt;/zscript&gt;    &#13;          &lt;vbox&gt;    &#13;                    &lt;hbox&gt;Name : &lt;textbox id="name"/&gt;&lt;/hbox&gt;        &#13;                    &lt;hbox&gt;Email: &lt;textbox id="email"/&gt;&lt;/hbox&gt;        &#13;                    &lt;button label="submit" onClick="submit()"/&gt;        &#13;          &lt;/vbox&gt;    &#13;&lt;/window&gt;&#13;</programlisting>
<para>この方法は簡単ですが、お勧めしません。なぜならZKアプリケーションはウェブをベースにしているアプリケーションであるからです。読み込みはいつ起こるか予想できません。データベースとの接続は効率的に行わなければなりません。</para>
<para>幸い、J2EEフレームワークとウェブサーバーはコネクションプーリングと呼ばれる機能を提供しています。この機能は簡単に使用できるし、データベースとの接続を管理することもできます。次のセクションで詳しく話します。</para>
<para>【ヒント】：ほかのウェブアプリケーションとは違って、ZKにて<code>DriverManager</code>を使用することは可能です。(ただし、推奨はしません)。はじめに、デスクトップの中でコネクションをキャッシュし、イベントに使用します(何度も使用することができます)。デスクトップが無効になったら閉じます。伝統的なクライアント/サーバーアプリケーションのように動きます。この方法は、クライアント/サーバーアプリケーションのように、同時に使用しているユーザー数が制限されています。(超えると、効率が低下します)。デスクトップが無効になったことを知るために、<code>org.zkoss.zk.ui.utilDesktopCleanup</code>の使用でリスナを実装しなければなりません。</para></sect1><sect1><title>コネクションプーリングを使用</title>
<para>コネクションプーリングはスレッドがいつでも使用できるコネクションを作成・管理する技術です。コネクションをすぐに閉じるのではなく、次の接続リクエストが有効に提供できるように、コネクションプールの中でそれらを一時保存します。コネクションプーリングはリソースの使用をコントロールするといった利点をたくさん持っています。</para>
<para>ZKアプリケーションを含んだウェブをベースにしているアプリケーションを開発するときに、コネクションプーリングを使わない理由はありません。</para>
<para>コネクションプーリングを使用するコンセプトはシンプルです:設定、接続、閉じるです。設定はウェブサーバーとデータベースサーバーが何を使用しているかによって決まる一方で、接続する方法とコネクションを閉じる方法はad-hocのアプローチととても類似しています。</para><sect2><title>接続とコネクションを閉じること</title>
<para>(以下のセクション中で討論されている)コネクションプーリングを設定した後、JNDIを使用してコネクションを以下のように取得します。</para>
<programlisting>import java.sql.Connection;&#13;import java.sql.SQLException;&#13;import java.sql.Statement;&#13;&#13;import javax.naming.InitialContext;&#13;import javax.sql.DataSource;&#13;&#13;import org.zkoss.zul.Window;&#13;&#13;public class MyWindows extends Window {&#13;          private Textbox name, email;    &#13;          public void onCreate() {    &#13;                    //initial name and email        &#13;                    name = getFellow("name");        &#13;                    email = getFellow("email");        &#13;          }    &#13;          public void onOK() throws Exception {    &#13;                    DataSource ds = (DataSource)new InitialContext()        &#13;                  .lookup("java:comp/env/jdbc/MyDB");
                  //Assumes your database is configured and            &#13;                              //named as "java:comp/env/jdbc/MyDB"            &#13;&#13;                    Connection conn = null;        &#13;                    Statement stmt = null;        &#13;                    try {        &#13;                              conn = ds.getConnection();            &#13;                  stmt = conn.prepareStatement("INSERT INTO user values(?, ?)");&#13;&#13;                              //insert what end user entered into database table            &#13;                              stmt.set(1, name.value);            &#13;                              stmt.set(2, email.value);            &#13;&#13;                              //execute the statement            &#13;                              stmt.executeUpdate();            &#13;                              stmt.close(); stmt = null;            &#13;                                //optional because the finally clause will close it        &#13;                        //However, it is a good habit to close it as soon as done, especially &#13;                        //you might have to create a lot of statement to complete a job&#13;                    } finally { //cleanup        &#13;                              if (stmt != null) {            &#13;                                        try {                &#13;                                                  stmt.close();                    &#13;                                        } catch (SQLException ex) {                &#13;                                                  //(optional log and) ignore                    &#13;                                        }                &#13;                              }            &#13;                              if (conn != null) {            &#13;                                        try {                &#13;                                                  conn.close();                    &#13;                                        } catch (SQLException ex) {                &#13;                                                  //(optional log and) ignore                    &#13;                                        }                &#13;                              }            &#13;                    }        &#13;          }    &#13;}&#13;</programlisting>
<para>【メモ】：</para>
<itemizedlist>
<listitem>
<para>使用後、コネクションとステートメントを閉じることが重要です。</para>
</listitem>
<listitem>
<para>一つ以上のコネクションを使用することで同時に多数のデータベースに接続することができます。また、設定とJ2EE/Webサーバによって、これらのコネクションをまとめて処理できることも可能です。</para>
</listitem>
</itemizedlist></sect2><sect2><title>コネクションプーリングの設定</title>
<para>コネクションプーリングの設定はJ2EE/Web/Databaseサーバーによって変わります。そのうちのいくつかをここで話します。使用しているサーバーのドキュメントを参考にしてください。</para><sect3><title>Tomcat 5.5 + MySQL</title>
<para>Tomcat 5.5 でコネクションプーリングを設定するには<code>$TOMCAT_DIR/conf/context.xml</code>
<footnote>
<para>Thomas Muller (<ulink url="http://asconet.org:8000/antville/oberinspector">http://asconet.org:8000/antville/oberinspector</ulink>) に指摘して頂きました.</para>
<para>
<ulink url="http://tomcat.apache.org/tomcat-5.5-doc/jndi-resources-howto.html">http://tomcat.apache.org/tomcat-5.5-doc/jndi-resources-howto.html</ulink> と <ulink url="http://en.wikibooks.org/wiki/ZK/How-Tos/HowToHandleHibernateSessions#Working_with_the_Hibernate_session">http://en.wikibooks.org/wiki/ZK/How-Tos/HowToHandleHibernateSessions#Working_with_the_Hibernate_session</ulink> をご覧ください。</para>
</footnote>を編集し、<code>&lt;context&gt;</code>要素の下に以下のコンテンツを追加しなければなりません。インストール・設定によって、パス・ユーザー名など(青い色のところ)変更する必要があります。</para>
<programlisting>&lt;!-- The name you used above, must match _exactly_ here!&#13;          The connection pool will be bound into JNDI with the name    &#13;          "java:/comp/env/jdbc/MyDB"    &#13;--&gt;&#13;&lt;Resource name="jdbc/MyDB" username="someuser" password="somepass" &#13;          url="jdbc:mysql://localhost:3306/test"     &#13;          auth="Container" defaultAutoCommit="false"     &#13;          driverClassName="com.mysql.jdbc.Driver" maxActive="20"     &#13;          timeBetweenEvictionRunsMillis="60000"     &#13;          type="javax.sql.DataSource" /&gt;    &#13;&lt;/ResourceParams&gt;&#13;</programlisting>
<para>そして、<code>web.xml</code>の中で、以下のように<code>&lt;web-app&gt;</code>の下に以下のコンテンツを追加しなければなりません。</para>
<programlisting>&lt;resource-ref&gt;&#13;    &lt;res-ref-name&gt;jdbc/MyDB&lt;/res-ref-name&gt;&#13;    &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;&#13;    &lt;res-auth&gt;Container&lt;/res-auth&gt;&#13;&lt;/resource-ref&gt;&#13;</programlisting></sect3><sect3><title>JBoss + MySQL</title>
<para>以下の説明はMySQL 5.0のリファレンスマニュアルの23.3.4.3セクションを基にしています。</para>
<para>JBossでコネクションプーリングを設定するには、<code>deploy(</code>
<code>$JBOSS_DIR/server/default/deploy</code>
<code>)</code>と呼ばれるディレクトリーに新しいファイルを追加します。そのファイルの名前は<code>"-ds.xml</code>"で終わらなければなりません。そのファイルは、JBossに、ファイルをJDBCデータソースとしてデプロイすることを伝えます。ファイルは以下のコンテンツを含まなければなりません。その情報はインストール・設定しだいで、変更が必要なところ(青い色)があります。</para>
<programlisting>&lt;datasources&gt;&#13;        &lt;local-tx-datasource&gt;&#13;                &lt;!-- This connection pool will be bound into JNDI with the name&#13;                          "java:/MyDB" --&gt;&#13;                &lt;jndi-name&gt;MyDB&lt;/jndi-name&gt;&#13;                &lt;connection-url&gt;jdbc:mysql://localhost:3306/test&lt;/connection-url&gt;&#13;                &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;&#13;                &lt;user-name&gt;someser&lt;/user-name&gt;&#13;                &lt;password&gt;somepass&lt;/password&gt;&#13;&#13;                &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;&#13;&#13;                &lt;!-- Don't set this any higher than max_connections on your&#13;                  MySQL server, usually this should be a 10 or a few 10's&#13;                  of connections, not hundreds or thousands --&gt;&#13;&#13;                &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;&#13;&#13;                &lt;!-- Don't allow connections to hang out idle too long,&#13;                  never longer than what wait_timeout is set to on the&#13;                  server...A few minutes is usually okay here,&#13;                  it depends on your application&#13;                  and how much spikey load it will see --&gt;&#13;&#13;                &lt;idle-timeout-minutes&gt;5&lt;/idle-timeout-minutes&gt;&#13;&#13;                &lt;!-- If you're using Connector/J 3.1.8 or newer, you can use&#13;                      our implementation of these to increase the robustness&#13;                      of the connection pool. --&gt;&#13;&#13;&lt;exception-sorter-class-name&gt;com.mysql.jdbc.integration.jboss.ExtendedMysqlExceptionSorter&lt;/exception-sorter-class-name&gt;&#13;&lt;valid-connection-checker-class-name&gt;com.mysql.jdbc.integration.jboss.MysqlValidConnectionChecker&lt;/valid-connection-checker-class-name&gt;&#13;&#13;        &lt;/local-tx-datasource&gt;&#13;&lt;/datasources&gt;&#13;</programlisting></sect3><sect3><title>JBoss + PostgreSQL</title>
<programlisting>&lt;datasources&gt;&#13;          &lt;local-tx-datasource&gt;    &#13;          &lt;!-- This connection pool will be bound into JNDI with the name    &#13;                     "java:/MyDB" --&gt;    &#13;          &lt;jndi-name&gt;MyDB&lt;/jndi-name&gt;    &#13;        &#13;          &lt;!-- jdbc:postgresql://[servername]:[port]/[database name] --&gt;    &#13;          &lt;connection-url&gt;jdbc:postgresql://localhost/test&lt;/connection-url&gt;    &#13;&#13;          &lt;driver-class&gt;org.postgresql.Driver&lt;/driver-class&gt;    &#13;          &lt;user-name&gt;someuser&lt;/user-name&gt;    &#13;          &lt;password&gt;somepass&lt;/password&gt;    &#13;          &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;    &#13;          &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;    &#13;          &lt;track-statements&gt;false&lt;/track-statements&gt;    &#13;          &lt;/local-tx-datasource&gt;    &#13;&lt;/datasources&gt;&#13;</programlisting></sect3></sect2></sect1><sect1><title>データベースアクセスに使用可能なZKの機能</title><sect2><title>
<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>インターフェース</title>
<para>以前に強調したように、<code>finally</code>段階でコネクションを閉じることは重要です。閉じることによって、すべてのコネクションはコネクションプールに正確に返ります。</para>
<para>アプリケーションをよりロバストにするのに、<code>finally</code>段階で保留されているコネクション、ステートメントを閉じることを忘れてしまったときに備えて、<code>org.zkoss.zk.ui.event.EventThreadCleanup</code>インターフェースを実装し、すべてのコネクションとステートメントを閉じることができます。</para>
<para>しかし、保留されているコネクションとステートメントを閉じる方法は使用しているサーバーしだいです。使用しているサーバーのドキュメントを参考にしてください。</para>
<para>【ヒント】：多くの場合、そのようなメソッドを提供する必要はありません。なぜなら、<code>finalized</code>メソッドが呼び出されたら、コネクションプーリングの実装はコネクションをリサイクルします。</para></sect2><sect2><title>EL表記でデータベースにアクセス</title>
<para>イベントリスナの中でデータベースへアクセスするほか、EL表記の使用で、データベースに通信し、属性の値を取得するのは一般的です。以下の例は、EL表記を使用して、データベースから取得したデータを<code>listbox</code>に表示します。</para>
<programlisting>&lt;zscript&gt;&#13;      import my.CustomerManager;&#13;          customers = new CustomerManager().findAll(); //load from database    &#13;&lt;/zscript&gt;&#13;&lt;listbox id="personList" width="800px" rows="5"&gt;&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="Name"/&gt;        &#13;                    &lt;listheader label="Surname"/&gt;        &#13;                    &lt;listheader label="Due Amount"/&gt;        &#13;          &lt;/listhead&gt;    &#13;          &lt;listitem value="${each.id}" forEach="${customers}"&gt;    &#13;                    &lt;listcell label="${each.name}"/&gt;        &#13;                    &lt;listcell label="${each.surname}"/&gt;        &#13;                    &lt;listcell label="${each.due}"/&gt;        &#13;          &lt;/listitem&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting>
<para>
<code>findAll</code>メソッドを実装する方法はいくつかあります。</para><sect3><title>すべてを読み、リンクリストへコピーする</title>
<para>
<code>findAll</code>メソッドですべてのデータを取得する最も簡単な方法は、データをリストにコピーし、コネクションを閉じます。</para>
<programlisting>public class CustomerManager {&#13;          public List findAll() throws Exception {    &#13;                    DataSource ds = (DataSource)new InitialContext()        &#13;                                        .lookup("java:comp/env/jdbc/MyDB");                &#13;&#13;                    Connection conn = null;        &#13;                    Statement stmt = null;        &#13;                    ResultSet rs = null;        &#13;                    List results = new LinkedList();        &#13;                    try {        &#13;                              conn = ds.getConnection();            &#13;                              stmt = conn.createStatement();            &#13;                              rs = stmt.executeQuery("SELECT id, name, surname FROM customers");            &#13;                              while (rs.next()) {            &#13;                                        long id = rs.getInt("id");                &#13;                                        String name = rs.getString("name");                &#13;                                        String surname = rs.getString("surname");                &#13;                                        results.add(new Customer(id, name, surname));                &#13;                              }            &#13;                              return results;            &#13;                    } finally {        &#13;                  if (rs != null) try { rs.close(); } catch (SQLException ex) [}&#13;                  if (stmt != null) try { stmt.close(); } catch (SQLException ex) [}&#13;                  if (conn != null) try { conn.close(); } catch (SQLException ex) [}&#13;                    }        &#13;          }    &#13;}&#13;</programlisting></sect3><sect3><title>
<code>org.zkoss.zk.ui.util.Initiator</code>インターフェースを実装</title>
<para>ビューとJavaコードを混在に使用しないで、<code>init</code>コマンドを使用してデータを読み込むことができます。</para>
<programlisting>&lt;?init class="my.AllCustomerFinder" arg0="customers"?&gt;&#13;&#13;&lt;listbox id="personList" width="800px" rows="5"&gt;&#13;          &lt;listhead&gt;    &#13;                    &lt;listheader label="Name"/&gt;        &#13;                    &lt;listheader label="Surname"/&gt;        &#13;                    &lt;listheader label="Due Amount"/&gt;        &#13;          &lt;/listhead&gt;    &#13;          &lt;listitem value="${each.id}" forEach="${customers}"&gt;    &#13;                    &lt;listcell label="${each.name}"/&gt;        &#13;                    &lt;listcell label="${each.surname}"/&gt;        &#13;                    &lt;listcell label="${each.due}"/&gt;        &#13;          &lt;/listitem&gt;    &#13;&lt;/listbox&gt;&#13;</programlisting>
<para>そして、<code>my.CustomerFindAll</code>クラスを<code>org.zkoss.zk.ui.util.Initiator</code>インターフェースを使用して、実装します。</para>
<programlisting>import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class AllCustomerFinder implements Initiator {&#13;          public void doInit(Page page, Object[] args) {    &#13;                    try {        &#13;                              page.setVariable((String)args[0], new CustomerManager().findAll());            &#13;                        //Use setVariable to pass the result back to the page&#13;                    } catch (Exception ex) {        &#13;                              throw UiException.Aide.wrap(ex);            &#13;                    }        &#13;          }    &#13;          public void doCatch(Throwable ex) { //ignore    &#13;          }    &#13;          public void doFinally() { //ignore    &#13;          }    &#13;}&#13;</programlisting></sect3></sect2><sect2><title>トランザクションと<code>org.zkoss.zk.util.Initiator</code>
</title>
<para>
<code>Distributed transaction</code> のような複雑なアプリケーションには、トランザクションのライフサイクルをはっきりとコントロールしなければなりません。すべてのデータベースアクセスがイベントリスナの中で処理される場合、そのままでZKにても使用できます。J2EE/Web サーバーのドキュメントに薦められた方法で、トランザクションを開始、コミット、ロールバックします。</para>
<para>一方、ZUMLページ(コンポーネント作成段階)が同じトランザクションの中で処理されるには、上のセクションの中で説明したように、<code>org.zkoss.zk.util.Initiator</code>インターフェースを実装して、与えられたページのライフサイクルをコントロールします。</para>
<para>概略の実装は以下のように示されます。</para>
<programlisting>import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class TransInitiator implements Initiator {&#13;              private boolean _err;      public void doInit(Page page, Object[] args) {        &#13;                    startTrans(); //depending the container, see below        &#13;          }    &#13;          public void doCatch(Throwable ex) {    &#13;                    _err = true;        &#13;                    rollbackTrans(); //depending the container, see below        &#13;              }      public void doFinally() {        &#13;                    if (!_err)        &#13;                              commitTrans(); //depending the container, see below            &#13;          }    &#13;}&#13;</programlisting>
<para>説明したように、トランザクションは<code>doInit</code>メソッドで開始して、<code>org.zkoss.zk.util.Inittiator</code>インターフェースで終了します。</para>
<para>トランザクションを開始、コミット、ロールバックする方法は、使用しているコンテナーによって変わります。</para><sect3><title>J2EEトランザクションとイニシエーター</title>
<para>J2EEコンテナーを使用する場合、トランザクションマネージャー(j<code>avax.transaction.TransactionManager</code>)　を検索し、<code>begin</code>メソッドを呼び出してトランザクションを開始します。ロールバックするには<code>rollback</code>メソッドを呼び出します。コミットには<code>commit</code>メソッドを呼び出します。</para></sect3><sect3><title>ウェブコンテナーとイニシエーター</title>
<para>トランザクションマネージャーなしのウェブコンテナーを使用している場合、データベースコネクションを構築することでトランザクションを開始します。そして、状況に応じて、<code>commit</code>と<code>rollback</code>メソッドを呼び出します。</para>
<programlisting>import java.sql.*;&#13;import javax.sql.DataSource;&#13;import javax.naming.InitContext;&#13;import org.zkoss.util.logging.Log;&#13;import org.zkoss.zk.ui.Page;&#13;import org.zkoss.zk.ui.util.Initiator;&#13;&#13;public class TransInitiator implements Initiator {&#13;          private static final Log log = Log.lookup(TransInitiator.class);    &#13;          private Connection _conn;    &#13;          private boolean _err;    &#13;&#13;          public void doInit(Page page, Object[] args) {    &#13;                    try {        &#13;                              DataSource ds = (DataSource)new InitialContext()            &#13;                                        .lookup("java:comp/env/jdbc/MyDB");                &#13;                              _conn = ds.getConnection();            &#13;                    } catch (Throwable ex) {        &#13;                              throw UiException.Aide.wrap(ex);            &#13;                    }        &#13;          }    &#13;          public void doCatch(Throwable t) {    &#13;                    if (_conn != null) {        &#13;                              try {            &#13;                                        _err = true;                &#13;                                        _conn.rollback();                &#13;                              } catch (SQLException ex) {            &#13;                                        log.warning("Unable to roll back", ex);                &#13;                              }            &#13;                    }        &#13;          }    &#13;          public void doFinally() {    &#13;                    if (_conn != null) {        &#13;                              try {            &#13;                                        if (!_err)                &#13;                                                  _conn.commit();                    &#13;                              } catch (SQLException ex) {            &#13;                                        log.warning("Failed to commit", ex);                &#13;                              } finally {            &#13;                                        try {                &#13;                                                  _conn.close();                    &#13;                                        } catch (SQLException ex) {                &#13;                                                  log.warning("Unable to close transaction", ex);                    &#13;                                        }                &#13;                              }            &#13;                    }        &#13;          }    &#13;}&#13;</programlisting></sect3></sect2></sect1></chapter>
<chapter>
<title>13. ポータルとの統合</title>
<para>ZKはJSR168に対応するポータルにポートレットを提供し、ZUMLページを読み込みます。このポートレットはZKポートレットローダーと呼ばれ、<code>org.zkoss.zk.ui.httpDHtmlLayoutPortlet</code>として実装されます。</para><sect1><title>設定</title><sect2><title>
<code>WEB-INF/portlet.xml</code>
</title>
<para>使用するには、<code>WEB-INF/portlet.xml</code>に以下の定義を追加しなければなりません。ポータルに結果をキャッシュしないように、<code>Expiration-cache</code>は0に指定しなければなりません。</para>
<programlisting>&lt;portlet&gt;&#13;   &lt;description&gt;ZK loader for ZUML pages&lt;/description&gt;&#13;   &lt;portlet-name&gt;zkPortletLoader&lt;/portlet-name&gt;&#13;   &lt;display-name&gt;ZK Portlet Loader&lt;/display-name&gt;&#13;&#13;   &lt;portlet-class&gt;org.zkoss.zk.ui.http.DHtmlLayoutPortlet&lt;/portlet-class&gt;&#13;&#13;   &lt;expiration-cache&gt;0&lt;/expiration-cache&gt;&#13;   &lt;supports&gt;&#13;      &lt;mime-type&gt;text/html&lt;/mime-type&gt;&#13;      &lt;portlet-mode&gt;VIEW&lt;/portlet-mode&gt;&#13;   &lt;/supports&gt;&#13;&#13;   &lt;supported-locale&gt;en&lt;/supported-locale&gt;&#13;   &lt;portlet-info&gt;&#13;      &lt;title&gt;ZK&lt;/title&gt;&#13;      &lt;short-title&gt;ZK&lt;/short-title&gt;&#13;      &lt;keywords&gt;ZK,ZUML&lt;/keywords&gt;&#13;   &lt;/portlet-info&gt;&#13;&lt;/portlet&gt;&#13;</programlisting>
</sect2><sect2><title>
<code>WEB-INF/web.xml</code>
</title>
<para>ZKポートレットローダーは実際はZKローダー(<code>org.zkoss.zk.ui.http.DHtmlLayoutServlet</code>)にZUMLページの読み込みを任せます。このため、開発用リファレンス中のAppendix Aの中で説明したように<code>WEB-INF/web.xml</code>を設定しなければなりません。</para></sect2></sect1><sect1><title>使用方法</title><sect2><title>
<code>zk_page</code>と<code>zk_richlet</code>パラメーターと属性</title>
<para>特定なZUMLページを読み込むのに、リクエストパラメーター、ポートレット属性、またはzk_pageというポートレット設定(preference)を指定しなければなりません。リッチレットを読み込む場合は、zk_richletというポートレット設定を指定しなければなりません。</para>
<para>より正確に言うと、ZKポートレットローダーははじめにZUMLページのパスまたはリッチレットのパスに以下の位置から探し出します。1.の優先順位が一番高いです。</para>
<orderedlist>
<listitem>
<para>
<code>zk_page</code>と呼ばれるリクエストパラメータ(<code>RenderRequest</code>の <code>getParameter</code>)。見つかったら、それをZUMLページのパスとして使います。 </para>
</listitem>
<listitem>
<para>
<code>zk_page</code>と呼ばれるリクエスト属性(<code>RenderRequest</code>の<code>getAttribute</code>)。見つかったら、それをZUMLページのパスとして使います。 </para>
</listitem>
<listitem>
<para>
<code>zk_page</code>と呼ばれるリクエスト属性(<code>RenderRequest</code>の<code>getPortletPreference</code>の<code>getValue</code>)。見つかったら、それをZUMLページのパスとして使います。 </para>
</listitem>
<listitem>
<para>
<code>zk_richlet</code>と呼ばれるリクエスト属性(<code>RenderRequest</code>の<code>getParameter</code>)。見つかったら、それを<code>richlet</code>のパスとして使います。</para>
</listitem>
<listitem>
<para>
<code>zk_richlet</code>と呼ばれるリクエスト属性(<code>RenderRequest</code>の<code>getAttribute</code>)。見つかったら、それを<code>richlet</code>のパスとして使います。は<code>zk_richlet</code>と呼ばれます。</para>
</listitem>
<listitem>
<para>
<code>zk_richlet</code>と呼ばれるリクエスト設定[preference](<code>RenderRequest</code>の<code>getPortletPreferences</code>の<code>getValue</code>)。見つかったら、それを<code>richlet</code>のパスとして使います。</para>
</listitem>
<listitem>
<para>
<code>zk_page</code>と呼ばれる<code>initial</code>パラメータ(<code>PortletConfig</code>の<code>getInitParameter</code>)。見つかったら、それをZUMLページのパスとして使います。</para>
</listitem>
</orderedlist></sect2><sect2><title>例</title>
<para>リクエストパラメータまたは属性をポートレットに渡す方法はポータルによります。詳細には使用しているポータルのユーザーガイドを参考にしてください。以下はPotix Portalを使用した例です。</para>
<programlisting>&lt;layout contentType="text/html"&gt;&#13;   &lt;title&gt;ZK Porlet Demo&lt;/title&gt;&#13;   &lt;header name="Cache-Control" value="no-cache"/&gt;&#13;   &lt;header name="Pragma" value="no-cache"/&gt;&#13;&#13;   &lt;vbox&gt;&#13;      &lt;hbox&gt;&#13;         &lt;servlet page="sample1.zul"/&gt;&#13;         &lt;portlet name="zkdemo.zkLoader"&gt;&#13;            &lt;attribute name="zk_page" value="/test/sample2.zul"/&gt;&#13;         &lt;/portlet&gt;&#13;      &lt;/hbox&gt;&#13;   &lt;/vbox&gt;&#13;&#13;   &lt;molds uri="~./pxp/html/molds.xml"/&gt;&#13;&lt;/layout&gt;&#13;</programlisting>
<para/><graphic align="center" fileref="img/1000000000000290000000735EEBE1FC.png">
			
		</graphic></sect2></sect1></chapter>
<chapter>
<title>14. ZKの延長 </title>
<para>ZUMLページを処理するのに加えて、ZKパッケージでは多くの技術とツールを含んでいます。この章はそれらのいくつかの基本的な情報を提供します。興味があればJavadoc APIをご覧ください。</para><sect1><title>ロガー</title>
<para>Package: <code>org.zkoss.util.logging.Log</code>
</para>
<para>ZKが使用しているロガーは標準的なロガーで、<code>java.util.Logger</code>を元にしています。効率を向上させるため、それを<code>org.zkoss.util.logging.Log</code>にパッケージしています。典型的な例は以下です。</para>
<programlisting>import org.zkoss.util.logging.Log;&#13;class MyClass {&#13;          private static final Log log = Log.lookup(MyClass.class);    &#13;          public void f(Object v) {    &#13;                    if (log.debugable()) log.debug("Value is "+v);        &#13;          }    &#13;}&#13;</programlisting>
<para>ZKは標準ロガーを使用して、メッセージのログを取ります。使用しているウェブサーバーのログ機能を設定することで、何をログするのかを設定できます。ウェブサーバーでログを設定する方法はサーバーによって異なります。マニュアルを参照してください。もう一つの選択肢は、ZKが提供するログ設定メカニズムを使用することです。</para>
<para>【メモ】：パフォーマンスを向上させるため、デフォルトでは、すべてZKログのインスタンスは<code>org.zkoss</code>という名前のJavaロガーにマッピングされています。クラス単位でログをコントロールするには、以下のステートメントを呼び出して階層(hierarchy)機能をオンにしなければなりません。<code>Log.setHierarchy</code>(true);</para>
<para>【メモ】：次のセクションのように<code>WEB-INF/zk.xml</code>でログレベルを設定すれば、階層機能は自動的にオンになります。</para><sect2><title>ZKにてログレベルを設定する方法</title>
<para>ウェブサーバーのログを設定するほか、ZKが提供するログ設定メカニズムを使用できます。デフォルトでは、使用不可です。使用可能にするのに、<code>WEB-INF/zk.xml</code>中の以下のコンテンツを指定しなければなりません。より詳しくは開発用リファレンスを参照してください。</para>
<programlisting>&lt;zk&gt;&#13;   &lt;log&gt;&#13;      &lt;log-base&gt;org.zkoss&lt;/log-base&gt;&#13;   &lt;/log&gt;&#13;&lt;/zk&gt;&#13;</programlisting>
<para>また、以下のように<code>LogService</code>の<code>init</code>メソッドを呼び出すことで、手動でログ設定メカニズムを使用可能にすることもできます。</para>
<programlisting>org.zkoss.util.logging.LogService.init("org.zkoss");&#13;</programlisting>
<para>
<code>org.zkoss</code>だけでなくすべてをログしする場合、<code>log-base</code>を空に指定します。</para>
<para>メカニズムが使用可能になると、ZKはスタートアップにクラスパスを検索し、<code>i3-log.conf</code>を探します。見つかったら、ZKはそのコンテンツを読み込み、ログレベルを初期化します。そして、ZKはこのファイルを監視し続け、ファイルが変更されたら、コンテンツを再読み込みます。</para></sect2><sect2><title>
<code>i3-log.conf</code>の中身</title>
<para>
<code>i3-log.conf</code>の例は以下のようです。</para>
<programlisting>org.zkoss.zk.ui.impl.UiEngineImpl=FINER&#13;   #Make the log level of the specified class to FINERorg.zkoss.zk.ui.http=DEBUG&#13;   #Make the log level of the specified package to DEBUG&#13;org.zkoss.zk.au.http.DHtmlUpdateServlet=INHERIT&#13;  #Clear the log level of a specified class such that it inherits what&#13;   #has been defined above (Default: INFO)&#13;org.zkoss.zk.ui=OFF&#13;   #Turn off the log for the specified package&#13;org.zkoss=WARNING&#13;   #Make all log levels of ZK classes to WARNING except those specified here&#13;</programlisting>
<sect3><title>許可レベル</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>レベル</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>OFF</code>
</para>
</entry>
<entry>
<para>何もメッセージをログしません。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>ERROR</code>
</para>
</entry>
<entry>
<para>エラーメッセージを提供します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>WARNING</code>
</para>
</entry>
<entry>
<para>警告メッセージを提供します。また、ERRORを意味しています。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>INFO</code>
</para>
</entry>
<entry>
<para>情報メッセージを提供します。また、ERRORとWARNINGを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>DEBUG</code>
</para>
</entry>
<entry>
<para>デバッグを目的とするトレース情報を提供します。また、ERRORとWARNINGとINFOを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>FINER</code>
</para>
</entry>
<entry>
<para>デバッグを目的とする、かなり詳しいトレース情報を提供します。ERRORとWARNINGとINFO、DEBUGを意味します。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>INHERIT</code>
</para>
</entry>
<entry>
<para>指定したパッケージまたはクラスに設定したレベルをクリアします。つまりログレベルはその親ノードと同じになります。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<code>i3-log.conf</code>の位置</title>
<para>はじめ、ZKはクラスパスの中でこのファイルを探します。見つからなかった場合、<code>conf</code>ディレクトリーを探します。</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>アプリケーションサーバー</para>
</entry>
<entry>
<para>位置</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Tomcat</para>
</entry>
<entry>
<para>
<code>$TOMCAT_HOME/conf</code>ディレクトリーの下に<code>i3-log.conf</code>におきます。</para>
</entry>
</row>
<row>
<entry>
<para>Others</para>
</entry>
<entry>
<para>最初にconfディレクトリーを試してください。だめでしたら<code>org.zkoss.io.conf.dir</code>
<code>　</code>ディレクトリーと呼ばれるシステムプロパティを<code>i3-log.conf</code>があるディレクトリーに設定します。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>すべてのログを使用不可にする</title>
<para>いくつかのログは<code>i3-log.conf</code>を読み込む前に生成されます。完全にすべてのログを使用不可にする場合、ウェブサーバー<footnote>
<para>ZKは標準的なログ機能を使用しています。<code>i3-log.conf</code>を設定しない限り、デフォルトログレベルはウェブサーバーの設定に従います。 (ほとんどの場合、レベルは INFO)</para>
</footnote>のログを設定するか、<code>WEB-INF/web.xml</code>の中で<code>DhtmlLayoutServlet</code>を設定する時に<code>log-level</code>を指定します。より詳しくは開発用リファレンスを参照してください。</para>
<programlisting>&lt;servlet&gt;&#13;   &lt;servlet-name&gt;zkLoader&lt;/servlet-name&gt;&#13;   &lt;servlet-class&gt;&#13;org.zkoss.zk.ui.http.DHtmlLayoutServlet&lt;/servlet-class&gt;&#13;   &lt;init-param&gt;&#13;      &lt;param-name&gt;log-level&lt;/param-name&gt;&#13;      &lt;param-value&gt;OFF&lt;/param-value&gt;&#13;   &lt;/init-param&gt;&#13;...&#13;</programlisting>
</sect2></sect1><sect1><title>DSP</title>
<para>Package: <code>org.zkoss.web.servlet.dsp</code>
</para>
<para>JSPと類似しているテンプレート技術です。JSP技術と同じようなシンタックスを使用します。JSPとは違って、DSPはランタイムで翻訳されますので、デプロイするのはより簡単です。Javaコンパイラーはランタイム環境では必要ありません。さらに、jarファイルの中でDSPページを配布できます。ZKもこの方法で配布しています。</para>
<para>しかし、DSPページの中でJavaコードを埋め込むことはできません。TLDファイルを使用してDSPの動作を追加することはできますが、JSPタグとは異なります。</para>
<para>ウェブアプリケーションでDSPを使用する場合、<code>WEB-INF/web.xml</code>を設定して以下のコードを追加しなければなりません。</para>
<programlisting>   &lt;!-- ///////////// --&gt;&#13;   &lt;!-- DSP (optional) --&gt;&#13;   &lt;servlet&gt;&#13;      &lt;description&gt;&lt;![CDATA[&#13;The servlet loads the DSP pages.&#13;      ]]&gt;&lt;/description&gt;&#13;      &lt;servlet-name&gt;dspLoader&lt;/servlet-name&gt;&#13;      &lt;servlet-class&gt;org.zkoss.web.servlet.dsp.InterpreterServlet&lt;/servlet-class&gt;&#13;&#13;      &lt;!-- Specify class-resource, if you want to access TLD defined in jar files --&gt;&#13;     &lt;init-param&gt;&#13;         &lt;param-name&gt;class-resource&lt;/param-name&gt;&#13;         &lt;param-value&gt;true&lt;/param-value&gt;&#13;      &lt;/init-param&gt;&#13;   &lt;/servlet&gt;&#13;   &lt;servlet-mapping&gt;&#13;      &lt;servlet-name&gt;dspLoader&lt;/servlet-name&gt;&#13;      &lt;url-pattern&gt;*.dsp&lt;/url-pattern&gt;&#13;   &lt;/servlet-mapping&gt;&#13;</programlisting>
<para>【ヒント】： DSPローダーのマッピングはオプションです。DSPシンタックスでウェブページを作成する場合のみそれを指定しましょう。ZKの標準のコンポーネントはテンプレート技術としてDSPを使用しますが、コンポーネントは実際、ZKローダーによって直接コントロールされます。</para><sect2><title>
<code>init-param</code> </title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>init-param</para>
</entry>
<entry>
<para>説明</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>
<code>Charset</code>
</para>
</entry>
<entry>
<para>
<code>[Optiona][Default: UTF-8]</code>
</para>
<para>出力のエンコード種類を指定します。何も指定しない場合、システムデフォルトエンコードが使用されます。</para>
</entry>
</row>
<row>
<entry>
<para>
<code>class-resource</code>
</para>
</entry>
<entry>
<para>
<code>[Optional][Default: false]</code>
</para>
<para>サーブレットコンテキストに加えて、クラスローダーからのリソースを読み込むかどうか指定します。</para>
<para>例えば、以下のコードが実行されると、ウェブアプリケーションの中の<code>WEB-INF/tld/web</code>ディレクトリーを初めに検索します。オプションがTrueのままで見つからなかったら、場合、クラスローダーに<code>/web/WEB-INF/tld/web/core.dsp.tld</code>を検索させます。</para>
<para><code>&lt;%@ taglib uri="/WEB-INF/tld/web/core.dsp.tld" prefix="c" %&gt;</code></para>
<para>ウェブアプリケーションにTLDのコピーを作る必要がないため、コンポーネントのDSPをカスタマイズする場合、この機能は便利です。</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2></sect1><sect1><title>iDOM</title>
<para>Package: <code>org.zkoss.idom</code>
</para>
<para>W3C DOMの実装。JDOMを手本とし、XMLに要素や属性のような具体的なクラスが使われています。また、iDOMは<code>org.w3c.dom.Element</code>といったW3C　APIを実装します。こうしてW3C DOMのみ受け付けるXMLユーティリティとiDOMをシームレスに使用できます。</para></sect1></chapter>
</book>
