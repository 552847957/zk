<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en-US">
<title>The Component Development Guide</title>
<subtitle>Versions 3.0, 3.5 and 3.6</subtitle>
<bookinfo>
<copyright>
<year>2009</year>
<holder>Potix Corporation. All rights reserved.</holder>
</copyright>
</bookinfo>
<para/>
<para>
<graphic fileref="images/potix.jpg"/>
</para>
<para>SIMPLY RICH</para>
<para>ZKTM</para>
<para>June 2008</para>
<para>Potix Corporation</para>
<para>Revision 4</para>
<para/>
<para/>
<para>Copyright © Potix Corporation. All rights reserved.</para>
<para>The material in this document is for information only and is subject to change without notice. While reasonable efforts have been made to assure its accuracy, Potix Corporation assumes no liability resulting from errors or omissions in this document, or from the use of the information contained herein.</para>
<para>Potix Corporation may have patents, patent applications, copyright or other intellectual property rights covering the subject matter of this document. The furnishing of this document does not give you any license to these patents, copyrights or other intellectual property.</para>
<para>Potix Corporation reserves the right to make changes in the product design without reservation and without notification to its users.</para>
<para>The Potix logo and ZK are trademarks of Potix Corporation.</para>
<para>All other product names are trademarks, registered trademarks, or trade names of their respective owners.</para>
<chapter>
<title>1. Introduction</title>
<para>Welcome to ZK, the simplest way to enrich Web Applications.</para>
<para>The Component Development Guide describes how to develop ZK components. For ZK concepts and features refer to the Developer's Guide. For installation refer to the Quick Start Guide. For a full description of component properties and methods refer to the Developer's Reference.</para>
<para>In this chapter, we will introduce you the basic concepts of ZK components and component development.</para><sect1><title>Two Sides of a Component</title>
<para>A component consists of two parts: view and handle. They are like two sides of the same coin. The view is the visual part of a component, which is running at the browser and interacts with the user. The handle is a Java object running at the server and interacts with the application.</para>
<para/>
<para>
<graphic fileref="images/ComponentTwoSides.gif"/>
</para><sect2><title>View</title>
<para>The view is the visual part of a component. It is the appearance that the user sees and interacts with. When a component is created and attached to a page, its view is created at the client to provide the visual appearance.</para>
<para>For example, when the application creates a button (at the server), the button-look view will be created accordingly at the client, so the user can click it.</para></sect2><sect2><title>Handle</title>
<para>The handle is actually a Java object running at the server. It have all states and API that the application can access. From application's viewpoint, all it knows and access is this Java object. In other words, the application doesn't communicate with the user directly via Internet. Rather, the application talks to the Java object and the Java object (by and large, the component) updates the visual part accordingly. Similarly, if an user access the visual part, it is component's job to update the Java object and notify the application (with events).</para>
<para>The application don't need to know anything about Ajax, Java Mobile, Google Android or Flash<footnote>
<para>The application can have his own client codes to communicate with the client and/or user directly. It is an option.</para>
</footnote>. The client and communication technologies are encapsulated by the implementation of the component(s).</para></sect2></sect1><sect1><title>Page and Rendering</title>
<para>When a component is created (e.g., new Button()), it doesn't belong to any page. Furthermore, there is no view at the client if it doesn't belong to a page. It also means any update to it won't have any effect at the client.</para>
<para>On the other hand, once a component is attached to a page<footnote>
<para>To attach a component to a page, the application can call either setPage() with a page, or setParent() with a component belonging to a page.</para>
</footnote> (i.e., belongs to a page), any update to it will cse the view to change accordingly<footnote>
<para>Whether to update the view is under control of the component when it belongs to a page After all, it is a component spec.</para>
</footnote>.</para>
<para>To maximize the performance, ZK does not update the client immediately. Rather, it accumulated all updates, optimize them, and then send a minimal collection of updates to the client at the final phase of the processing. The final phase is called the Rendering phase.</para>
<para>From application's viewpoint, there are four different phases<footnote>
<para>Refer to the Developer's Guide for more information</para>
</footnote>. However, from component's viewpoint, all other phases are the same, so you might say there are the rendering phase and the non-rendering phases.</para><sect2><title>The Non-Rendering Phases</title>
<para>In the phases other than Rendering, the application and ZK are allowed to access any methods of the component except the redraw method. It is the component's job to notify ZK if a component needs to be redrawn, or some states of the view have to change.</para>
<para>For example, you have a method that will cause the client to redraw the view, then you can call back the invalidate method.</para>
<programlisting>public MyComp extends org.zkoss.zk.ui.AbstractComponent {&#13;</programlisting>
<para>public void setValue(String value) {</para>
<para>_value = value;</para>
<para>invalidate();</para>
<para>}</para>
<para>}</para>
<para>The invocation of invalidate notifies that a component has to be redrawn in the Rendering phase. It doesn't redraw it immediately. Rather, ZK accumulates all these updates and processes them later in the Rendering phase.</para></sect2><sect2><title>The Rendering Phase</title>
<para>After all events are processed, ZK starts the rendering phase to redraw components that are invalidated in other phases. In other words, if a component's invalidate method was ever called, ZK will invoke the redraw method in the Rendering phase.</para>
<para>In the Rendering phase, only the redraw method is invoked and the invalidate method cannot be called – it also implies almost all methods other than redraw shall not be called.</para><sect3><title>Molds</title>
<para>The skeletal implementation of AbstractComponent introduces the concept of molds. A mold is a view of a component. For example, tabbox supports the default and accordion molds to provide different views for the same component.</para>
<programlisting>&lt;tabbox mold="default"&gt;&#13;&lt;/tabbox&gt;&#13;&lt;tabbox mold="accordion"&gt;&#13;&lt;/tabbox&gt;&#13;</programlisting>
<para>To minimize the development effect, it is recommended to extend from AbstractComponent or one of its deriving classes. With AbstractComponent, you don't implement the redraw method directly. Rather, you can use your favorite Servlet technologies to generate the view, such as DSP<footnote>
<para>DSP (Dynamical Server Page) is a template technology developed by Potix. It is similar to JSP, but it can be embedded into a JAR file and no need to be compiled to Java codes first.</para>
</footnote> and JSP.</para></sect3></sect2></sect1><sect1><title>Trilogy of Component Development</title>
<para>From development perspectives, there are three steps to implement a ZK component. First, you have to design the view. Second, you have to implement the handle (as a Java class) at the server. Finally, you have to configure it with a XML file, such that it is accessible to the applications.</para>
<para>How to implement the view depends on the client technology. For example, HTML tags and Java codes are required for the Ajax browsers, while Java MIDlet is required for Java Mobile clients. For the convenience of description, we focus on the Ajax browsers in this guide. The following illustrates the relationship among them.</para>
<para/>
<para>
<graphic fileref="images/ComponentTrilogy.gif"/>
</para><sect2><title>Development of View</title>
<para>For Ajax browsers, the view of a component is basically a collection of HTML tags and, optionally, JavaScript methods. The HTML tags are the visual presentation, while JavaScript methods initialize, clean up, listen to browser events and communicate with the server.</para><sect3><title>HTML Tags</title>
<para>For Ajax browser, the visual presentation is implemented with a collection of HTML tags. For example, assume you want to use the HTML's BUTTON tag to represent a component, and then the visual presentation might look as follows.</para>
<programlisting>&lt;BUTTON id="z_ed_0" z.type="mycomps.MyButton"&gt;I am a button&lt;/BUTTON&gt;&#13;</programlisting>
<para>where z_ed_0 is the component's UUID (which is assigned by ZK Loader), and z.type is a special attribute used to indicate the type of the component.</para>
<para>The visual presentation are running at and interpreted by the browser. However, they are generated at the server, when the redraw method is called. Everything written to the writer argument passed to the redraw method will be sent to the client.</para>
<para>Instead of implementing redraw, you can extend from AbstractComponent and provide a or its deriving classes), and not to implement redraw directly. Rather, implement the so-called mold with your favorite Servlet technology, such as DSP, JSP, and so on. For convenience of description, we will use DSP mostly in this guide.</para>
<para>In addition to Java Servlet technologies, you can implement it with a so-called component renderer (org.zkoss.zk.ui.util.ComponentRenderer) instead. It is a bit harder to read but with better performance. We will talk more about it later.</para></sect3><sect3><title>JavaScript Methods</title>
<para>Except implementing a very simple component, you usually need to provide some JavaScript codes to interact with the user, to manipulate HTML tags, and to communicate with the server. The JavaScript codes depending on their purpose can be grouped into separate methods. For example, assume you want to register an event listener when the component is initialized at the browser, and then the JavaScript codes might look as follows.</para>
<programlisting>zkMyButton.init = function (cmp) {&#13;    zk.listen(cmp, "click", function (evt) {/*my listener*/});    &#13;};&#13;</programlisting>
<para>where the method name is determined by the component type and when to call. In this example, the button's z.type is mycomps.MyButton (specified in the z.type attribute as described above). It means the JavaScript codes are located in a JavaScript file called, /web/js/mycomps.js. (and it must be locatable by the class loader), and the component type is MyButton.</para>
<para>Since we want it to run during initialization, the method name shall be zkMyButton.init (= "zk" + "Type" + ".when"). Similarly, If you want a method to be called when the browser is resized, the method name will be zkMyButton.onSize. We will talk more about it later.</para></sect3></sect2><sect2><title>Development of Handle</title>
<para>The handle is the states and API of the component that Web applications access. More precisely, it is a Java class that implements the org.zkoss.zk.ui.Component interface.</para>
<para>You generally don't implement this interface directly. Rather, you, depending on the requrirement, extend from one of the existent classes, such as org.zkoss.zk.ui.AbstractComponent, org.zkoss.zk.ui.HtmlBasedComponent, and org.zkoss.zul.XulComponent.</para>
<para>For example, assume we want to extend the most skeletal implementation AbstractComponent, and then the Java class might look as follows.</para>
<programlisting>public MyButton extends AbstractComponent {&#13;}&#13;</programlisting>
<para>If you are extending from one of the skeletal implementations, there is basically no abstract method you have to implement other than component-specific methods.</para></sect2><sect2><title>Configuration</title>
<para>Once you implement the view and handle, you can specify the component in a XML file such that ZK will load it and the application can use it. The configuration file is called lang-addon.xml<footnote>
<para>If you want to define a brand new language rather than adding components to an existent one, you shall use lang.xml instead.</para>
</footnote>. There are two locations you can place this file. One is under the /metainfo/zk directory that is locatable by classpath (usually part of a JAR file). The other is inside a Web application (part of a WAR file) by specifying the correct path in /WEB-INF/zk.xml<footnote>
<para>Refer to the Developer's Reference for details.</para>
</footnote>.</para>
<para>Let us assume the view is /web/myaddon/button.dsp and the handle is the com.myaddon.MyButton class. Then, the configuration will look like as follows.</para>
<programlisting>&lt;language-addon&gt;&#13;        &lt;addon-name&gt;myAddon&lt;/addon-name&gt;&lt;language-name&gt;xul/html&lt;/language-name&gt;        &#13;    &lt;component&gt;    &#13;        &lt;component-name&gt;mybutton&lt;/component-name&gt;        &#13;        &lt;component-class&gt;com.myaddon.MyButton&lt;/component-class&gt;        &#13;        &lt;mold&gt;        &#13;            &lt;mold-name&gt;default&lt;/mold-name&gt;            &#13;            &lt;mold-uri&gt;~./web/myaddon/button.dsp&lt;/mold-uri&gt;            &#13;        &lt;/mold&gt;        &#13;    &lt;/component&gt;    &#13;&lt;/language-addon&gt;&#13;</programlisting>
<para>As shown, each lang-addon.xml must specify an unique name (addon-name) and the language it belongs to (language-name). Each component definition must specify the component name (component-name), the handle (component-class) and the view (mold). Each component can have multiple views and each view has a name (mold-name). The default mold name is default., which the mold you must have (unless you want to implement the redraw method directly).</para></sect2></sect1></chapter>
<chapter>
<title>2. Handle</title>
<para>The handle is a Java object running at the server, with which the application access. From application's viewpoint, it is everything about a component, so, in the context of application development, we usually just call it a component rather than separating the concept of view and handle.</para>
<para>The handle must implement two interfaces: org.zkoss.zk.ui.Component and org.zkoss.zk.ui.sys.ComonentCtrl. Component is a collection of APIs that applications could access, while ComponentCtrl is a collection of APIs that are accessible only by ZK and component development.</para>
<para>However, you generally don't implement them from scratch. Rather, you pick up one of skeletal implementations or an existent component that fulfill your requirement, and then extend from them. The following section describes each of these skeletal implementations.</para><sect1><title>Skeletal Implementations</title>
<para>ZK provides several skeletal implementations to minimize the effort required to implement a component. </para><sect2><title>The org.zkoss.zk.ui.AbstractComponent Class</title>
<para>AbstractComponent is the most base skeletal implementation. Use it only if the component you implement is for non-HTML clients (such as mobile devices).</para>
<para>AbstractComponent implements the redraw method to support molds, annotations, ID space, page association, parent-children relationship, event listener registration, serialization, clone, and all component APIs.</para>
<para>The use of AbstractComponent is straightforward: just implement your own methods – no abstract method to implement at all. For example,</para>
<programlisting>public class MyComp extends org.zkoss.zk.ui.AbstractComponent {&#13;    private Object _value;    &#13;    public Object getValue() {    &#13;        return _value;        &#13;    }    &#13;    public void setValue(Object value) {    &#13;        _value = value;        &#13;    }    &#13;}&#13;</programlisting>
<para>In addition to Component and ComponentCtrl, AbstractComponent also provides a collection of utilities to minimize the effort of the implementation.</para><sect3><title>Utilities to Communicate with the Client</title>
<para>AbstractComponent provides three kinds of methods to communicate with the client: invalidates, smart updates and AU responses. Invalidates notify ZK that a component needs to be redrawn completely. Smart updates notify ZK that a property of a component has been changed. AU responses allows a handle to ask the view to do anything it wants, such as change focus, start a timer, execute a piece of JavaScript codes and so on.</para>
<programlisting>public class MyComp extends org.zkoss.zk.ui.AbstractComponent {&#13;    private String _label = "";    &#13;    public String getLabel() {    &#13;        return _label;        &#13;    }    &#13;    public void setLabel(String label) {    &#13;        if (!label.equals(_label)) {        &#13;            _label = label;            &#13;            smartUpdate("label", _label);            &#13;        }        &#13;    }    &#13;    public void updateContent(Object value) {    &#13;        //whatever...        &#13;        invalidate();        &#13;    }    &#13;}&#13;</programlisting>
<para>The communication between the view and the handle is one of the most important topic. We will discuss it later more detailedly.</para></sect3><sect3><title>Utilities to Generate the View</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Method</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>isAsapRequired</para>
</entry>
<entry>
<para>Returns if any non-deferrable event listener is registered for the specified event.</para>
</entry>
</row>
<row>
<entry>
<para>appendAsapAttr</para>
</entry>
<entry>
<para>Detects if a non-deferrable event is registered, and appends a special attribute to denote it if true.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Extra Controls</title>
<para>To encapsulate API that are used only for component development, we introduce a concept called extra controls (aka., extra interfaces). If a component needs to provide some extra interfaces that will be used only for component development, it can override the newExtraCtrl method to instantiate an instance carrying the extra interfaces. For example, Slider allows the client to change the position of the slider, and then it has to implements the org.zkoss.zk.ui.ext.client.Scrollable interface. As depicted below, Slider first implements the ExtraCtrl class to implement the Scrollable interface. Then, Slider overrides newExtraCtrl to instantiate an ExtraCtrl instance.</para>
<programlisting>public class Slider extends org.zkoss.zk.ui.HtmlBasedComponent {&#13;    private int _curpos;    &#13;    protected Object newExtraCtrl() {return new ExtraCtrl();}protected class ExtraCtrl extends HtmlBasedComponent.ExtraCtrl    &#13;                                    implements Scrollable {public final void setCurposByClient(int curpos) {_curpos = curpos;}}}                                    &#13;</programlisting>
<para>Notice that you generally have to extend from base class's extra controls, such that it inherits all extra controls. In the above case, it extends from the HtmlBasedComponent.ExtraCtrl class.</para></sect3></sect2><sect2><title>The org.zkoss.zk.ui.HtmlBasedComponent Class</title>
<para>If you are implementing a component for HTML-based browser, you might consider to extend from HtmlBasedComponent. It extends from AbstractComponent to provide more HTML features, such as CSS style, CSS class, width, height, drag-and-drop, tooltip text, and so on. By extending from HtmlBasedComponent, your component inherits the HTML features for free – no special initialization, implementation, or invocation is required.</para>
<para>In additions, it provides </para><sect3><title>Utilities to Generate the View</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>getInnerAttrsgetOuterAttrs</para>
</entry>
<entry>
<para>HtmlBasedComponent assumes the view might have nested tags – the outer and inner tags. Then, getInnerAttrs and getOuterAttrs are used to generate the attributes for the inner and outer tags correspondingly. If a component isn't implemented with the nested tags, it just concatenates the return of both methods as shown below. Refer to the next chapter for more detailed about the view.</para>
<programlisting>&lt;span id="${self.uuid}"${self.outAttrs}${self.innerAttrs}&gt;&#13;&lt;/span&gt;&#13;</programlisting>
</entry>
</row>
<row>
<entry>
<para>getRealSclassgetRealStyle</para>
</entry>
<entry>
<para>When getOuterAttrs is called, it invokes these two methods to generate the class and style attributes. By default, they delegate the invocation to getSclass and getStyle, respectively.</para>
<para>If you need to add a CSS style (in addition to that an user specifies by calling setStyle), you can override getRealStyle. For exmple,</para>
<programlisting>    protected String getRealStyle() {return super.getRealStyle() + "padding:5px;";    &#13;}&#13;</programlisting>
</entry>
</row>
<row>
<entry>
<para>getAllOnClickAttrs</para>
</entry>
<entry>
<para>Used to generate attributes for onClick, onDoubleClick and onRightClick events. If the component supports these events, it shall call back this method in getOuterAttrs. Then, if the application registers a listener for them, the event will be sent back from the client automically (non-deferrable; no JavaScript codes required).</para>
<programlisting>    public String getOuterAttrs() {String attrs = super.getOuterAttrs();    &#13;        String clkattrs = getAllOnClickAttrs();rerturn clkattrs != null ? attrs + clkattrs: attrs;        &#13;}&#13;</programlisting>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>The org.zkoss.zul.impl.XulElement Class</title>
<para>XulElement is the skeletal implementation for XUL components. If you want to implement a component that will be added to the xul/html language, this class is a good starting point.</para>
<para>XulElement extends from HtmlBasedComonent. It provides the XUL features, such as popup, context menu, tooltip and client-side-action.</para><sect3><title>Utilities to Generate the View</title>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>None</para>
</entry>
<entry>
<para>None</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2></sect1><sect1><title>Communication with the Client</title>
<para>It is the component's job to communicate between the view and the handle, while the communication is transparent to the application developers.</para>
<para>The communication is kind of pitch-and-catch. It usually involves the view and the handle. In this section, we focus on the handle (the server side). The view (the client side) will be described in the later chapter.</para><sect2><title>Response to the Client</title>
<para>There are three ways to send a response to the view (the client side): invalidates, smart updates and responses. An invalidate causes the whole view of the component to be redrawn. A smart update causes a particular attribute of the component's view to be changed. An AU response is a fully customizable response to manipulate the component's view. </para><sect3><title>Invalidates</title>
<para>public void invalidate();</para>
<para>When the invalidate method is called, the component is marked as dirty, and then the redraw method will be called to generate the whole view to client in the Rendering phase.</para>
<para>The typical use is to call invalidate(), when the invocation of a method changes the view.</para>
<programlisting>public void setLabel(String label) {&#13;    if (!Objects8org.zkoss.lang.Objects.equals() compares if two objects equal (even both null)..equals(_label, label)) {    &#13;        _label = label;        &#13;        invalidate();        &#13;    }    &#13;}&#13;</programlisting>
<para>It is the simplest way to update the view since we don't need to write any JavaScript codes. The view is updated with the redrawn view automatically by ZK. However, if the component contains a lot of child components (such as a grid), it is costly to redraw the whole view (since it has to also redraw all child components). Thus, if the change is mirror, the performance will be better if you use smart updates or AU responses.</para>
<para>Note: ZK optimizes the invalidates before invoking the redraw method. For example, a component will be redrawn at most one time, even if it is invalidated multiple times, or its parent is invalidated, too.</para></sect3><sect3><title>Smart Updates</title>
<para>public void smartUpdate(String attrName, String value);public void smartUpdate(String attrName, DeferredValue value);public void smartUpdate(String attrName, boolean value);public void smartUpdate(String attrName, int value);</para>
<para>A smart update is used to modify an attribute of the view. Unlike an invalidate, it won't cause the component to be redrawn.</para>
<programlisting>public void setReadonly(boolean readonly) {&#13;                    if (_readonly != readonly) {_readonly = readonly;smartUpdate("readOnly", _readonly);                    &#13;    }}    &#13;</programlisting>
<para>By default, ZK Client Engine will update the attribute of the most outer DOM element (of the view) with the specified name. For example, assume the most outer DOM element of the above example is elem, it is equivalent to invoke the following JavaScript codes at the client:</para>
<programlisting>elem.readOnly = _readonly;&#13;</programlisting>
<para>ZK Client Engine is smart enough to invoke the correct method for updating a field. For example, elem.className for the class attribute, elem.setAttribute() for unrecognized attributes, and so on.</para>
<para>In additions, you can provide your own JavaScript codes to handle smart updates at the client, if you want to handle smart updates in a component-specific way.</para>
<para>Note: if both smart updates and invalidates are called against the same component, the smart updates will be ignored – after all, the whole view will be redrawn.</para></sect3><sect3><title>AU Responses</title>
<para>public void response(String key, AuResponse<footnote>
<para>org.zkoss.zk.au.AuResponse</para>
</footnote> response);</para>
<para>An AU response is the lowest-level response. You can fully customize it to do whatever you want.</para>
<para>However, you rarely need to use AU responses directly, since invalidates and smart updates can do almost everything you want. Remember you can provide your custom JavaScript codes to handle smart updates at the client. In other words, you can use smart updates to execute something at the client; not just modify an attribute.</para>
<para>Unlike smart updates, an AU responses are always sent to the client even if an invalidate is called against the same component. It is one of the reason we have to use AU responses for certain circumstances.</para>
<para>For example, let us say we want to implement the focus feature. Since we want to change the focus to a component even if it is invalidated, an AU response is the only choice.</para>
<programlisting>    public void focus() {response("focus", new AuFocus(this));}    &#13;</programlisting>
<para>where AuFocus is one of built-in AU responses extending from AuResponse with predefined functionality.</para><sect4><title>Depends</title>
<para>We say an AU response depends on a component, if it shall not be sent to the client when the component is removed. It is controlled by the depends argument of the constructor.</para>
<para>In most cases, an AU response depends on a component.</para>
<para>Note: Unlike smart updates, the AU response is sent to the client even if the component it depends is invalidated (until the component is removed).</para></sect4><sect4><title>Built-in AU Responses</title>
<para>There are a lot of built-in AU responses such as AuAlert, AuInvoke, AuPrint and so on in the org.zkoss.zk.au.out package. When you think you have to develop your own AU response, check Javadoc first if any of them fulfills your requirement.</para>
<para>AuInvoke and AuScript are AU response used to invoke the JavaScript codes at the client. AuInoke is used to invoke a JavaScript method depending on the component's type, while AuScript invokes a piece of codes regardless if it is part of a component's view.</para>
<programlisting>public void play() {&#13;    response("play", new AuScript(this, "alert('Hi')"));    &#13;</programlisting>
<para>}</para>
<para>We discuss how to create your custom AU response in the later chapter, since it requires some JavaScript codes.</para></sect4></sect3></sect2><sect2><title>Request to the Server</title>
<para>To notify what happens at the client, the view has to send an AU request (org.zkoss.zk.au.AuRequest) to the server. The AU request is processed by the so-called command. Whether to update the component and whether to post an event depends on how a command is implemented.</para><sect3><title>Command</title>
<para>A command (org.zkoss.zk.au.Command) is used to process certain type of AU requests. When ZK Update Engine receives an AU request, it associates a command with it. Then, it invokes the process method of the command to process it. The processing, depending on the requirement, usually updates the content of the component and then posts an event to notify the application.</para>
<para>For example, the org.zkoss.zk.au.in.RemoveCommand command is registered to process all AU requests called remove. Thus, if an AU request called remove is received, the process method of RemoveCommand will be invoked. Here is how RemoveCommand is implemented:</para>
<programlisting>                                        public class RemoveCommand extends Command {public RemoveCommand(String evtnm, int flags) {super(evtnm, flags);}protected void process(AuRequest request) {final Component comp = request.getComponent();if (comp != null) comp.detach();}}                                        &#13;</programlisting>
<para>Note: ZK uses the same command instance for the same type of AU requests, so concurrent access of the command is possible.</para>
<para>See Also: Refer to the Process Request at the Server section in the next chapter for more details.</para></sect3><sect3><title>Event</title>
<para>When a command processing a request, it might post one or several events. For example, InputCommand will post the onChange event as an instance of org.zkoss.zk.ui.event.InputEvent. The events are queued until all commands are processed. In other words, the events are processed by the application, after the components have been updated.</para>
<para>There is a common question for developing a component: shall I update the component's state in a command or in an event listener. In general, it is better to use event to notify the application only. And, it is better to update the component's state in a command. After all, the application might stop the event propagation at any time (Event.stopPropagation).</para>
<para>On the other hand, we can utilize the stop-propagation feature to allow the application to customize some behavior. For example, the list box sorts the list items in the onSort listener, such that the application can provide its own sorting by adding its own listener and stop the event propagation.</para></sect3></sect2></sect1><sect1><title>Miscellaneous Features</title><sect2><title>Drag-and-Drop, Tooltip and Context Menu</title>
<para>They are supported automatically with custom JavaScript codes as long as you extends your component handle from org.zkoss.zul.impl.XulElement.</para></sect2><sect2><title>Click, Right Click and Double Click</title>
<para>The onClick, onRightClick and onDoubleClick events are handled automatically by ZK Client Engine. All you need to do is to generate the correct attributes by use of the appendAsapAttr method.</para>
<programlisting>public String getOuterAttrs() {final StringBuffer sb = new StringBuffer(super.getOuterAttrs());appendAsapAttr(sb, Events.ON_CLICK);appendAsapAttr(sb, Events.ON_DOUBLE_CLICK);appendAsapAttr(sb, Events.ON_RIGHT_CLICK);return sb.otString();                    &#13;}&#13;</programlisting>
<para>HtmlBasedCcomponent provides an utility called getAllOnClickAttrs to simplify the job.</para>
<programlisting>public String getOuterAttrs() {String attrs = super.getOuterAttrs();    &#13;        String clkattrs = getAllOnClickAttrs();rerturn clkattrs != null ? attrs + clkattrs: attrs;        &#13;}&#13;</programlisting></sect2></sect1></chapter>
<chapter>
<title>3. View</title>
<para>The view is the visual presentation of a component at the client. Depending on the client, it could be HTML tags plus JavaScript codes, MIDlet, XML node and Flash. For sake of description, we discuss only the view for the Ajax browsers, i.e., HTML tags plus JavaScript codes.</para><sect1><title>HTML Tags</title>
<para>You can choose whatever Servlet technologies you prefer to generate HTML tags. ZK (more precisely, AbstractComponent) uses the include method of javax.servlet.RequestDispatcher to include the HTML tags you generate for the view.</para>
<para>For sake of description, we use DSP (Dynamical Server Page) in most examples. It is a template technology developed by ZK. The use is similar to JSP except you cannot embed Java codes in it. There are several benefits, such as no compilation required, ability to be part of JAR file, no JSP/EL requirement and so on.</para><sect2><title>Retrieve Component Being Rendered</title>
<para>When the view being rendered, the related information is passed through the request attribute called arg, which is a Map instance. In arg, the component being rendered is stored in the entry called self. That is, you can retrieve it with the following EL expression:</para>
<programlisting>${requestScope.arg.self}&#13;</programlisting>
<para>With Java codes, you can retrieve it as follows.</para>
<programlisting>void doGet(HttpServletRequest request, HttpServletResponse response) {&#13;    Component self = (Component)((Map)request.getAttribute("arg")).get("self");...    &#13;</programlisting>
<para>Here is the example of org.zkoss.zul.Image's view (in DSP):</para>
<programlisting>&lt;%@ taglib uri="http://www.zkoss.org/dsp/web/core" prefix="c" %&gt;&lt;c:set var="self" value="${requestScope.arg.self}"/&gt;&lt;img id="${self.uuid}" z.type="zul.widget.Img"${self.outerAttrs}${self.innerAttrs}/&gt;&#13;</programlisting>
<para>where</para>
<itemizedlist>
<listitem>
<para>You have to generate the id attribute with component's UUID.</para>
</listitem>
<listitem>
<para>Generate the required attributes by calling the getOuterAttrs and getInnerAttrs methods of HtmlBasedComponent.</para>
</listitem>
<listitem>
<para>If the view requires some specific JavaScript codes, the z.type attribute might be specified with an unique value to denote the component type.</para>
</listitem>
</itemizedlist>
<para>Notice that each view must have exactly one topmost HTML element – which is img in the above case. The following view is incorrect since it has two topmost element.</para>
<programlisting>&lt;%@ taglib uri="http://www.zkoss.org/dsp/web/core" prefix="c" %&gt;&lt;c:set var="self" value="${requestScope.arg.self}"/&gt;&lt;img id="${self.uuid}" ${self.outerAttrs}${self.innerAttrs}/&gt;&#13;&lt;img/&gt;&#13;</programlisting>
<para>To correct it, you can enclose them with span or div.</para>
<programlisting>&lt;span id="${self.uuid}" ${self.outerAttrs}${self.innerAttrs}/&gt;&#13;    &lt;img/&gt;    &#13;    &lt;img/&gt;    &#13;&lt;/span&gt;&#13;</programlisting></sect2><sect2><title>DSP File Location</title>
<para>Depending on your requirement, you can place the DSP file representing a view in the Web application, or in a JAR library.</para>
<para>If you put in the Web application, say, /WEB-INF/myaddon/button.dsp, just specify the correct path in the mold-uri element as follows.</para>
<programlisting>&lt;component&gt;&#13;    &lt;mold&gt;    &#13;        &lt;mold-name&gt;default&lt;/mold-name&gt;        &#13;        &lt;mold-uri&gt;/WEB-INF/myaddon/button.dsp&lt;/mold-uri&gt;        &#13;    &lt;/mold&gt;    &#13;...&#13;</programlisting>
<para>If you want to put it to a JAR file, you must place it under the /web directory. For example, /web/myaddon/button.dsp is a legal path, and the mold URI is as follows.</para>
<programlisting>&lt;component&gt;&#13;    &lt;mold&gt;    &#13;        &lt;mold-name&gt;default&lt;/mold-name&gt;        &#13;        &lt;mold-uri&gt;~./myaddon/button.dsp&lt;/mold-uri&gt;        &#13;</programlisting>
<para>&lt;/mold&gt;</para>
<para>...</para>
<para>where "~." means the /web directory in a JAR file, or locatable by classpath.</para></sect2><sect2><title>Component Renderer</title>
<para>DSP is an easy way to design a component view, but the performance of EL expressions is much slower than native Java codes. To maximize the performance with native Java codes, you can develop either a Servlet or a so-called component renderer.</para>
<para>A component renderer is a Java class used to render a view directly. It must implement the org.zkoss.zk.ui.render.ComponentRenderer interface, which has only one method: render. For example, the following is the renderer of Image:</para>
<programlisting>public class ImageDefault implements ComponentRenderer {&#13;    public void render(Component comp, Writer out) throws IOException {    &#13;        final Image self = (Image)comp;        &#13;        out.write("&lt;img id=\"");        &#13;        out.write(self.getUuid());        &#13;        out.write("\" z.type=\"zul.widget.Img\"");        &#13;        out.write(self.getOuterAttrs());        &#13;        out.write(self.getInnerAttrs());        &#13;        out.write("/&gt;");        &#13;    }    &#13;}&#13;</programlisting>
<para>Then, the mold URI must start with "class:" and end with the class name, as shown below.</para>
<programlisting>&lt;component&gt;&#13;    &lt;mold&gt;    &#13;        &lt;mold-name&gt;default&lt;/mold-name&gt;        &#13;        &lt;mold-uri&gt;class:org.zkoss.zkmax.zul.render.ImageDefault&lt;/mold-uri&gt;        &#13;</programlisting>
<para>&lt;/mold&gt;</para>
<para>...</para></sect2></sect1><sect1><title>JavaScript Codes</title>
<para>In addition to the visual representation, a component view usually has some codes running at the client to, say, initialize the view and interact with the user. For Ajax devices, the client codes are written in JavaScript. For sake of convenience, we discuss only Ajax devices here.</para><sect2><title>Component Type</title>
<para>Each component that requires the JavaScript codes to run at the client must provide an unique type in the z.type attribute. For example,</para>
<programlisting>&lt;BUTTON id="z_ed_0" z.type="mycomps.MyButton"&gt;I am a button&lt;/BUTTON&gt;&#13;</programlisting>
<para>The syntax is</para>
<programlisting>dir1.dir2.file.Type&#13;</programlisting>
<para>The part after the last dot (.) is the name of the type. The part before the last dot is the path of the JavaScript file that must be loaded (to handle the view). ZK use the type as a naming convention to call the proper JavaScript methods. For example, assume the type is Tx. Then, if the zkT.init method is declared, it will be called when ZK is initializing the component at the client.</para>
<programlisting>zkTp = {}&#13;zkTp.init = function (cmp) {&#13;</programlisting>
<para>zk.listen(cmp, "onClick", zkTp.onclick);</para>
<para>}</para>
<para>zkTp.onclick = function (evt) {</para>
<para>var el = Event.element(evt);</para>
<para>...</para>
<para>};</para></sect2><sect2><title>JavaScript File Location</title>
<para>As described in the previous section. the first part of the z.type attribute is the path of the JavaScript to load. For example, assume the z.type attribute is a.b.c.Tx, then ZK will load the file in the path /web/js/a/b/c.js, right before initializing the view.</para>
<para>Notice that the path must be locatable by classpath, and it always stats at /web/js.</para></sect2></sect1><sect1><title>Initialization and Cleanup</title><sect2><title>Initialization</title>
<para>When ZK Client Engine initializes a component view, it first check if the z.type attribute is defined. If not specified, it means no JavaScript codes required and it ends the initialization of this component.</para>
<para>If z.type is specified, say, widget.SuperButton, ZK Client Engine first loads the JavaScript file, /web/js/widget.js, and then check if any method called zkSuperButton.init. Invoke it if found. We call this method as the init callback.</para>
<para>A component view usually registered event listeners in this method. For example,</para>
<programlisting>zkSuperButton = {} //declare zkSuperButton to hold init, cleanup and other methods&#13;</programlisting>
<para/>
<programlisting>zkSuperButton.init = function (cmp) {&#13;</programlisting>
<para>zk.listen(cmp, "focus", zkau.onfocus);zk.listen(cmp, "blur", zkau.onblur);};</para>
<para>The initialization order is starting from the child, then to the parent, to the parent's parent, and so on.</para>
<para>After init is called, it invokes zkSuperButton.beforeSize and zkSuperButton.onSize, if any, to initialize the size of the view. Components rarely need to provide these two methods, unless they are providing the layout, such as Hbox and Borderlayout. We will talk more about them in the ZK Callbacks section.</para></sect2><sect2><title>Cleanup</title>
<para>When a component is about to be removed, ZK will check if the cleanup callback exists (i.e., zkSuperButton.cleanup in the above example). Invoke it if found.</para>
<para>The order of cleanups is starting from the topmost component, then to its child, to its child's child and so on.</para>
<para>Tip: You don't need to unregister the event listeners you registered in the init callback. ZK Client Engine will unregister them automatically.</para></sect2></sect1><sect1><title>Event Handling</title>
<para>There are two types of event handling. One is ZK callbacks, such as the init and cleanup callback mentioned in the previous section. The other is the browser event listeners.</para><sect2><title>ZK Callbacks</title>
<para>Like the browser event listeners, ZK callbacks are used to handle a situation, such as when the parent's is resized, or when a view becomes visible. Unlike the browser event listeners, they are called by ZK Client Engine directly and registered by use of name convention. In other words, once you declare the method, it will be called automatically.</para>
<para>Tip: ZK scans any callback to register after invoking the init callback, so you can declare them in the init callback.</para>
<para>zkType.init = function (cmp) {zkType.onSize = function (cmp) {};};</para><sect3><title>The init Callback</title>
<programlisting>zkType.init = function (cmp) {&#13;};&#13;</programlisting>
<para>Called when a component is attached to a page or redrawn (due to being invalidated).</para>
<para>The order of invocations is the child first (like Java constructor). The child without a parent is called first, then its child, then its grandchild, and so on.</para></sect3><sect3><title>The cleanup Callback</title>
<programlisting>zkType.cleanup = function (cmp) {&#13;};&#13;</programlisting>
<para>Called when a component is detached, or will be redrawn (due to being invalidated).</para>
<para>When the invalidate method is called at the server, ZK Client Engine will first call the cleanup callback, replace the DOM tree, and then call the init callback.</para>
<para>The order of invocations is the parent first. The topmost parent being cleanup is called first, then its child, then its grandchild, and so on.</para></sect3><sect3><title>The beforeSize and onSize Callback<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
</title>
<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
<programlisting>zkType.beforeSize = function (cmp) {&#13;};&#13;zkType.onSize = function (cmp) {&#13;</programlisting>
<para>};</para>
<para>When the browser window or a resizable parent (such as Borderlayout) is resized, ZK Client Engine first call the beforeSize callback for all components that are affected, and then call the onSize callback for them. In other words, it is a two-pass mechanism. The beforSize callback is used to do some preparation. For example, you might have to reset style.width in the beforeSize callback and then set the correct size in the onSize callback.</para>
<para>The order of invocations is the parent first. The topmost parent that is affected is called first, then its child, then its grandchild, and so on.</para>
<para>Notes</para>
<orderedlist>
<listitem>
<para>The beforeSize and onSize callbacks are also called when initializing a component, so you don't and shalln't handle the size in the init callback.</para>
</listitem>
<listitem>
<para>The browser doesn't notify JavaScript codes when a DOM element is resized, so these two callbacks are actually triggered by the invocation of the zk.beforeSizeAt and zk.onSizeAt methods (by a layout component).</para>
</listitem>
</orderedlist></sect3><sect3><title>The onVisi Callback</title>
<programlisting>zkType.onVisi = function (cmp) {&#13;};&#13;</programlisting>
<para>Called right after a component has become visible.</para>
<para>The order of invocations is the parent first. The topmost parent becoming visible is called first, then its child, then its grandchild, and so on.</para>
<para>Note</para>
<orderedlist>
<listitem>
<para>The browser doesn't notify JavaScript codes when a DOM element becomes visible or invisible, so it won't be called if you set display="none" directly. On the hand, it is called automatically by ZK Client Engine if the visiblity is changed due to the visible property is changed at the server, or due to the invocation of zk.show or action.show at the client.</para>
</listitem>
</orderedlist></sect3><sect3><title>The onHide Callback</title>
<programlisting>zkType.onHide = function (cmp) {&#13;};&#13;</programlisting>
<para>Called right before a component becomes invisible. Notice that when this method is called, the component is still visible.</para>
<para>The order of invocations is the parent first. The topmost parent becoming invisible is called first, then its child, then its grandchild, and so on.</para></sect3><sect3><title>The onScroll Callback<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
</title>
<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
<programlisting>zkType.onScroll = function (cmp) {&#13;};&#13;</programlisting>
<para>Called when the user is scrolling the browser window or one of its ancestor component.</para>
<para>The order of invocations is the parent first. The topmost parent affected by scrolling is called first, then its child, then its grandchild, and so on.</para>
<para>Notes</para>
<orderedlist>
<listitem>
<para>The browser doesn't notify JavaScript codes when the user is scrolling a DOM element (rather than the browser window). It is up to a component view decide whether to invoke zk.onScrollAt.</para>
</listitem>
</orderedlist></sect3></sect2><sect2><title>Browser Event Listeners</title>
<para>You can listen to whatever browser events you care like any other JavaScript codes. However, ZK provide two methods to simplify the job: zk.listen and zk.unlisten. They are not only compatible with all kind of browsers, but also unlisten automatically – so no worry of memory leak. In fact, you rarely need to invoke zk.unlisten.</para>
<programlisting>zk.listen(cmp, "click", function () {zkCkbox.onclick(cmp);});&#13;</programlisting></sect2></sect1><sect1><title>Communicate with the Server</title><sect2><title>Send Requests to the Server</title>
<para>To notify what happens at the client, the view has to send an AU request to the server. At the server the AU request is encapulated as an instance of the org.zkoss.zk.au.AuRequest class. At the client side, the AU request is an object with uuid, cmd, data and other properties. For example,</para>
<programlisting>{uuid: cmp.id, cmd: "onClick", data: [10, 20], ctrl: true}&#13;</programlisting><sect3><title>AU Request</title>
<para>The following is a list of the properties that an AU request might have.</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Property</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>uuid</para>
</entry>
<entry>
<para>[Optional but exactly one of uuid and dtid must be specified]</para>
<para>The UUID of the component that shall receive this request. It is also known as the targeted component.</para>
</entry>
</row>
<row>
<entry>
<para>dtid</para>
</entry>
<entry>
<para>[Optional but exactly one of uuid and dtid must be specified]</para>
<para>The desktop ID that shall receive this request.</para>
</entry>
</row>
<row>
<entry>
<para>cmd</para>
</entry>
<entry>
<para>[Required]</para>
<para>The command ID, such as onClick and onSelect. It is used to search for the command. ZK Update Engine first invokes the getCommand method of the targeted component to look for the component-specific command. If not found, it then invokes the static getCommand method of the AuRequest class to look for the global command.</para>
</entry>
</row>
<row>
<entry>
<para>data</para>
</entry>
<entry>
<para>[Optional; Default: null]</para>
<para>An array of data to pass to the server. It depends on the command. For example, the onClick command accepts a two-element array to indicate the position of the mouse pointer.</para>
</entry>
</row>
<row>
<entry>
<para>ctl</para>
</entry>
<entry>
<para>[Optional; Default: false]</para>
<para>Whether the request is a control command, such as onClick, onOK and so on. To avoid re-execute the long operation twice when an impatient user clicks a button repeatedly, ZK ignores the second control command if two consecutive control commands target the same component and the first one is still in execution.</para>
<para>If any doubt, don't specify it (with true).</para>
</entry>
</row>
<row>
<entry>
<para>ignorable</para>
</entry>
<entry>
<para>[Optional, Default: false]</para>
<para>Whether the request can be ignored if the system is busy or it causes an error. Typical example is the onChanging and onScrolling commands. It is too annoying if not to set ignorable to true.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Basic Utilities to Send Requests</title>
<para>zkau.sendasap and zkau.send are two of most common methods to send an AU request to the server.</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>zkau.send(evt, timeout)</para>
<para>Sends an AU request after the specified milliseconds expires. If there are any pending AU requests, this request will be appended to the end.</para>
<para>evt</para>
<para>The AU request to send.</para>
<para>timeout</para>
<para>The delay before sending the request (unit: milliseconds). If not specified, it is delayed for 0 milliseconds (i.e., calling setTimeout with 0). If a negative value is specified, it means it is a deferrable command and it won't be sent back to the server until another invocation of zkau.send with a non-negative timeout.</para>
<para>To have better performance, it is better to specify -1 if no non-deferrable event listener is registered for this command. It is easy to do this by use of zkau.asapTimeout as shown below.</para>
<programlisting>zkau.send({uuid: cmp.id, cmd: "onChange", data: [cmp.value]},&#13;zkau.asapTimeout(cmp, "onChange"));&#13;</programlisting>
</entry>
</row>
<row>
<entry>
<para>zkau.sendasap(evt, timeout)</para>
<para>Sends an AU request by checking if there is a non-deferrable event listener registered for it. It is a shortcut of the following.</para>
<programlisting>zkau.send(evt, zkau.asapTimeout(evt.uuid, evt.cmd, timeout));&#13;</programlisting>
<para>evt</para>
<para>The AU request to send.</para>
<para>timeout</para>
<para>The delay before sending the request (unit: milliseconds) if non-deferrable.</para>
<para>Notice that it is the timeout used only if there is a non-deferrable event listener registered for it.</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendAhead(evt, timeout)</para>
<para>Sends an AU request by placing it in front of any other pending AU requests.</para>
<para>evt</para>
<para>The AU request to send.</para>
<para>timeout</para>
<para>The delay before sending the request (unit: milliseconds). If not specified, it is delayed for 0 milliseconds (i.e., calling setTimeout with 0). If a negative value is specified, it means it is a deferrable command and it won't be sent back to the server until another invocation of zkau.send with a non-negative timeout.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Callbacks</title>
<para>There are two callbacks you can register to do something before sending AU requests, and after receiving the responses.</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>zkau.addOnSend(func);zkau.removeOnSend(func);</para>
<para>Register a callback function that will be called before AU requests are sending to the server.</para>
<para>It is useful if you are using timer or other mechanism to monitor the DOM element's value. FCKeditor is a typical example. By using the onSend callback, we can check the value again and send back the correct value if changed with other AU requests.</para>
<programlisting>zkau.addOnSend(function() {&#13;//check any change and call zkau.sendAhead to carry the change back&#13;});&#13;</programlisting>
</entry>
</row>
<row>
<entry>
<para>zkau.addOnResponse(script)</para>
<para>Register a callback function that will be called after processing all responses.</para>
<para>script</para>
<para>It could be a function or a string containing JavaScript codes.</para>
</entry>
</row>
<row>
<entry>
<para>zk.addOnLoad(nm, script)</para>
<para>Register a callback function that will be called after a module is loaded.</para>
<para>Applicable: 3.0.6 or later</para>
<para>nm</para>
<para>The module name, such as "zul.sel".</para>
<para>script</para>
<para>It could be a function or a string containing JavaScript codes.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>More Utilities to Send Requests</title>
<para>Here is a list of methods to simply the sending of particular AU requests, such as onClose. They are all based on zkau.send.</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>zkau.sendRemove(uuid)</para>
<para>Sends the remove command to remove the specified component (at the server).</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendOnMove</para>
<para>Sends the onMove command to denote a component is moved.</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendOnSize</para>
<para>Sends the onSize command to denote a component's size is changed.</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendOnZIndex</para>
<para>Sends the onZIndex command to denote the Z-index of a component is changed.</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendOnClose</para>
<para>Sends the onClose command that causes the onClose event being sent to the component. How the onClose event is handled depends on the component. For window, it is detached.</para>
</entry>
</row>
<row>
<entry>
<para>zkau.sendRedraw (ZK 3.1 or later)</para>
<para>Sends the redraw command to redraw all desktops in the browser window. It is usually used to recover from severe errors.</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>Process Request at the Server</title>
<para>When an AU request arrives at the server, it is packed as an instance of org.zkoss.zk.au.AuRequest by associating with a command (org.zkoss.zk.au.Command). The command is responsible to process the associated request. ZK Update Engine doesn't assume anything but invoking the command's process method. Up to the component developer, the command might then update the component's state, post an event or others when process is invoked.</para><sect3><title>Global and Component-specific Commands</title>
<para>There are two kinds of commands: global commands and component-specific commands. The global commands are available to all kind of components, while component-specific commands are available only to a particular kind of components. More precisely, global commands are maintained in a global map, while component-specific commands is maintained in an individual component.</para><sect4><title>How to Identify a Command</title>
<para>ZK takes two steps to look for the command for an AU request:</para>
<orderedlist>
<listitem>
<para>ZK first check whether any component-specific command is defined for the command ID of the AU request. This is done by invoking the getCommand method of the ComponentCtrl interface.</para>
</listitem>
<listitem>
<para>Then, ZK check whether any global command is defined for the command ID of the AU request, if no component-specific command is found. This is done by invoking the static method called getCommand of the AuRequest class.</para>
</listitem>
</orderedlist></sect4><sect4><title>Built-in Commands</title>
<para>There are a lot of built-in AU responses such as InputCommand, MouseCommand, KeyCommand and so on in the org.zkoss.zk.au.in package. All of them are global commands. In other words, they are available to all components.</para>
<para>To minimize the development effort, use the built-in commands if possible.</para></sect4></sect3><sect3><title>Develop Your Own Command</title>
<para>If none of built-in command fulfills your requirement, you can develop your own command.</para><sect4><title>Develop Your Own Component-specific Command</title>
<para>First, you have to decide if the command is available to two or more different kinds of components. If it is unique to particular kind of components, you shall develop a component-specific command:</para>
<orderedlist>
<listitem>
<para>Extend from ComponentCommand and implement the process method.</para>
</listitem>
<listitem>
<para>Return the command when the getCommand method of the component is called.</para>
</listitem>
</orderedlist>
<para>For example,</para>
<programlisting>public class SuperButton extends AbstractComponent {&#13;    private static Command _flycmd = new ComponentCommand("onFly", 0) {    &#13;        protected void process(AuRequest request) {        &#13;            final SuperButton btn = (SuperButton)request.getComponent();            &#13;            btn.doFly();            &#13;                    Events.postEvent(new Event(getId(), btn, request.getData()));}                    &#13;    }; //note: it won't register itself to the global map    &#13;        //because it is extended from ComponentCommand)        &#13;    public Command getCommand(String cmdId) {    &#13;        return "fly".equals(cmdId) ? _flycmd: null;        &#13;    }    &#13;    void doFly() {    &#13;        //whatever        &#13;    }    &#13;}&#13;</programlisting></sect4><sect4><title>Develop Your Own Global Command</title>
<para>If the command is available to two or more other kinds of components, you might consider to implement a global command<footnote>
<para>Of course, you can still implement as component-specific – just return it in several implementations of the getCommand method.</para>
</footnote>. Since it is available to all components, make sure the naming doesn't conflict with others.</para>
<para>A global command is extended from the org.zkoss.zk.au.Command class.</para>
<programlisting>class FlyCommand extends Command {&#13;</programlisting>
<para>public FlyCommand(String id, int flags) {super(id, flags);</para>
<para>}</para>
<para>protected process(AuRequest request) {</para>
<programlisting>        final SuperButton btn = (SuperButton)request.getComponent();        &#13;        btn.doFly();        &#13;</programlisting>
<para>Events.postEvent(new Event(getId(), btn, request.getData()));}</para>
<para>}</para>
<para>Since it is global, you have to instantiate an instance at startup. A typical usage is to declare a static instance of a class. For example,</para>
<programlisting>public class SuperButton extends AbstractComponent {&#13;    static {    &#13;            new FlyCommand("onFly", 0); //register itself automatically}            &#13;...&#13;</programlisting>
<para>It is interesting to note you don't need to keep a reference to a global command. It is registered automatically as soon as it is instantiated.</para>
<para>Also notice you must instantiate them in a class that will be loaded – the component's class is always loaded (if it is registered in lang.xml or lang-addon.xml).</para></sect4><sect4><title>The getExtraCtrl Method</title>
<para>When implementing a command, you can call any method you want. However, ZK introduces a special method to encapsulate the implementation to be invisible to application developers. This method is called getExtraCtrl (in the ComponentCtrl interface) – aka., extra control.</para>
<programlisting>public Object getExtraCtrl();&#13;</programlisting>
<para>Note: You don't have to follow this. First, it is simply a design pattern we use to implement components. Second, command related methods can be encapsulated well if you use only component-specific commands.</para>
<para>Here is how it use. Let us assume you don't want doFly to be accessed by applications. The easiest way is to declare it as private or protected and then implement it as a component-specific command as we did in the Develop Your Own Component-specific Command section.</para>
<para>However, what if FlyCommand has to be a global command? First, you can design an interface, say, Flyable.</para>
<programlisting>public interface Flyable {&#13;</programlisting>
<para>public void doFly();</para>
<para>}</para>
<para>Then, in the component implementation, we can do as follows.</para>
<programlisting>public class SuperButton extends AbstractComponent {&#13;    public Object newExtraCtrl() {    &#13;        return new ExtraCtrl();        &#13;    }    &#13;    private void doFly() { //make it inaccessible    &#13;        //whatever        &#13;    }    &#13;    private class ExtraCtrl implements Flyable {    &#13;</programlisting>
<para>public void doFly() {</para>
<para>SuperButto.this.doFly();</para>
<para>}</para>
<para>}</para>
<para>...</para>
<para>where we override newExtraCtrl rather than getExtraCtrl, since getExtraCtrl handles the lifecycle of the extra control and will invoke newExtraCtrl to instantiate the object.</para>
<para>Finally, you can implement FlyCommand this way:</para>
<programlisting>class FlyCommand extends Command {&#13;</programlisting>
<para>public FlyCommand(String id, int flags) {super(id, flags);</para>
<para>}</para>
<para>protected process(AuRequest request) {</para>
<programlisting>        final Component comp = request.getComponent();        &#13;        if (comp instanceof Flyable)        &#13;            ((Flyable)comp).doFly();            &#13;</programlisting>
<para>Events.postEvent(new Event(getId(), comp, request.getData()));</para>
<para>}</para>
<para>}</para></sect4></sect3></sect2><sect2><title>Process Smart Updates</title>
<para>Handling the smart updates sent from the server is straightforward. Just declare a callback called setAttr. For example, assume the component type is SuperButton, then the setAttr callback is as follows.</para>
<programlisting>zkSuperButton.setAttr = function (cmp, name, value) {&#13;</programlisting>
<para>if ("fly" == name) {</para>
<para>//whatever</para>
<para>}</para>
<para>return false;</para>
<para>}</para>
<para>The return value is whether you want the default behavior to take place, i.e., whether to update the attribute. More precisely, zkau.setAttr(cmp, name, value) will be called if false is returned.</para>
<para>If you prefer to update the attribute first, you can invoke zkau.setAttr manually. For example,</para>
<programlisting>zkSuperButton.setAttr = function (cmp, name, value) {&#13;</programlisting>
<para>if ("disabled" == name) {</para>
<para>zkau.setAttr(cmp, name, value); //update cmp.disabled first</para>
<para>//whatever</para>
<para>return true; //attribute has been updated</para>
<para>}</para>
<para>return false;</para>
<para>}</para><sect3><title>Smart Updates with Multiple Values<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
</title>
<footnote>
<para>Available in ZK 3.0.5 or later.</para>
</footnote>
<para>When implementing a sophisticated component, you might want to pass multiple values (i.e., an array of values) to an attribute. At the server side, you invoke the smartUpdateValues method. At the client, the setAttr callback will be called with additional arguments. For example, at the server, you invoke</para>
<programlisting>smartUpdateValues("fly", new String[] {"low", "fast"});&#13;</programlisting>
<para>Then, at the client, you can handle it as follows.</para>
<programlisting>zkSuperButton.setAttr = function (cmp, name, value1, value2) {&#13;</programlisting>
<para>if ("fly" == name) {</para>
<para>fly(value1, value2);</para>
<para>...</para>
<para>JavaScript Tip: You can use arguments.length to determine how many arguments are passed.</para></sect3></sect2><sect2><title>Process AU Responses</title>
<para>There are many built-in responses you can use (in the org.zkoss.zk.au.out package). However, the invoke (AuInvoke) and script (AuScript) responses are almost all you need.</para><sect3><title>The invoke Response</title>
<para>The invoke response is used to invoke a callback. For example, you can send an AU response at the server as follows.</para>
<programlisting>    public void fly() {response("ctrl", new AuInvoke(this, "fly", "low", "fast"));}    &#13;</programlisting>
<para>Then, at the client, the following callback will be called.</para>
<programlisting>    zkSuperButton.fly = function (cmp, height, speed) {//whatever    &#13;}&#13;</programlisting>
<para>Tip: As shown above, we can use a AU response and a smart update to do the similar task (fly in this example). But, there is a difference: the AU response is sent even if the component is invalidated, while the smart update won't.</para>
<para>Thus, if the init callback will handle everything, the smart update shall be used (otherwise, you will do it twice when it is invalidated).</para></sect3><sect3><title>The script Response</title>
<para>The script response is used to execute any JavaScript codes at the client, not just the callbacks. For example,</para>
<programlisting>public void fly() {&#13;    response("ctrl",    &#13;</programlisting>
<para>new AuScript(this, "zkSuperButton.fly('" + getUuid() + "','low','fast')"));</para>
<para>}</para>
<para>Since the JavaScript codes are hardcoded, it is sometimes not easy to support multiple molds. For example, assume you want to use the same Java class to implement another mold. Then, the JavaScript codes that implements fly might be different. So, you might have to do as follows.</para>
<programlisting>public void fly() {&#13;    response("ctrl",    &#13;</programlisting>
<para>new AuScript(this,</para>
<para>("SuperButton".equals(getMold()) ? "zkSuperButton": "zkGiantButton")</para>
<para>+ ".fly('" + getUuid() + "','low','fast')"));</para>
<para>}</para>
<para>On the other hand, if you use the invoke response, you can have the same response but define a different component type, say GiantButton. Then, you don't modify Java class. Rather, provide another callback:</para>
<programlisting>    zkGiantButton.fly = function (cmp, height, speed) {//whatever    &#13;</programlisting>
<para>}</para>
<para>In general, the invoke response is recommended if applicable.</para></sect3><sect3><title>Develop Your Own AU Responses</title>
<para>Unlike the AU request's commands, you rarely need to develop your own AU response since the invoke response can serve almost everything. However, if you prefer to provide your own response, you can follow the instructions described in this section.</para>
<para>First, you have to implement a Java class extending from the org.zkoss.zk.au.AuResponse class.</para>
<programlisting>public AuFly extends AuResponse {&#13;    public AuFly(SuperButton comp, String height, String speed) {    &#13;</programlisting>
<para>super("fly", comp, new String[] {comp.getUuid(), height, speed});</para>
<para>}</para>
<para>}</para>
<para>where "fly" is the response name, and the third argument (String[]) of AuResponse's constructor will be passed to the client. The response name must be unique. The third argument is called the response data.</para>
<para>Then, at the client side, you shall provide a method called zkau.cmd1.fly to handle it.</para>
<programlisting>zkau.cmd1.fly = function (uuid, cmp, height, speed) {&#13;</programlisting>
<para>//whatever</para>
<para>}</para>
<para>There are two set of response handlers: zkau.cmd0 and zkau.cmd1. zkau.cmd0 is used to handle responses that are applied to the whole browser window, while zkau.cmd1 is for individual component.</para>
<para>If zkau.cmd1 is overridden, the first element of the response data must be the component UUID (comp.getUuid() in the above example). Then, ZK Client Engine will convert it to a reference to a component, and then invoke the response's handler with UUID and the reference as the first two arguments (refer to zkau.cmd.fly in the above example).</para></sect3></sect2></sect1><sect1><title>JavaScript Utilities</title>
<para>To be added.</para></sect1></chapter>
<chapter>
<title>4. Configuration</title>
<para>The configuration provides the component definitions that can be accessed by ZK applications. There are two types of configuration: the language definition and the language addon. The language definition is used to define a new language (such as xul/html, xhtml, and xml), while the language addon enhances an existent language. The syntax are very similar and we will discuss the language addon first.</para><sect1><title>Language Addon</title>
<para>The language addon is a XML file providing the component definitions and other language features.</para><sect2><title>Location of the Language Addon</title>
<para>Location of the language addon depends on how you pack your component definitions: JAR or WAR.</para><sect3><title>Location in a JAR File</title>
<para>If you pack the component definition(s) in a JAR file, the language addon must be named lang-addon.xml and placed at the /metainfo/zk directory accessible by the classpath.</para></sect3><sect3><title>Location in a WAR File</title>
<para>If you pack the component definition(s) in a WAR file, you can specify the path of the XML file in /WEB-INF/zk.xml. For example, let us assume the path of the XML file is /WEB-INF/zk/lang-addon.xml, then specify the following in /WEB-INF/zk.xml. You can specify multiple language addons.</para>
<programlisting>&lt;language-config&gt;&#13;    &lt;addon-uri&gt;/WEB-INF/zk/lang-addon.xml&lt;/addon-uri&gt;    &#13;&lt;/language-config&gt;&#13;</programlisting></sect3></sect2><sect2><title>A Sample of the Language Addon</title>
<para>Here is a sample of the language addon (ZK FCKeditor).</para>
<programlisting>&lt;language-addon&gt;&#13;    &lt;addon-name&gt;fckez&lt;/addon-name&gt;    &#13;&#13;    &lt;version&gt;    &#13;        &lt;version-class&gt;org.zkforge.fckez.Version&lt;/version-class&gt;        &#13;        &lt;version-uid&gt;2.5.1_1&lt;/version-uid&gt;        &#13;        &lt;zk-version&gt;2.4.0&lt;/zk-version&gt;&lt;!-- or later →        &#13;    &lt;/version&gt;    &#13;&#13;    &lt;language-name&gt;xul/html&lt;/language-name&gt;    &#13;        &#13;    &lt;javascript-module name="fckez.fckez" version="2.5.1_1"/&gt;    &#13;        &#13;    &lt;zscript&gt;    &#13;    import org.zkforge.fckez.*;    &#13;    &lt;/zscript&gt;    &#13;&#13;    &lt;component&gt;    &#13;        &lt;component-name&gt;fckeditor&lt;/component-name&gt;        &#13;        &lt;component-class&gt;org.zkforge.fckez.FCKeditor&lt;/component-class&gt;        &#13;        &lt;mold&gt;        &#13;            &lt;mold-name&gt;default&lt;/mold-name&gt;            &#13;            &lt;mold-uri&gt;~./fckez/fckeditor.dsp&lt;/mold-uri&gt;            &#13;        &lt;/mold&gt;        &#13;    &lt;/component&gt;    &#13;&lt;/language-addon&gt;&#13;</programlisting></sect2><sect2><title>Headers of the Language Addon</title>
<para>The headers of the language addon specifies the name of the addon, the language to addon, and so on.</para><sect3><title>The addon-name Element</title>
<para>[Required]</para>
<programlisting>&lt;addon-name&gt;name&lt;/addon-name&gt;&#13;</programlisting>
<para>Specifies the unique name of the language addon.</para></sect3><sect3><title>The depends Element</title>
<para>[Optional]</para>
<programlisting>&lt;depends&gt;another1, another2&lt;/depends&gt;&#13;</programlisting>
<para>Specifies a list of the names of other addons, which this addon depends on. If specified, this addon won't be loaded until all depended addons are loaded. If not specified, the loading sequence is unpredictable.</para></sect3><sect3><title>The language-name Element</title>
<para>[Required]</para>
<programlisting>&lt;language-name&gt;xul/html&lt;/language-name&gt;&#13;</programlisting>
<para>Specified the language that this addon shall be added to.</para></sect3><sect3><title>The verson Element</title>
<para>[Optional<footnote>
<para>It is required for ZK 3.0.4 and prior.</para>
</footnote>]</para>
<programlisting>&lt;version&gt;&#13;    &lt;version-class&gt;org.zkforge.fckez.Version&lt;/version-class&gt;    &#13;    &lt;version-uid&gt;2.5.1_1&lt;/version-uid&gt;    &#13;    &lt;zk-version&gt;2.4.0&lt;/zk-version&gt;&lt;!-- or later →    &#13;&lt;/version&gt;&#13;</programlisting>
<para>There are two parts: addon version and ZK version. Addon version is specified in version-uid element. In certain environments, it is possible to have several versions of JAR file containing the same set of component definitions<footnote>
<para>For example, you might have an older version in WEB-INF/lib, and a newer version in shared/lib.</para>
</footnote>. To ensure the correct XML file is loaded, you have to specify a class carrying the version. The class must have a static data member called UID as shown below.</para>
<programlisting>public class Version {&#13;    public static final String UID = "2.5.1_1";    &#13;}&#13;</programlisting>
<para>Then, ZK will compare UID with the value specified in version-uid, and the addon is ignored if not matched – it means the XML file is not from the same JAR file being loaded.</para>
<para>ZK Version that this addon requires is specified in the zk-version element. The addon is ignored if ZK installed is an older version.</para></sect3><sect3><title>The javascript-module Element</title>
<para>[Optional]</para>
<programlisting>&lt;javascript-module name="fckez.fckez" version="2.5.1_1"/&gt;&#13;</programlisting>
<para>Specifies the version of JavaScript codes that will run at the client. If specified, ZK will mangle the URL of JavaScript files with the version, such that the browsers won't use the wrong cached version. It is recommended to change the version each time you deliver a new version of your components (so JavaScript files with the most update version will be loaded by the browser).</para></sect3></sect2><sect2><title>Component Definitions</title>
<para>There are two kinds components: macro and primitive components. By macro we mean to implement a component based on a ZUML page. By primitive we mean to implement the Component interface (actually extending from AbstractComponent, HtmlBasedComponent and others). This guide focuses on the implementation of primitive components. For implementation of macro components, refer to the Developer's Guide.</para><sect3><title>Define a Primitive Component</title>
<programlisting>&lt;component&gt;&#13;    &lt;component-name&gt;fckeditor&lt;/component-name&gt;    &#13;    &lt;component-class&gt;org.zkforge.fckez.FCKeditor&lt;/component-class&gt;    &#13;    &lt;mold&gt;    &#13;        &lt;mold-name&gt;default&lt;/mold-name&gt;        &#13;        &lt;mold-uri&gt;~./fckez/fckeditor.dsp&lt;/mold-uri&gt;        &#13;    &lt;/mold&gt;    &#13;&lt;/component&gt;&#13;</programlisting><sect4><title>The component-class Element</title>
<para>[Required]</para>
<para>Specifies the implementation class of this kind of components.</para></sect4><sect4><title>The component-name Element</title>
<para>[Required]</para>
<para>Specifies the component name. If an existent component is defined with the same name, the existent component is completely invisible in this page.</para></sect4><sect4><title>The mold Element</title>
<para>[Optional]</para>
<programlisting>&lt;mold&gt;&#13;    &lt;mold-name&gt;default&lt;/mold-name&gt;    &#13;    &lt;mold-uri&gt;~./fckez/fckeditor.dsp&lt;/mold-uri&gt;    &#13;&lt;/mold&gt;&#13;</programlisting>
<para>Specifies a mold. You can have any number of molds for one component definition.</para></sect4><sect4><title>The mold-name Element</title>
<para>[Required if mold is specified]</para>
<para>Specified the mold name. The default mold shall be named as default.</para></sect4><sect4><title>The mold-uri Element</title>
<para>[Required if mold is specified][EL is allowed]</para>
<para>Specifies the mold URI.</para></sect4><sect4><title>The text-as Element</title>
<para>[Optional]</para>
<para>Specifies a property name that the text inside the element in the ZUL file will be assigned to. For example, comboitem declares text-as as follows.</para>
<programlisting>&lt;component&gt;&#13;    &lt;component-name&gt;comboitem&lt;/component-name&gt;    &#13;    &lt;text-as&gt;content&lt;/text-as&gt;    &#13;...&#13;</programlisting>
<para>Then, the following ZUL fragment</para>
<programlisting>&lt;comboitem&gt;This is the text assigned to the content property&lt;/comboitem&gt;&#13;</programlisting>
<para>is equivalent to</para>
<programlisting>&lt;comboitem content="This is the text assigned to the content property"/&gt;&#13;</programlisting></sect4><sect4><title>The custom-attribute Element</title>
<para>[Optional]</para>
<programlisting>&lt;custom-attribute&gt;&#13;    &lt;attribute-name&gt;my.attr&lt;/attribute-name&gt;    &#13;    &lt;attribute-value&gt;my value&lt;/attribute-value&gt;    &#13;&lt;/custom-attribute&gt;&#13;</programlisting>
<para>Specifies an attribute in the component scope. In other words, the setAttribute method of the Component interface will be called to store the attribute.</para></sect4><sect4><title>The property Element</title>
<para>[Optional]</para>
<programlisting>&lt;property&gt;&#13;    &lt;property-name&gt;border&lt;/property-name&gt;    &#13;    &lt;property-value&gt;blue&lt;/property-value&gt;    &#13;&lt;/property&gt;&#13;</programlisting>
<para>Specifies a property to initialize. For example, assume the property name is border, then the setBorder method will be called to set the value specified in property-value.</para></sect4><sect4><title>The annotation Element</title>
<para>[Optional]</para>
<programlisting>&lt;annotation&gt;&#13;    &lt;annotation-name&gt;&lt;/annotation-name&gt;    &#13;    &lt;property-name&gt;&lt;/property-name&gt;    &#13;    &lt;attribute&gt;    &#13;        &lt;attribute-name&gt;&lt;/attribute-name&gt;        &#13;        &lt;attribute-value&gt;&lt;/attribute-value&gt;        &#13;    &lt;/attribute&gt;    &#13;    &lt;attribute&gt;    &#13;        &lt;attribute-name&gt;&lt;/attribute-name&gt;        &#13;        &lt;attribute-value&gt;&lt;/attribute-value&gt;        &#13;    &lt;/attribute&gt;    &#13;&lt;/annotation&gt;&#13;</programlisting>
<para>Specifies an annotation to the component definition. It can be accessed by the getAnnotationMap method of the ComponentDefinition interface.</para></sect4></sect3><sect3><title>Define a Macro Component</title>
<programlisting>&lt;component&gt;&#13;    &lt;component-name&gt;mycomp&lt;/component-name&gt;    &#13;    &lt;component-class&gt;com.mine.Mycomp&lt;/component-class&gt;    &#13;    &lt;macro-uri&gt;~./mine/mycomp.zul&lt;/macro-uri&gt;    &#13;&lt;/component&gt;&#13;</programlisting>
<para>The syntax of a macro definition is similar to the definition of the primitive component, except</para>
<itemizedlist>
<listitem>
<para>mold is not allowed</para>
</listitem>
<listitem>
<para>macro-uri is required to specify the template (a ZUML file) used to generate the macro component</para>
</listitem>
</itemizedlist><sect4><title>The macro-uri Element</title>
<para>[Required][EL is not allowed]</para>
<para>Specifies the URI of the ZUML page, which is used as the template to create the macro component.</para></sect4><sect4><title>The inline Element</title>
<para>[Optional][Default: false][EL is not allowed]</para>
<programlisting>&lt;inline&gt;true&lt;/inline&gt;&#13;</programlisting>
<para>Specifies whether this is an inline macro component.</para></sect4></sect3><sect3><title>Extend from Existent Component</title>
<programlisting>&lt;component&gt;&#13;    &lt;component-name&gt;funnybutton&lt;/component-name&gt;    &#13;    &lt;extends&gt;button&lt;/extends&gt;    &#13;&lt;/component&gt;&#13;</programlisting>
<para>In addition to define a new component, you can extend from the existent one. By extending, it inherits all properties such the as component class, molds and so on. You can override any element you want. The syntax is the same, but they are optional except the component-name and extends element.</para><sect4><title>extends</title>
<para>[Required]</para>
<para>Specifies the name of the component definition to extend from (aka., extendee). If specified, the extendee's definition will be loaded to initialize the new component definition. In other words, it extends the existent definition instead of defining a brand-new one.</para></sect4></sect3></sect2></sect1><sect1><title>Language Definition</title>
<para>The language definition is a XML file definition a new language, which includes component definitions and other language features.</para>
<para>The syntax of the language definition is similar to the language addon except the location and the headers are a bit different.</para><sect2><title>Location of the Language Definition</title>
<para>The language definition must be named lang.xml and placed at the /metainfo/zk directory accessible by the classpath.</para></sect2><sect2><title>Headers of the Language Definition</title><sect3><title>The language-name Element</title>
<para>[Required]</para>
<programlisting>&lt;language-name&gt;xul/html&lt;/language-name&gt;&#13;</programlisting>
<para>Specified the language name that uniquely identifies this langauge.</para></sect3><sect3><title>The device-type Element</title>
<para>[Required]</para>
<programlisting>&lt;&lt;device-type&gt;ajax&lt;/device-type&gt;&#13;</programlisting>
<para>Specified the device type, such as ajax, xml, mil and hil.</para></sect3><sect3><title>The namespace Element</title>
<para>[Required]</para>
<programlisting>&lt;namespace&gt;http://www.zkoss.org/2005/zul&lt;/namespace&gt;&#13;</programlisting>
<para>Specified the namespace that also uniquely identifies this language.</para></sect3><sect3><title>The extension Element</title>
<para>[Required; Multiple]</para>
<programlisting>&lt;extension&gt;zul&lt;/extension&gt;&#13;&lt;extension&gt;xul&lt;/extension&gt;&#13;</programlisting>
<para>Specified the file extension that shall be considered as using this language. For example, if zul is specified, this language will be used as the default language for all files with the .zul extension. Of course, the file can change the language later with the page directive.</para></sect3><sect3><title>The version Element</title>
<para>[Optional<footnote>
<para>It is required for ZK 3.0.4 and prior.</para>
</footnote>]</para>
<programlisting>&lt;version&gt;&#13;    &lt;version-class&gt;org.zkoss.zul.Version&lt;/version-class&gt;    &#13;    &lt;version-uid&gt;3.0.5&lt;/version-uid&gt;    &#13;    &lt;zk-version&gt;3.0.0&lt;/zk-version&gt;&lt;!-- or later →    &#13;&lt;/version&gt;&#13;</programlisting>
<para>There are two parts: language version and ZK version. Language version is specified in version-uid element. In certain environments, it is possible to have several versions of JAR file containing the same set of component definitions<footnote>
<para>For example, you might have an older version in WEB-INF/lib, and a newer version in shared/lib.</para>
</footnote>. To ensure the correct XML file is loaded, you have to specify a class carrying the version. The class must have a static data member called UID as shown below.</para>
<programlisting>public class Version {&#13;    public static final String UID = "3.0.5";    &#13;}&#13;</programlisting>
<para>Then, ZK will compare UID with the value specified in version-uid, and the language is ignored if not matched – it means the XML file is not from the same JAR file being loaded.</para>
<para>ZK Version that this language requires is specified in the zk-version element. The language is ignored if ZK installed is an older version.</para></sect3><sect3><title>The javascript Element</title>
<para>[Optional][Multiple]</para>
<programlisting>&lt;javascript src="~./js/zk/zk.js.dsp" charset="UTF-8"/&gt;&#13;</programlisting>
<para>Specifies a JavaScript file that must be loaded when a ZUML page is sent to the browser. It is actually generated inside HTML HEAD tag.</para></sect3><sect3><title>The stylesheet Element</title>
<para>[Optional][Multiple]</para>
<programlisting>&lt;stylesheet href="~./zul/css/norm*.css.dsp*" type="text/css"/&gt;&#13;</programlisting>
<para>Specifies a CSS file that must be loaded when a ZUML page is sent to the browser. It is actually generated inside HTML HEAD tag.</para></sect3><sect3><title>The zscript Element</title>
<para>[Optional][Multiple]</para>
<programlisting>&lt;zscript language="Java"&gt;&#13;void alert(String m) {&#13;    Messagebox.show(m);    &#13;}&#13;&lt;/zscript&gt;&#13;</programlisting>
<para>Specifies a snippet of zscript codes that will be evaluated before ZK evaluates the zscript codes embedded in a ZUML page. The snippet is evaluated only once. If you want it to be evaluated each time the embedded zscript codes is evaluated, you can specify the each-time attribute as follows.</para>
<programlisting>&lt;zscript language="Groovy" each-time="true"&gt;&#13;import java.util.*&#13;&lt;/zscript&gt;&#13;</programlisting></sect3><sect3><title>The mold Element</title>
<para>[Optional][Multiple]</para>
<programlisting>&lt;mold&gt;&#13;    &lt;mold-name&gt;desktop&lt;/mold-name&gt;    &#13;    &lt;mold-uri&gt;~./zul/html/desktop.dsp&lt;/mold-uri&gt;    &#13;&lt;/mold&gt;&#13;</programlisting>
<para>Specifies the URL used to render a desktop or a page. Only three mold names are accepeted: desktop, page and complete. The desktop mold is used if a ZK page is standalone, i.e., not included by another page. The page mold is used if a ZK page is included by another page. The complete mold is used if a page is declared to be complete. , i.e., the complete attribute of the page directive is true; refer to the Developer's Reference.</para></sect3><sect3><title>The label-template Element</title>
<para>[Required]</para>
<programlisting>&lt;label-template&gt;&#13;    &lt;component-name&gt;label&lt;/component-name&gt;    &#13;    &lt;component-attribute&gt;value&lt;/component-attribute&gt;    &#13;&lt;/label-template&gt;&#13;</programlisting>
<para>Specifies the component that is used to represent a label. When ZK loader encounters a piece of text, it converts it to a component specified here. For example, based on the label-template example listed above, the following codes</para>
<programlisting>&lt;window&gt;&#13;Test&#13;&lt;/window&gt;&#13;</programlisting>
<para>is equivalent to</para>
<programlisting>&lt;window&gt;&#13;&lt;label value="Test"/&gt;&#13;&lt;/window&gt;&#13;</programlisting><sect4><title>The raw Element</title>
<para>[Optional]</para>
<programlisting>&lt;label-template&gt;&#13;    &lt;component-name&gt;label&lt;/component-name&gt;    &#13;    &lt;component-attribute&gt;value&lt;/component-attribute&gt;    &#13;    &lt;raw/&gt;    &#13;&lt;/label-template&gt;&#13;</programlisting>
<para>Specifies whether the language prefer to use the raw labels.</para>
<para>By raw labels we mean the text shall not be trimmed and shall be generated directly to the output (rather than wrapping with, say, SPAN).</para>
<para>For example, the ZHTML and ZML languages specify this option, while the ZUL language doesn't.</para></sect4></sect3><sect3><title>The macro-template Element</title>
<para>[Required]</para>
<programlisting>&lt;macro-template&gt;&#13;    &lt;macro-class&gt;org.zkoss.zk.ui.HtmlMacroComponent&lt;/macro-class&gt;    &#13;    &lt;macro-uri&gt;~./zul/html/macro.dsp&lt;/macro-uri&gt;    &#13;&lt;/macro-template&gt;&#13;</programlisting>
<para>Specifies the class used to represent a macro component, and the URI used to render it.</para>
<para>The class specified in the macro-class element must implement the org.zkoss.zk.ui.ext.Macro interface.</para></sect3><sect3><title>The native-template Element</title>
<para>[Required]</para>
<programlisting>&lt;native-template&gt;&#13;    &lt;native-class&gt;org.zkoss.zk.ui.HtmlNativeComponent&lt;/native-class&gt;    &#13;&lt;/native-template&gt;&#13;</programlisting>
<para>Specifies the class used to represent a native component. It must implement the import org.zkoss.zk.ui.ext.DynamicTag and org.zkoss.zk.ui.ext.Native interfaces</para></sect3></sect2></sect1></chapter>
</book>
